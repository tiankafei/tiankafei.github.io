(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{468:function(t,s,e){"use strict";e.r(s);var a=e(42),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"分布式锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" 分布式锁")]),t._v(" "),e("h2",{attrs:{id:"特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),e("ol",[e("li",[t._v("互斥性：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁")]),t._v(" "),e("li",[t._v("安全性：锁只能被持有该锁的客户端删除，不能由其它客户端删除")]),t._v(" "),e("li",[t._v("防死锁：获取锁的客户端因为某些原因（如down机等），需要设置一个策略把锁释放掉，否则其他客户端再也无法获取到该锁")]),t._v(" "),e("li",[t._v("容错性：当部分服务节点down机时，客户端仍然能够获取锁和释放锁")])]),t._v(" "),e("h2",{attrs:{id:"基于数据库行级锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于数据库行级锁"}},[t._v("#")]),t._v(" 基于数据库行级锁")]),t._v(" "),e("h2",{attrs:{id:"基于zookeeper的分布式锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于zookeeper的分布式锁"}},[t._v("#")]),t._v(" 基于Zookeeper的分布式锁")]),t._v(" "),e("h2",{attrs:{id:"基于redis的分布式锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于redis的分布式锁"}},[t._v("#")]),t._v(" 基于Redis的分布式锁")]),t._v(" "),e("h3",{attrs:{id:"redis单节点加锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis单节点加锁"}},[t._v("#")]),t._v(" Redis单节点加锁")]),t._v(" "),e("blockquote",[e("p",[t._v("基于Redis命令：SET key value NX EX max-lock-time")])]),t._v(" "),e("h3",{attrs:{id:"redisson加锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redisson加锁"}},[t._v("#")]),t._v(" Redisson加锁")]),t._v(" "),e("p",[t._v("有5台毫无任何关系的redis实例，参与分布式锁的竞争时，如果有一个线程过半通过，得到了3把锁，此时，其中有一台redis挂了，就剩下2把锁了，当这台挂的实例起来之后，由于数据的丢失，另外一个线程也能获得过半的实例个数，此时就会出现被多次加锁的情况：解决方案，让挂了的实例延迟启动，启动的时间要求大于锁的有效期时间")])])}),[],!1,null,null,null);s.default=r.exports}}]);