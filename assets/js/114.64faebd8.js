(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{467:function(a,t,s){"use strict";s.r(t);var e=s(42),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"eureka自我保护机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#eureka自我保护机制"}},[a._v("#")]),a._v(" eureka自我保护机制")]),a._v(" "),s("h2",{attrs:{id:"自我保护背景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自我保护背景"}},[a._v("#")]),a._v(" 自我保护背景")]),a._v(" "),s("p",[a._v("首先对Eureka注册中心需要了解的是Eureka各个节点都是平等的，没有ZK中角色的概念， 即使N-1个节点挂掉也不会影响其他节点的正常运行。")]),a._v(" "),s("p",[a._v("默认情况下，**如果Eureka Server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，Eureka Server将会移除该实例。**但是当网络分区故障发生时，微服务与Eureka Server之间无法正常通信，而微服务本身是正常运行的，此时不应该移除这个微服务，所以引入了自我保护机制。")]),a._v(" "),s("h2",{attrs:{id:"自我保护机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自我保护机制"}},[a._v("#")]),a._v(" 自我保护机制")]),a._v(" "),s("p",[a._v("官方对于自我保护机制的定义：")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("自我保护模式正是一种针对网络异常波动的安全保护措施，使用自我保护模式能使Eureka集群更加的健壮、稳定的运行。\n")])])]),s("p",[a._v("自我保护机制的工作机制是："),s("strong",[a._v("如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制")]),a._v("，此时会出现以下几种情况：")]),a._v(" "),s("ol",[s("li",[a._v("Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务")]),a._v(" "),s("li",[a._v("Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用")]),a._v(" "),s("li",[a._v("当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中")])]),a._v(" "),s("p",[a._v("因此Eureka Server可以很好的应对因网络故障导致部分节点失联的情况，而不会像ZK那样如果有一半不可用的情况会导致整个集群不可用而变成瘫痪。")]),a._v(" "),s("h2",{attrs:{id:"自我保护开关"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自我保护开关"}},[a._v("#")]),a._v(" 自我保护开关")]),a._v(" "),s("p",[a._v("Eureka自我保护机制，通过配置 "),s("code",[a._v("eureka.server.enable-self-preservation")]),a._v(" 来"),s("code",[a._v("true")]),a._v("打开/"),s("code",[a._v("false")]),a._v("禁用自我保护机制，默认打开状态，建议生产环境打开此配置。")]),a._v(" "),s("h2",{attrs:{id:"开发环境配置"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开发环境配置"}},[a._v("#")]),a._v(" 开发环境配置")]),a._v(" "),s("p",[a._v("开发环境中如果要实现服务失效能自动移除，只需要修改以下配置。")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("注册中心关闭自我保护机制，修改检查失效服务的时间")]),a._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("eureka")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("server")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n     "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("enable-self-preservation")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean important"}},[a._v("false")]),a._v("\n     "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("eviction-interval-timer-in-ms")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3000")]),a._v("\n")])])])]),a._v(" "),s("li",[s("p",[a._v("微服务修改减短服务心跳的时间")]),a._v(" "),s("div",{staticClass:"language-yaml extra-class"},[s("pre",{pre:!0,attrs:{class:"language-yaml"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("eureka")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("instance")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 默认90秒")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("lease-expiration-duration-in-seconds")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("90")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 默认30秒")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token key atrule"}},[a._v("lease-renewal-interval-in-seconds")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("30")]),a._v("\n")])])])])]),a._v(" "),s("h1",{attrs:{id:"autowired注解与-resource注解的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#autowired注解与-resource注解的区别"}},[a._v("#")]),a._v(" @Autowired注解与@Resource注解的区别")]),a._v(" "),s("h2",{attrs:{id:"相同点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[a._v("#")]),a._v(" 相同点")]),a._v(" "),s("p",[a._v("@Resource的作用相当于@Autowired，均可标注在字段或属性的setter方法上。")]),a._v(" "),s("h2",{attrs:{id:"不同点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不同点"}},[a._v("#")]),a._v(" 不同点")]),a._v(" "),s("ol",[s("li",[a._v("提供方：@Autowired是由Spring提供；@Resource是由J2EE提供，需要JDK1.6及以上")]),a._v(" "),s("li",[a._v("注入方式：@Autowired只按照byType 注入；@Resource默认按byName自动注入，也提供按照byType 注入；")]),a._v(" "),s("li",[a._v("属性：@Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果我们想使用按名称装配，可以结合 @Qualifier 注解一起使用。@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。")])]),a._v(" "),s("h2",{attrs:{id:"resource装配顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resource装配顺序"}},[a._v("#")]),a._v(" @Resource装配顺序")]),a._v(" "),s("ol",[s("li",[a._v("如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常")]),a._v(" "),s("li",[a._v("如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常")]),a._v(" "),s("li",[a._v("如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常")]),a._v(" "),s("li",[a._v("如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；")])]),a._v(" "),s("p",[a._v("推荐使用@Resource注解在字段上，这样就不用写setter方法了.并且这个注解是属于J2EE的，减少了与Spring的耦合,这样代码看起就比较优雅 。")]),a._v(" "),s("h1",{attrs:{id:"秒杀的分布式锁场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#秒杀的分布式锁场景"}},[a._v("#")]),a._v(" 秒杀的分布式锁场景")]),a._v(" "),s("h2",{attrs:{id:"前提"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前提"}},[a._v("#")]),a._v(" 前提")]),a._v(" "),s("p",[a._v("已有的系统功能完善，稳定。")]),a._v(" "),s("h2",{attrs:{id:"特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),s("p",[a._v("稳定，短时间，高并发")]),a._v(" "),s("h2",{attrs:{id:"目标"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目标"}},[a._v("#")]),a._v(" 目标")]),a._v(" "),s("p",[a._v("不多卖，不少卖，服务的可用性，服务器响应速度快")]),a._v(" "),s("h2",{attrs:{id:"实现流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实现流程"}},[a._v("#")]),a._v(" 实现流程")]),a._v(" "),s("p",[s("img",{attrs:{src:"%5Cimages%5C%E7%A7%92%E6%9D%80%E6%B5%81%E7%A8%8B%E5%9B%BE.png",alt:"秒杀流程图"}})]),a._v(" "),s("h2",{attrs:{id:"如何提高加锁阻塞的效率"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何提高加锁阻塞的效率"}},[a._v("#")]),a._v(" 如何提高加锁阻塞的效率？")]),a._v(" "),s("ul",[s("li",[a._v("库存分段，10个10个的锁，并发效率提高了10倍")])]),a._v(" "),s("h2",{attrs:{id:"秒杀场景优化思路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#秒杀场景优化思路"}},[a._v("#")]),a._v(" 秒杀场景优化思路")]),a._v(" "),s("ol",[s("li",[a._v("请求的数据量要少（接口数据少）")]),a._v(" "),s("li",[a._v("请求的路径要端（减少链路调用次数）")]),a._v(" "),s("li",[a._v("相关依赖要少")]),a._v(" "),s("li",[a._v("不要单点")]),a._v(" "),s("li",[a._v("CDN分发")]),a._v(" "),s("li",[a._v("动静分离（静态数据做缓存，减少服务器压力）")]),a._v(" "),s("li",[a._v("识别热点数据，为系统扩容做准备（当前置的耗费资源少的接口被频繁调用时，说明热点数据快要来了）")]),a._v(" "),s("li",[a._v("使用消息队列进行削峰，前面简单处理一下，就扔到MQ里，后面进行排队，慢慢的去进行消费")]),a._v(" "),s("li",[a._v("答题，输验证码")]),a._v(" "),s("li",[a._v("网络（网络请求转发）、CPU（优化程序的并发）、内存（自己的内存+Redis）、硬盘（MySQL）")])]),a._v(" "),s("h1",{attrs:{id:"object类的方法说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#object类的方法说明"}},[a._v("#")]),a._v(" Object类的方法说明")]),a._v(" "),s("h2",{attrs:{id:"tostring-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tostring-方法"}},[a._v("#")]),a._v(" toString() 方法")]),a._v(" "),s("p",[a._v("返回对象的描述信息：全类名@哈希码值的十六进制形式")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("编程规范：开发者要对自定义的类重写toString()，对对象做详细的说明\n")])])]),s("h2",{attrs:{id:"hashcode-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashcode-方法"}},[a._v("#")]),a._v(" hashCode() 方法")]),a._v(" "),s("p",[a._v("返回该对象的哈希码值，int类型；\n同一个对象的哈希码值是唯一的。java规定如果两个对象equals返回true，那么这两个对象的hashCode码必须一致。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("编程规范： 一般重写了类的equals方法后，都会重写它的hashCode方法\n")])])]),s("h2",{attrs:{id:"tostring和hashcode哈希码的联系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tostring和hashcode哈希码的联系"}},[a._v("#")]),a._v(" toString和hashCode哈希码的联系")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("他们之间是十六进制与十进制之间的关系！\n")])])]),s("h2",{attrs:{id:"equals-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#equals-方法"}},[a._v("#")]),a._v(" equals() 方法")]),a._v(" "),s("p",[a._v("默认比较的是两个对象的内存值，相等返回 true，否则 false。可重写equals方法。")]),a._v(" "),s("p",[a._v("问题：既然equals比较的是对象的内存值，那我们在开发的时候经常使用 equals() 方法比较两个字符串是否相等，为什么？")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("String 重写了Object类的equals方法，比较的是字符串内容是否相等。\n")])])]),s("h2",{attrs:{id:"equals-和"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#equals-和"}},[a._v("#")]),a._v(" equals 和 ==")]),a._v(" "),s("h3",{attrs:{id:""}},[s("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")]),a._v(" ==")]),a._v(" "),s("ul",[s("li",[a._v("比较基本数据类型，比较的是值是否相等。")]),a._v(" "),s("li",[a._v("比较引用数据类型，比较的是地址是否相等。")])]),a._v(" "),s("h3",{attrs:{id:"equals"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#equals"}},[a._v("#")]),a._v(" equals")]),a._v(" "),s("ul",[s("li",[a._v("比较的是两个对象的地址值是否相等，此时等价 ==。")]),a._v(" "),s("li",[a._v("重写后按照重写后的方式比较。")])]),a._v(" "),s("h2",{attrs:{id:"equals-和-hashcode-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#equals-和-hashcode-方法"}},[a._v("#")]),a._v(" equals 和 hashCode 方法")]),a._v(" "),s("h3",{attrs:{id:"作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[a._v("#")]),a._v(" 作用")]),a._v(" "),s("p",[a._v("都是用于比较java对象是否一致")]),a._v(" "),s("ul",[s("li",[a._v("equals：重写的equal() 方法里一般比较全面、复杂，效率低。")]),a._v(" "),s("li",[a._v("hashCode：生成一个int类型的hash值。效率高，但hash值可能不唯一。")])]),a._v(" "),s("h3",{attrs:{id:"问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[a._v("#")]),a._v(" 问题")]),a._v(" "),s("p",[a._v("由于hash值的生成问题，可能导致不同的对象，hash值相同。")]),a._v(" "),s("h3",{attrs:{id:"结论"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结论"}},[a._v("#")]),a._v(" 结论")]),a._v(" "),s("ul",[s("li",[a._v("equal()对比绝对可靠（equal()相等的两个对象他们的hashCode()肯定相等）")]),a._v(" "),s("li",[a._v("hashCode()不是绝对可靠的（hashCode()相等的两个对象他们的equal()不一定相等）")])]),a._v(" "),s("h3",{attrs:{id:"使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[a._v("#")]),a._v(" 使用")]),a._v(" "),s("p",[a._v("​\t\t所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！")]),a._v(" "),s("h1",{attrs:{id:"string的hashcde算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#string的hashcde算法"}},[a._v("#")]),a._v(" String的hashcde算法")]),a._v(" "),s("h2",{attrs:{id:"hashcde源码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hashcde源码"}},[a._v("#")]),a._v(" hashcde源码")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/** The value is used for character storage. */")]),a._v("  \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("char")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//将字符串截成的字符数组  ")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/** Cache the hash code for the string */")]),a._v("  \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Default to 0 用以缓存计算出的hashcode值  ")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("/** \n* Returns a hash code for this string. The hash code for a \n* <code>String</code> object is computed as \n* <blockquote><pre> \n* s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] \n* </pre></blockquote> \n* using <code>int</code> arithmetic, where <code>s[i]</code> is the \n* <i>i</i>th character of the string, <code>n</code> is the length of \n* the string, and <code>^</code> indicates exponentiation. \n* (The hash value of the empty string is zero.) \n* \n* @return  a hash code value for this object. \n*/")]),a._v("  \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("  \n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("&&")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("  \n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("char")]),a._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("  \n\t\t\th "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("31")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" h "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n\t\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("  \n\t\thash "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("  \n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("h2",{attrs:{id:"举例说明"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#举例说明"}},[a._v("#")]),a._v(" 举例说明")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("String msg = \"abcd\";  // 此时value[] = {'a','b','c','d'}  因此\n\nfor循环会执行4次\n第一次：h = 31*0 + a = 97\n第二次：h = 31*97 + b = 3105\n第三次：h = 31*3105 + c = 96354\n第四次：h = 31*96354 + d = 2987074\n由以上代码计算可以算出 msg 的hashcode = 2987074  刚好与 System.err.println(new String(\"abcd\").hashCode()); 进行验证\n \n在源码的hashcode的注释中还提供了一个多项式计算方式：\ns[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]      \ns[0] ：表示字符串中指定下标的字符\nn：表示字符串中字符长度\na*31^3 + b*31^2 + c*31^1 + d = 2987074  + 94178 + 3069 + 100 = 2987074 ;\n")])])]),s("h1",{attrs:{id:"mq100-投递及消费"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mq100-投递及消费"}},[a._v("#")]),a._v(" MQ100%投递及消费")]),a._v(" "),s("h2",{attrs:{id:"核心点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心点"}},[a._v("#")]),a._v(" 核心点")]),a._v(" "),s("ol",[s("li",[a._v("消息收到先落地")]),a._v(" "),s("li",[a._v("消息超时、重传、确认保证消息必达")])]),a._v(" "),s("h2",{attrs:{id:"mq投递消息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mq投递消息"}},[a._v("#")]),a._v(" MQ投递消息")]),a._v(" "),s("ol",[s("li",[a._v("客户端给MQ服务器发送消息")]),a._v(" "),s("li",[a._v("MQ服务器将消息落地，落地后即为发送成功")]),a._v(" "),s("li",[a._v("MQ服务器将应答发送给MQ客户端")])]),a._v(" "),s("p",[a._v("说明：MQ投递消息的1或者2或者3如果丢失或者超时，MQ客户端内的定时器会重发消息，直到期望收到3，如果重传N次后还未收到，则回调发送失败（说明此时网络可能存在问题了；如果要求100%投递成功，可以先把失败的消息存储到一个第三方介质上，过段时间网络恢复了再进行消息投递）需要注意的是，这个过程中MQ服务器可能会收到同一条消息的多次重发")]),a._v(" "),s("h2",{attrs:{id:"mq消费消息"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mq消费消息"}},[a._v("#")]),a._v(" MQ消费消息")]),a._v(" "),s("ol",[s("li",[a._v("MQ服务器将消息发送给MQ客户端")]),a._v(" "),s("li",[a._v("MQ客户端回复MQ服务器接受完成")]),a._v(" "),s("li",[a._v("MQ服务器收到ACK应答，将已经落地的消息删除，完成消息的可靠传递")])]),a._v(" "),s("p",[a._v("说明：MQ消费消息的1或者2或者3如果丢失或者超时，MQ服务器内的定时器会重发消息，直到收到2并且成功执行3，这个过程可能会重发很多次消息，一般采用指数退避的策略，先隔x秒重发，2x秒重发，4x秒重发，以此类推，需要注意的是，这个过程中MQ客户端也可能会收到同一条消息的多次重发")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("MQ投递消息与MQ消费消息如何进行消息去重，需要进行MQ架构幂等性设计！！！\n")])])]),s("h1",{attrs:{id:"幂等的设计思路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#幂等的设计思路"}},[a._v("#")]),a._v(" 幂等的设计思路")]),a._v(" "),s("h2",{attrs:{id:"mq幂等设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mq幂等设计"}},[a._v("#")]),a._v(" MQ幂等设计")]),a._v(" "),s("h3",{attrs:{id:"mq投递消息的幂等设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mq投递消息的幂等设计"}},[a._v("#")]),a._v(" MQ投递消息的幂等设计")]),a._v(" "),s("p",[a._v("此时重发的是MQ客户端，消息处理的是MQ服务器端，为了避免步骤2落地重复的消息，对每条消息，MQ系统内部必须生成一个内部的消息id（inner-msg-id），作为去重和幂等的依据，这个内部消息ID的特性是：")]),a._v(" "),s("ol",[s("li",[a._v("全局唯一")]),a._v(" "),s("li",[a._v("MQ生成，具备业务无关性，对消息发送发和消息接收方屏蔽")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("有了这个inner-msg-id，就能保证MQ投递消息的重发，只有1条消息落到MQ服务器中，实现MQ消息投递的幂等。\n")])])]),s("h3",{attrs:{id:"mq消费消息的幂等设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mq消费消息的幂等设计"}},[a._v("#")]),a._v(" MQ消费消息的幂等设计")]),a._v(" "),s("p",[a._v("此时重发的是MQ服务器，消息的处理是消息消费业务方，消息重发势必会导致业务方重复消费，为了保证业务幂等性，业务消息体中，必须有一个biz-id，作为去重和幂等的依据，这个业务id的特性是：")]),a._v(" "),s("ol",[s("li",[a._v("对于同一个业务场景，全局唯一")]),a._v(" "),s("li",[a._v("由业务消息发送方生成，业务相关，对MQ透明")]),a._v(" "),s("li",[a._v("由业务消息消费方负责判重，以保证幂等")])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("最常见的业务id有：支付id，订单id，帖子id等；有了这个业务id，才能够保证MQ消息消费业务方即使收到重复的消息，也只有1条被消费，保证了幂等。\n")])])]),s("h3",{attrs:{id:"mq幂等设计总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mq幂等设计总结"}},[a._v("#")]),a._v(" MQ幂等设计总结")]),a._v(" "),s("ul",[s("li",[a._v("MQ投递消息\n"),s("ul",[s("li",[a._v("MQ客户端内部或者MQ服务器生成inner-msg-id，保证MQ投递消息幂等")]),a._v(" "),s("li",[a._v("这个id全局唯一，业务无关，由MQ保证")])])]),a._v(" "),s("li",[a._v("MQ消费消息\n"),s("ul",[s("li",[a._v("业务发送发带入biz-id，业务接收方去重保证幂等")]),a._v(" "),s("li",[a._v("这个id对业务唯一，业务相关，对MQ透明")])])])]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("结论：幂等性，不仅对MQ有要求，对业务上下游也有要求。\n")])])]),s("h2",{attrs:{id:"服务接口幂等设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#服务接口幂等设计"}},[a._v("#")]),a._v(" 服务接口幂等设计")]),a._v(" "),s("h3",{attrs:{id:"保证接口幂等性的要求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#保证接口幂等性的要求"}},[a._v("#")]),a._v(" 保证接口幂等性的要求")]),a._v(" "),s("ol",[s("li",[a._v("对于每个请求必须有一个唯一的标识")]),a._v(" "),s("li",[a._v("每次处理完请求之后，必须有一个记录标识这个请求处理过了")]),a._v(" "),s("li",[a._v("每次接收请求需要进行判断之前是否处理过的逻辑处理")])]),a._v(" "),s("h3",{attrs:{id:"用户重复提交问题-nginx重试-ribbon重试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用户重复提交问题-nginx重试-ribbon重试"}},[a._v("#")]),a._v(" 用户重复提交问题,Nginx重试,Ribbon重试")]),a._v(" "),s("p",[a._v("这个问题等同于表单重复提交，一般的解决思路是token机制。")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("也就是说在表单提交之前需要向后端申请token，后端返给前端token的同时需要把token保存到redis中，并设置超时时间。请求接口时，将此token放在header中或者作为参数，后端判断token是否存在，存在则删除token并正常处理业务逻辑；否则返回重复提交提示。\n")])])]),s("h1",{attrs:{id:"分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[a._v("#")]),a._v(" 分布式锁")]),a._v(" "),s("h2",{attrs:{id:"分布式锁的特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁的特点"}},[a._v("#")]),a._v(" 分布式锁的特点")]),a._v(" "),s("ol",[s("li",[a._v("互斥性：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁")]),a._v(" "),s("li",[a._v("安全性：锁只能被持有该锁的客户端删除，不能由其它客户端删除")]),a._v(" "),s("li",[a._v("防死锁：获取锁的客户端因为某些原因（如down机等），需要设置一个策略把锁释放掉，否则其他客户端再也无法获取到该锁")]),a._v(" "),s("li",[a._v("容错性：当部分服务节点down机时，客户端仍然能够获取锁和释放锁")])]),a._v(" "),s("h2",{attrs:{id:"基于数据库的锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于数据库的锁"}},[a._v("#")]),a._v(" 基于数据库的锁")]),a._v(" "),s("p",[a._v("利用数据库的行级锁实现")]),a._v(" "),s("h2",{attrs:{id:"基于zookeeper的分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于zookeeper的分布式锁"}},[a._v("#")]),a._v(" 基于Zookeeper的分布式锁")]),a._v(" "),s("p",[a._v("利用zk临时顺序节点的特性来实现")]),a._v(" "),s("h2",{attrs:{id:"基于redis单机的锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于redis单机的锁"}},[a._v("#")]),a._v(" 基于Redis单机的锁")]),a._v(" "),s("p",[a._v("使用redis set nx命令来实现")]),a._v(" "),s("h2",{attrs:{id:"基于redisson分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于redisson分布式锁"}},[a._v("#")]),a._v(" 基于Redisson分布式锁")]),a._v(" "),s("p",[a._v("多个redis实例之间毫无任何关系，加锁成功的个数超过半数+1，即获得锁成功")]),a._v(" "),s("h1",{attrs:{id:"分布式事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[a._v("#")]),a._v(" 分布式事务")]),a._v(" "),s("h1",{attrs:{id:"feign调用全过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#feign调用全过程"}},[a._v("#")]),a._v(" feign调用全过程")])])}),[],!1,null,null,null);t.default=r.exports}}]);