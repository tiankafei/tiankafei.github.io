(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{468:function(s,t,e){"use strict";e.r(t);var a=e(42),r=Object(a.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"分布式锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[s._v("#")]),s._v(" 分布式锁")]),s._v(" "),e("h2",{attrs:{id:"特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[s._v("#")]),s._v(" 特点")]),s._v(" "),e("ol",[e("li",[s._v("互斥性：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁")]),s._v(" "),e("li",[s._v("安全性：锁只能被持有该锁的客户端删除，不能由其它客户端删除")]),s._v(" "),e("li",[s._v("防死锁：获取锁的客户端因为某些原因（如down机等），需要设置一个策略把锁释放掉，否则其他客户端再也无法获取到该锁")]),s._v(" "),e("li",[s._v("容错性：当部分服务节点down机时，客户端仍然能够获取锁和释放锁")])]),s._v(" "),e("h2",{attrs:{id:"基于数据库行级锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于数据库行级锁"}},[s._v("#")]),s._v(" 基于数据库行级锁")]),s._v(" "),e("h2",{attrs:{id:"基于zookeeper的分布式锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于zookeeper的分布式锁"}},[s._v("#")]),s._v(" 基于Zookeeper的分布式锁")]),s._v(" "),e("h2",{attrs:{id:"基于redis的分布式锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于redis的分布式锁"}},[s._v("#")]),s._v(" 基于Redis的分布式锁")]),s._v(" "),e("h3",{attrs:{id:"redis单节点加锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis单节点加锁"}},[s._v("#")]),s._v(" Redis单节点加锁")]),s._v(" "),e("p",[s._v("基于Redis命令：SET key value NX EX max-lock-time，需要手动实现锁的延期")]),s._v(" "),e("h3",{attrs:{id:"redisson加锁"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redisson加锁"}},[s._v("#")]),s._v(" Redisson加锁")]),s._v(" "),e("p",[s._v("redisson加锁的奇数个实例之间毫无任何关系，不需要进行数据同步，只要过半成功就说明加锁成功了。redisson会起一个线程，当执行时间到达锁过期时间的1/3时，如果依然没有执行完成，则进行锁的有效期延长；如果当前线程获取到锁之后，就宕机了，那么当过了锁的有效期之后，锁会被自动释放。")]),s._v(" "),e("p",[e("img",{attrs:{src:"%5Cimages%5C%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-redisson.png",alt:"分布式锁-redisson"}})])])}),[],!1,null,null,null);t.default=r.exports}}]);