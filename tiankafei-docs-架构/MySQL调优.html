<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>MySQL调优 | tiankafei - java相关技术栈</title>
    <meta name="generator" content="VuePress 1.5.3">
    
    <meta name="description" content="自己写的一些东西的记录，包括代码与笔记，jdk最低支持1.8">
    <link rel="preload" href="/assets/css/0.styles.abfd12c2.css" as="style"><link rel="preload" href="/assets/js/app.2037e208.js" as="script"><link rel="preload" href="/assets/js/2.39facb6e.js" as="script"><link rel="preload" href="/assets/js/96.c8852b6e.js" as="script"><link rel="prefetch" href="/assets/js/10.5e948851.js"><link rel="prefetch" href="/assets/js/100.db52371c.js"><link rel="prefetch" href="/assets/js/101.c6639fbb.js"><link rel="prefetch" href="/assets/js/102.2228f068.js"><link rel="prefetch" href="/assets/js/103.bda9c68a.js"><link rel="prefetch" href="/assets/js/104.824c83ac.js"><link rel="prefetch" href="/assets/js/105.d9bddf38.js"><link rel="prefetch" href="/assets/js/11.768d8e4c.js"><link rel="prefetch" href="/assets/js/12.eecc14c4.js"><link rel="prefetch" href="/assets/js/13.fdafbe9f.js"><link rel="prefetch" href="/assets/js/14.b273df4c.js"><link rel="prefetch" href="/assets/js/15.b6fb6c7c.js"><link rel="prefetch" href="/assets/js/16.9218f5b3.js"><link rel="prefetch" href="/assets/js/17.82428c52.js"><link rel="prefetch" href="/assets/js/18.8e48c5ab.js"><link rel="prefetch" href="/assets/js/19.de289862.js"><link rel="prefetch" href="/assets/js/20.c1ab7131.js"><link rel="prefetch" href="/assets/js/21.d74bceab.js"><link rel="prefetch" href="/assets/js/22.11b2f0a0.js"><link rel="prefetch" href="/assets/js/23.1df0d465.js"><link rel="prefetch" href="/assets/js/24.654ce122.js"><link rel="prefetch" href="/assets/js/25.d46f3c5d.js"><link rel="prefetch" href="/assets/js/26.f95bc591.js"><link rel="prefetch" href="/assets/js/27.3f183dc5.js"><link rel="prefetch" href="/assets/js/28.f155b337.js"><link rel="prefetch" href="/assets/js/29.805de2b2.js"><link rel="prefetch" href="/assets/js/3.0b90710e.js"><link rel="prefetch" href="/assets/js/30.24298f93.js"><link rel="prefetch" href="/assets/js/31.b4ce6f80.js"><link rel="prefetch" href="/assets/js/32.cc6d6564.js"><link rel="prefetch" href="/assets/js/33.73b6e686.js"><link rel="prefetch" href="/assets/js/34.88223eae.js"><link rel="prefetch" href="/assets/js/35.1542b211.js"><link rel="prefetch" href="/assets/js/36.e731f7cd.js"><link rel="prefetch" href="/assets/js/37.2fec8c1d.js"><link rel="prefetch" href="/assets/js/38.509153c9.js"><link rel="prefetch" href="/assets/js/39.5ed60b0f.js"><link rel="prefetch" href="/assets/js/4.3b6a7e49.js"><link rel="prefetch" href="/assets/js/40.ea3bba57.js"><link rel="prefetch" href="/assets/js/41.0a377cc0.js"><link rel="prefetch" href="/assets/js/42.c33f9a8a.js"><link rel="prefetch" href="/assets/js/43.752540dd.js"><link rel="prefetch" href="/assets/js/44.2df68af6.js"><link rel="prefetch" href="/assets/js/45.9cbf408e.js"><link rel="prefetch" href="/assets/js/46.3e2a7532.js"><link rel="prefetch" href="/assets/js/47.1fff17f1.js"><link rel="prefetch" href="/assets/js/48.25746328.js"><link rel="prefetch" href="/assets/js/49.00a5b87c.js"><link rel="prefetch" href="/assets/js/5.af75ae8c.js"><link rel="prefetch" href="/assets/js/50.550ea49a.js"><link rel="prefetch" href="/assets/js/51.92abcce4.js"><link rel="prefetch" href="/assets/js/52.225c1ca9.js"><link rel="prefetch" href="/assets/js/53.5aa8c19e.js"><link rel="prefetch" href="/assets/js/54.21b37f61.js"><link rel="prefetch" href="/assets/js/55.6a10bb5e.js"><link rel="prefetch" href="/assets/js/56.bc822efa.js"><link rel="prefetch" href="/assets/js/57.b6e9258e.js"><link rel="prefetch" href="/assets/js/58.7420709f.js"><link rel="prefetch" href="/assets/js/59.e782c2a3.js"><link rel="prefetch" href="/assets/js/6.0132adf5.js"><link rel="prefetch" href="/assets/js/60.c0738e6d.js"><link rel="prefetch" href="/assets/js/61.b53ee4fa.js"><link rel="prefetch" href="/assets/js/62.a02c2218.js"><link rel="prefetch" href="/assets/js/63.b71df437.js"><link rel="prefetch" href="/assets/js/64.2043e96b.js"><link rel="prefetch" href="/assets/js/65.a17e6ff6.js"><link rel="prefetch" href="/assets/js/66.35ae3823.js"><link rel="prefetch" href="/assets/js/67.180b766e.js"><link rel="prefetch" href="/assets/js/68.dcb7a50b.js"><link rel="prefetch" href="/assets/js/69.cb703132.js"><link rel="prefetch" href="/assets/js/7.80dd9fab.js"><link rel="prefetch" href="/assets/js/70.30cb6fc1.js"><link rel="prefetch" href="/assets/js/71.2549bc20.js"><link rel="prefetch" href="/assets/js/72.cb69cca5.js"><link rel="prefetch" href="/assets/js/73.3cdb7bb4.js"><link rel="prefetch" href="/assets/js/74.c93cfd18.js"><link rel="prefetch" href="/assets/js/75.7f2f6571.js"><link rel="prefetch" href="/assets/js/76.2bc49fe8.js"><link rel="prefetch" href="/assets/js/77.7ca54af5.js"><link rel="prefetch" href="/assets/js/78.0a6220c2.js"><link rel="prefetch" href="/assets/js/79.285d557c.js"><link rel="prefetch" href="/assets/js/8.a59e0ab0.js"><link rel="prefetch" href="/assets/js/80.bb06b0b4.js"><link rel="prefetch" href="/assets/js/81.ce4829ff.js"><link rel="prefetch" href="/assets/js/82.4b5df711.js"><link rel="prefetch" href="/assets/js/83.f76795c8.js"><link rel="prefetch" href="/assets/js/84.3a3ff091.js"><link rel="prefetch" href="/assets/js/85.7c7be266.js"><link rel="prefetch" href="/assets/js/86.2d1b8ad2.js"><link rel="prefetch" href="/assets/js/87.537c2740.js"><link rel="prefetch" href="/assets/js/88.e9bb6450.js"><link rel="prefetch" href="/assets/js/89.88c4b02f.js"><link rel="prefetch" href="/assets/js/9.429929a5.js"><link rel="prefetch" href="/assets/js/90.fd76f454.js"><link rel="prefetch" href="/assets/js/91.d3e8e80a.js"><link rel="prefetch" href="/assets/js/92.430ee1bd.js"><link rel="prefetch" href="/assets/js/93.6aefe170.js"><link rel="prefetch" href="/assets/js/94.82ac00dc.js"><link rel="prefetch" href="/assets/js/95.6e7f90b2.js"><link rel="prefetch" href="/assets/js/97.5e5be332.js"><link rel="prefetch" href="/assets/js/98.c118ced4.js"><link rel="prefetch" href="/assets/js/99.132cfddc.js">
    <link rel="stylesheet" href="/assets/css/0.styles.abfd12c2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">tiankafei - java相关技术栈</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/tiankafei-docs-java/Java基础.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/tiankafei-docs-spring/spring学习笔记/" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/tiankafei-docs-架构/MySQL调优/" class="nav-link">
  架构
</a></div><div class="nav-item"><a href="/tiankafei-docs-大数据/centos7安装配置Hadoop/" class="nav-link">
  大数据
</a></div><div class="nav-item"><a href="/tiankafei-docs-linux/centos常用命令/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/tiankafei-docs-云/Centos7安装Docker并配置使用/" class="nav-link">
  云
</a></div><div class="nav-item"><a href="/tiankafei-docs-other/git上fork后再更新/" class="nav-link">
  其他
</a></div><div class="nav-item"><a href="/tiankafei-docs-en/词性语法学习/" class="nav-link">
  英语
</a></div><div class="nav-item"><a href="https://github.com/tiankafei/tiankafei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/tiankafei-docs-java/Java基础.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/tiankafei-docs-spring/spring学习笔记/" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/tiankafei-docs-架构/MySQL调优/" class="nav-link">
  架构
</a></div><div class="nav-item"><a href="/tiankafei-docs-大数据/centos7安装配置Hadoop/" class="nav-link">
  大数据
</a></div><div class="nav-item"><a href="/tiankafei-docs-linux/centos常用命令/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/tiankafei-docs-云/Centos7安装Docker并配置使用/" class="nav-link">
  云
</a></div><div class="nav-item"><a href="/tiankafei-docs-other/git上fork后再更新/" class="nav-link">
  其他
</a></div><div class="nav-item"><a href="/tiankafei-docs-en/词性语法学习/" class="nav-link">
  英语
</a></div><div class="nav-item"><a href="https://github.com/tiankafei/tiankafei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>架构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tiankafei-docs-架构/MySQL调优.html" class="active sidebar-link">MySQL调优</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#mysql中innodb的主键" class="sidebar-link">MySQL中innodb的主键</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#设计原则" class="sidebar-link">设计原则</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#这样设计的原因" class="sidebar-link">这样设计的原因</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#mysql中各数据类型的取值范围" class="sidebar-link">MySQL中各数据类型的取值范围</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#优化种类" class="sidebar-link">优化种类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#rbo：基于规则的优化" class="sidebar-link">RBO：基于规则的优化</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#cbo：基于成本的优化" class="sidebar-link">CBO：基于成本的优化</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#数据文件类型" class="sidebar-link">数据文件类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#innodb" class="sidebar-link">InnoDB</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#myisam" class="sidebar-link">MyISAM</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#性能监控" class="sidebar-link">性能监控</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#使用show-profile查询剖析工具，可以指定具体的type" class="sidebar-link">使用show profile查询剖析工具，可以指定具体的type</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#使用performance-schema来更加容易的监控mysql" class="sidebar-link">使用performance schema来更加容易的监控mysql</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#使用-show-processlist-查看连接的线程个数" class="sidebar-link">使用 show processlist 查看连接的线程个数</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#schema与数据类型优化" class="sidebar-link">schema与数据类型优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#数据类型的优化" class="sidebar-link">数据类型的优化</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#合理使用范式和反范式" class="sidebar-link">合理使用范式和反范式</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#主键的选择" class="sidebar-link">主键的选择</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#字符集的选择" class="sidebar-link">字符集的选择</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#存储引擎的选择" class="sidebar-link">存储引擎的选择</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#适当的数据冗余" class="sidebar-link">适当的数据冗余</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#适当拆分" class="sidebar-link">适当拆分</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#执行计划" class="sidebar-link">执行计划</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#id" class="sidebar-link">id</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#select-type" class="sidebar-link">select_type</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#table" class="sidebar-link">table</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#partitions" class="sidebar-link">partitions</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#type" class="sidebar-link">type</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#possible-keys" class="sidebar-link">possible_keys</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#key" class="sidebar-link">key</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#key-len" class="sidebar-link">key_len</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#ref" class="sidebar-link">ref</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#rows" class="sidebar-link">rows</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#extra" class="sidebar-link">extra</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#通过索引进行优化" class="sidebar-link">通过索引进行优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#索引基本知识" class="sidebar-link">索引基本知识</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#哈希索引" class="sidebar-link">哈希索引</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#组合索引" class="sidebar-link">组合索引</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#聚簇索引与非聚簇索引" class="sidebar-link">聚簇索引与非聚簇索引</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#覆盖索引-2" class="sidebar-link">覆盖索引</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#优化小细节" class="sidebar-link">优化小细节</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#索引监控" class="sidebar-link">索引监控</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#简单案例" class="sidebar-link">简单案例</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#查询优化" class="sidebar-link">查询优化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#查询慢的原因" class="sidebar-link">查询慢的原因</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#优化数据访问" class="sidebar-link">优化数据访问</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#执行过程的优化" class="sidebar-link">执行过程的优化</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#优化特定类型的查询" class="sidebar-link">优化特定类型的查询</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#分区表" class="sidebar-link">分区表</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#分区表的应用场景" class="sidebar-link">分区表的应用场景</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#分区表的限制" class="sidebar-link">分区表的限制</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#分区表的原理" class="sidebar-link">分区表的原理</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#分区表的类型" class="sidebar-link">分区表的类型</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#如何使用分区表" class="sidebar-link">如何使用分区表</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#在使用分区表的时候需要注意的问题" class="sidebar-link">在使用分区表的时候需要注意的问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#服务器参数设置" class="sidebar-link">服务器参数设置</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#general：通用配置" class="sidebar-link">general：通用配置</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#character：字符集" class="sidebar-link">character：字符集</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#connection：连接-配置" class="sidebar-link">connection：连接 配置</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#log：日志配置" class="sidebar-link">log：日志配置</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#cache：缓存" class="sidebar-link">cache：缓存</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#innodb-3" class="sidebar-link">innodb</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#mysql集群" class="sidebar-link">mysql集群</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#主从复制" class="sidebar-link">主从复制</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#读写分离" class="sidebar-link">读写分离</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#mysql事务" class="sidebar-link">MySQL事务</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#事务的处理" class="sidebar-link">事务的处理</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#事务的基本特性" class="sidebar-link">事务的基本特性</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/MySQL调优.html#隔离级别" class="sidebar-link">隔离级别</a></li></ul></li></ul></li><li><a href="/tiankafei-docs-架构/mysql主从复制安装配置.html" class="sidebar-link">mysql主从复制安装配置</a></li><li><a href="/tiankafei-docs-架构/使用amoeba实现mysql读写分离.html" class="sidebar-link">使用amoeba实现mysql读写分离</a></li><li><a href="/tiankafei-docs-架构/redis学习笔记.html" class="sidebar-link">redis介绍</a></li><li><a href="/tiankafei-docs-架构/zookeeper学习笔记.html" class="sidebar-link">zookeeper学习笔记</a></li><li><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html" class="sidebar-link">Elasticsearch学习笔记</a></li><li><a href="/tiankafei-docs-架构/Tomcat源码分析.html" class="sidebar-link">Tomcat源码分析</a></li><li><a href="/tiankafei-docs-架构/Netty源码分析.html" class="sidebar-link">Netty源码分析</a></li><li><a href="/tiankafei-docs-架构/分布式事务.html" class="sidebar-link">事务</a></li><li><a href="/tiankafei-docs-架构/分布式锁.html" class="sidebar-link">分布式三把锁</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="mysql调优"><a href="#mysql调优" class="header-anchor">#</a> MySQL调优</h1> <blockquote><p>命令行连接mysql命令：</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># mysql -u用户名 -p密码 -h主机 -P端口</span>
mysql -uroot -ptiankafei -hsoftware -P3306
</code></pre></div></blockquote> <h2 id="mysql中innodb的主键"><a href="#mysql中innodb的主键" class="header-anchor">#</a> MySQL中innodb的主键</h2> <h3 id="设计原则"><a href="#设计原则" class="header-anchor">#</a> 设计原则</h3> <ol><li>一定要显式定义主键</li> <li>采用与业务无关的单独列</li> <li>采用自增列</li> <li>数据类型采用int，并尽可能小，能用tinyint就不用int，能用int就不用bigint</li></ol> <h3 id="这样设计的原因"><a href="#这样设计的原因" class="header-anchor">#</a> 这样设计的原因</h3> <ol><li>在innodb引擎中只能有一个聚集索引，我们知道，聚集索引的叶子节点上直接存有行数据，所以聚集索引列尽量不要更改，而innodb表在有主键时会自动将主键设为聚集索引，如果不显式定义主键，会选第一个没有null值的唯一索引作为聚集索引，唯一索引涉及到的列内容难免被修改引发存储碎片且可能不是递增关系，存取效率低，所以最好显式定义主键且采用与业务无关的列以避免修改；如果这个条件也不符合，就会自动添加一个不可见不可引用的6byte大小的rowid作为聚集索引</li> <li>需采用自增列来使数据顺序插入，新增数据顺序插入到当前索引的后面，符合叶子节点的分裂顺序，性能较高；若不用自增列，数据的插入近似于随机，插入时需要插入到现在索引页的某个中间位置，需要移动数据，造成大量的数据碎片，索引结构松散，性能很差</li> <li>在主键插入时，会判断是否有重复值，所以尽量采用较小的数据类型，以减小比对长度提高性能，且可以减小存储需求，磁盘占用小，进而减少磁盘IO和内存占用；而且主键存储占用小，普通索引的占用也相应较小，减少占用，减少IO，且存储索引的页中能包含较多的数据，减少页的分裂，提高效率</li></ol> <h3 id="mysql中各数据类型的取值范围"><a href="#mysql中各数据类型的取值范围" class="header-anchor">#</a> MySQL中各数据类型的取值范围</h3> <table><thead><tr><th>字段</th> <th>最小值</th> <th>最大值</th></tr></thead> <tbody><tr><td>tinyint</td> <td>-128</td> <td>127</td></tr> <tr><td>tinyint unsigned</td> <td>0</td> <td>255</td></tr> <tr><td>smallint</td> <td>-32768</td> <td>32,767</td></tr> <tr><td>smallint unsigned</td> <td>0</td> <td>65,535</td></tr> <tr><td>mediumint</td> <td>-8388608</td> <td>8,388,607</td></tr> <tr><td>mediumint unsigned</td> <td>0</td> <td>16,777,215</td></tr> <tr><td>int</td> <td>-2147483648</td> <td>2,147,483,647</td></tr> <tr><td>int unsigned</td> <td>0</td> <td>4,294,967,295</td></tr> <tr><td>bigint</td> <td>-9223372036854775808</td> <td>9,223,372,036,854,775,807</td></tr> <tr><td>bigint unsigned</td> <td>0</td> <td>18,446,744,073,709,551,615</td></tr></tbody></table> <h2 id="优化种类"><a href="#优化种类" class="header-anchor">#</a> 优化种类</h2> <h3 id="rbo：基于规则的优化"><a href="#rbo：基于规则的优化" class="header-anchor">#</a> RBO：基于规则的优化</h3> <h3 id="cbo：基于成本的优化"><a href="#cbo：基于成本的优化" class="header-anchor">#</a> CBO：基于成本的优化</h3> <h2 id="数据文件类型"><a href="#数据文件类型" class="header-anchor">#</a> 数据文件类型</h2> <h3 id="innodb"><a href="#innodb" class="header-anchor">#</a> InnoDB</h3> <ul><li>*<strong>.frm</strong>   当前存储表的表结构文件</li> <li>*<strong>.ibd</strong>   当前存储表的数据文件</li></ul> <h3 id="myisam"><a href="#myisam" class="header-anchor">#</a> MyISAM</h3> <ul><li>*<strong>.frm</strong>   当前存储表的表结构文件</li> <li>*<strong>.MYD</strong>   当前存储表的数据文件</li> <li>*<strong>.MYI</strong>   当前存储表的索引文件</li></ul> <h2 id="性能监控"><a href="#性能监控" class="header-anchor">#</a> 性能监控</h2> <h3 id="使用show-profile查询剖析工具，可以指定具体的type"><a href="#使用show-profile查询剖析工具，可以指定具体的type" class="header-anchor">#</a> 使用show profile查询剖析工具，可以指定具体的type</h3> <div class="language-mysql extra-class"><pre class="language-text"><code>-- 可以查看执行sql的Query_ID
show profiles;
</code></pre></div><ol><li><p>all：显示所有性能信息</p> <div class="language-mysql extra-class"><pre class="language-text"><code>show profile all for query Query_ID
</code></pre></div></li> <li><p>block io：显示块io操作的次数</p> <div class="language-mysql extra-class"><pre class="language-text"><code>show profile block io for query Query_ID
</code></pre></div></li> <li><p>context switches：显示上下文切换次数，被动和主动</p> <div class="language-mysql extra-class"><pre class="language-text"><code>show profile context switches for query Query_ID
</code></pre></div></li> <li><p>cpu：显示用户cpu时间、系统cpu时间</p> <div class="language-mysql extra-class"><pre class="language-text"><code>show profile cpu for query Query_ID
</code></pre></div></li> <li><p>IPC：显示发送和接受的消息数量</p> <div class="language-mysql extra-class"><pre class="language-text"><code>show profile ipc for query Query_ID
</code></pre></div></li> <li><p>page faults：显示页错误数量</p> <div class="language-mysql extra-class"><pre class="language-text"><code>show profile page faults for query Query_ID
</code></pre></div></li> <li><p>source：显示源码中的函数名称与位置</p> <div class="language-mysql extra-class"><pre class="language-text"><code>show profile source for query Query_ID
</code></pre></div></li> <li><p>swaps：显示swap的次数</p> <div class="language-mysql extra-class"><pre class="language-text"><code>show profile swaps for query Query_ID
</code></pre></div></li></ol> <h3 id="使用performance-schema来更加容易的监控mysql"><a href="#使用performance-schema来更加容易的监控mysql" class="header-anchor">#</a> 使用performance schema来更加容易的监控mysql</h3> <h4 id="performance-schema的介绍"><a href="#performance-schema的介绍" class="header-anchor">#</a> performance_schema的介绍</h4> <blockquote><p>背景： MySQL 5.5开始新增一个数据库：PERFORMANCE_SCHEMA，主要用于收集数据库服务器性能参数。MySQL5.5默认是关闭的，需要手动开启，在配置文件里添加：</p> <div class="language-mysql extra-class"><pre class="language-text"><code>[mysqld]
performance_schema=ON
</code></pre></div><p>查看是否开启:</p> <div class="language-mysql extra-class"><pre class="language-text"><code>show variables like 'performance_schema';
</code></pre></div><p>从MySQL5.6开始，默认打开，本文就从MySQL5.6来说明，在数据库使用当中PERFORMANCE_SCHEMA的一些比较常用的功能。具体的信息可以查看<a href="http://dev.mysql.com/doc/refman/5.6/en/performance-schema.html" target="_blank" rel="noopener noreferrer">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>参考地址：<a href="https://www.cnblogs.com/zhoujinyi/p/5236705.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/zhoujinyi/p/5236705.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p>特点如下：</p> <ol><li>提供了一种在数据库运行时实时检查server的内部执行情况的方法。performance_schema 数据库中的表使用performance_schema 存储引擎。该数据库主要关注数据库运行过程中的性能相关的数据，与 information_schema 不同，information_schema 主要关注server运行过程中的元数据信息。</li> <li>performance_schema通过监视server的事件来实现监视server内部运行情况， “事件”就是server内部活动中所做的任何事情以及对应的时间消耗，利用这些信息来判断server中的相关资源消耗在了哪里？一般来说，事件可以是函数调用、操作系统的等待、SQL语句执行的阶段（如sql语句执行过程中的parsing 或 sorting阶段）或者整个SQL语句与SQL语句集合。事件的采集可以方便的提供server中的相关存储引擎对磁盘文件、表I/O、表锁等资源的同步调用信息。</li> <li>performance_schema中的事件与写入二进制日志中的事件（描述数据修改的events）、事件计划调度程序（这是一种存储程序）的事件不同。performance_schema中的事件记录的是server执行某些活动对某些资源的消耗、耗时、这些活动执行的次数等情况。</li> <li>performance_schema中的事件只记录在本地server的performance_schema中，其下的这些表中数据发生变化时不会被写入binlog中，也不会通过复制机制被复制到其他server中。</li> <li>当前活跃事件、历史事件和事件摘要相关的表中记录的信息。能提供某个事件的执行次数、使用时长。进而可用于分析某个特定线程、特定对象（如mutex或file）相关联的活动。</li> <li>PERFORMANCE_SCHEMA存储引擎使用server源代码中的“检测点”来实现事件数据的收集。对于performance_schema实现机制本身的代码没有相关的单独线程来检测，这与其他功能（如复制或事件计划程序）不同。</li> <li>收集的事件数据存储在performance_schema数据库的表中。这些表可以使用SELECT语句查询，也可以使用SQL语句更新performance_schema数据库中的表记录（如动态修改performance_schema的setup_*开头的几个配置表，但要注意：配置表的更改会立即生效，这会影响数据收集）。</li> <li>performance_schema的表中的数据不会持久化存储在磁盘中，而是保存在内存中，一旦服务器重启，这些数据会丢失（包括配置表在内的整个performance_schema下的所有数据）。</li> <li>MySQL支持的所有平台中事件监控功能都可用，但不同平台中用于统计事件时间开销的计时器类型可能会有所差异。</li></ol> <h4 id="performance-schema入门"><a href="#performance-schema入门" class="header-anchor">#</a> performance schema入门</h4> <p>在mysql的5.7版本中，性能模式是默认开启的，如果想要显式的关闭的话需要修改配置文件，不能直接进行修改，会报错Variable 'performance_schema' is a read only variable。</p> <ul><li>instruments: 生产者，用于采集mysql中各种各样的操作产生的事件信息，对应配置表中的配置项我们可以称为监控采集配置项。</li> <li>consumers:消费者，对应的消费者表用于存储来自instruments采集的数据，对应配置表中的配置项我们可以称为消费存储配置项。</li></ul> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--查看performance_schema的属性</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'performance_schema'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">--------------------+-------+</span>
<span class="token operator">|</span> Variable_name      <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------------------+-------+</span>
<span class="token operator">|</span> performance_schema <span class="token operator">|</span> <span class="token keyword">ON</span>    <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">--------------------+-------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>

<span class="token comment">--在配置文件中修改performance_schema的属性值，on表示开启，off表示关闭</span>
<span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span>
performance_schema<span class="token operator">=</span><span class="token keyword">ON</span>

<span class="token comment">--切换数据库</span>
<span class="token keyword">use</span> performance_schema<span class="token punctuation">;</span>

<span class="token comment">--查看当前数据库下的所有表,会看到有很多表存储着相关的信息</span>
<span class="token keyword">show</span> <span class="token keyword">tables</span><span class="token punctuation">;</span>

<span class="token comment">--可以通过show create table tablename来查看创建表的时候的表结构</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">show</span> <span class="token keyword">create</span> <span class="token keyword">table</span> setup_consumers<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">-----------------+---------------------------------</span>
<span class="token operator">|</span> <span class="token keyword">Table</span>           <span class="token operator">|</span> <span class="token keyword">Create</span> <span class="token keyword">Table</span>                    
<span class="token operator">+</span><span class="token comment">-----------------+---------------------------------</span>
<span class="token operator">|</span> setup_consumers <span class="token operator">|</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>setup_consumers<span class="token punctuation">`</span> <span class="token punctuation">(</span>
  <span class="token punctuation">`</span>NAME<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>                      
  <span class="token punctuation">`</span>ENABLED<span class="token punctuation">`</span> <span class="token keyword">enum</span><span class="token punctuation">(</span><span class="token string">'YES'</span><span class="token punctuation">,</span><span class="token string">'NO'</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>               
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span>PERFORMANCE_SCHEMA <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 <span class="token operator">|</span>  
<span class="token operator">+</span><span class="token comment">-----------------+---------------------------------</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>                             
</code></pre></div><h4 id="performance-schema表的分类"><a href="#performance-schema表的分类" class="header-anchor">#</a> performance_schema表的分类</h4> <p>performance_schema库下的表可以按照监视不同的维度就行分组。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--语句事件记录表，这些表记录了语句事件信息，当前语句事件表events_statements_current、历史语句事件表events_statements_history和长语句历史事件表events_statements_history_long、以及聚合后的摘要表summary，其中，summary表还可以根据帐号(account)，主机(host)，程序(program)，线程(thread)，用户(user)和全局(global)再进行细分)</span>
<span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%statement%'</span><span class="token punctuation">;</span>

<span class="token comment">--等待事件记录表，与语句事件类型的相关记录表类似：</span>
<span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%wait%'</span><span class="token punctuation">;</span>

<span class="token comment">--阶段事件记录表，记录语句执行的阶段事件的表</span>
<span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%stage%'</span><span class="token punctuation">;</span>

<span class="token comment">--事务事件记录表，记录事务相关的事件的表</span>
<span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%transaction%'</span><span class="token punctuation">;</span>

<span class="token comment">--监控文件系统层调用的表</span>
<span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%file%'</span><span class="token punctuation">;</span>

<span class="token comment">--监视内存使用的表</span>
<span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%memory%'</span><span class="token punctuation">;</span>

<span class="token comment">--动态对performance_schema进行配置的配置表</span>
<span class="token keyword">show</span> <span class="token keyword">tables</span> <span class="token operator">like</span> <span class="token string">'%setup%'</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="performance-schema的简单配置与使用"><a href="#performance-schema的简单配置与使用" class="header-anchor">#</a> performance_schema的简单配置与使用</h4> <p>数据库刚刚初始化并启动时，并非所有instruments(事件采集项，在采集项的配置表中每一项都有一个开关字段，或为YES，或为NO)和consumers(与采集项类似，也有一个对应的事件类型保存表配置项，为YES就表示对应的表保存性能数据，为NO就表示对应的表不保存性能数据)都启用了，所以默认不会收集所有的事件，可能你需要检测的事件并没有打开，需要进行设置，可以使用如下两个语句打开对应的instruments和consumers（行计数可能会因MySQL版本而异)。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--打开等待事件的采集器配置项开关，需要修改setup_instruments配置表中对应的采集器配置项</span>
<span class="token keyword">UPDATE</span> setup_instruments <span class="token keyword">SET</span> ENABLED <span class="token operator">=</span> <span class="token string">'YES'</span><span class="token punctuation">,</span> TIMED <span class="token operator">=</span> <span class="token string">'YES'</span><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'wait%'</span><span class="token punctuation">;</span>

<span class="token comment">--打开等待事件的保存表配置开关，修改setup_consumers配置表中对应的配置项</span>
<span class="token keyword">UPDATE</span> setup_consumers <span class="token keyword">SET</span> ENABLED <span class="token operator">=</span> <span class="token string">'YES'</span><span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'%wait%'</span><span class="token punctuation">;</span>

<span class="token comment">--当配置完成之后可以查看当前server正在做什么，可以通过查询events_waits_current表来得知，该表中每个线程只包含一行数据，用于显示每个线程的最新监视事件</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> events_waits_current\G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
            THREAD_ID: <span class="token number">11</span>
             EVENT_ID: <span class="token number">570</span>
         END_EVENT_ID: <span class="token number">570</span>
           EVENT_NAME: wait<span class="token operator">/</span>synch<span class="token operator">/</span>mutex<span class="token operator">/</span><span class="token keyword">innodb</span><span class="token operator">/</span>buf_dblwr_mutex
               SOURCE: 
          TIMER_START: <span class="token number">4508505105239280</span>
            TIMER_END: <span class="token number">4508505105270160</span>
           TIMER_WAIT: <span class="token number">30880</span>
                SPINS: <span class="token boolean">NULL</span>
        OBJECT_SCHEMA: <span class="token boolean">NULL</span>
          OBJECT_NAME: <span class="token boolean">NULL</span>
           INDEX_NAME: <span class="token boolean">NULL</span>
          OBJECT_TYPE: <span class="token boolean">NULL</span>
OBJECT_INSTANCE_BEGIN: <span class="token number">67918392</span>
     NESTING_EVENT_ID: <span class="token boolean">NULL</span>
   NESTING_EVENT_TYPE: <span class="token boolean">NULL</span>
            OPERATION: <span class="token keyword">lock</span>
      NUMBER_OF_BYTES: <span class="token boolean">NULL</span>
                FLAGS: <span class="token boolean">NULL</span>
<span class="token comment">/*该信息表示线程id为11的线程正在等待buf_dblwr_mutex锁，等待事件为30880
属性说明：
	id:事件来自哪个线程，事件编号是多少
	event_name:表示检测到的具体的内容
	source:表示这个检测代码在哪个源文件中以及行号
	timer_start:表示该事件的开始时间
	timer_end:表示该事件的结束时间
	timer_wait:表示该事件总的花费时间
注意：_current表中每个线程只保留一条记录，一旦线程完成工作，该表中不会再记录该线程的事件信息
*/</span>

<span class="token comment">/*
_history表中记录每个线程应该执行完成的事件信息，但每个线程的事件信息只会记录10条，再多就会被覆盖，*_history_long表中记录所有线程的事件信息，但总记录数量是10000，超过就会被覆盖掉
*/</span>
<span class="token keyword">select</span> thread_id<span class="token punctuation">,</span>event_id<span class="token punctuation">,</span>event_name<span class="token punctuation">,</span>timer_wait <span class="token keyword">from</span> events_waits_history <span class="token keyword">order</span> <span class="token keyword">by</span> thread_id <span class="token keyword">limit</span> <span class="token number">21</span><span class="token punctuation">;</span>

<span class="token comment">/*
summary表提供所有事件的汇总信息，该组中的表以不同的方式汇总事件数据（如：按用户，按主机，按线程等等）。例如：要查看哪些instruments占用最多的时间，可以通过对events_waits_summary_global_by_event_name表的COUNT_STAR或SUM_TIMER_WAIT列进行查询（这两列是对事件的记录数执行COUNT（*）、事件记录的TIMER_WAIT列执行SUM（TIMER_WAIT）统计而来）
*/</span>
<span class="token keyword">SELECT</span> EVENT_NAME<span class="token punctuation">,</span>COUNT_STAR <span class="token keyword">FROM</span> events_waits_summary_global_by_event_name  <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token comment">/*
instance表记录了哪些类型的对象会被检测。这些对象在被server使用时，在该表中将会产生一条事件记录，例如，file_instances表列出了文件I/O操作及其关联文件名
*/</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> file_instances <span class="token keyword">limit</span> <span class="token number">20</span><span class="token punctuation">;</span> 
</code></pre></div><h4 id="常用配置项的参数说明"><a href="#常用配置项的参数说明" class="header-anchor">#</a> 常用配置项的参数说明</h4> <ul><li><p>启动选项</p> <div class="language-sql extra-class"><pre class="language-sql"><code>performance_schema_consumer_events_statements_current<span class="token operator">=</span><span class="token boolean">TRUE</span>
<span class="token comment">-- 是否在mysql server启动时就开启events_statements_current表的记录功能(该表记录当前的语句事件信息)，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新setup_consumers配置表中的events_statements_current配置项，默认值为TRUE</span>

performance_schema_consumer_events_statements_history<span class="token operator">=</span><span class="token boolean">TRUE</span>
<span class="token comment">-- 与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件短历史信息，默认为TRUE</span>

performance_schema_consumer_events_stages_history_long<span class="token operator">=</span><span class="token boolean">FALSE</span>
<span class="token comment">-- 与performance_schema_consumer_events_statements_current选项类似，但该选项是用于配置是否记录语句事件长历史信息，默认为FALSE</span>

performance_schema_consumer_global_instrumentation<span class="token operator">=</span><span class="token boolean">TRUE</span>
<span class="token comment">-- 是否在MySQL Server启动时就开启全局表（如：mutex_instances、rwlock_instances、cond_instances、file_instances、users、hostsaccounts、socket_summary_by_event_name、file_summary_by_instance等大部分的全局对象计数统计和事件汇总统计信息表 ）的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新全局配置项：默认值为TRUE</span>

performance_schema_consumer_statements_digest<span class="token operator">=</span><span class="token boolean">TRUE</span>
<span class="token comment">-- 是否在MySQL Server启动时就开启events_statements_summary_by_digest 表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新digest配置项：默认值为TRUE</span>

performance_schema_consumer_thread_instrumentation<span class="token operator">=</span><span class="token boolean">TRUE</span>
<span class="token comment">-- 是否在MySQL Server启动时就开启events_xxx_summary_by_yyy_by_event_name表的记录功能，启动之后也可以在setup_consumers表中使用UPDATE语句进行动态更新线程配置项：默认值为TRUE</span>

performance_schema_instrument<span class="token punctuation">[</span><span class="token operator">=</span>name<span class="token punctuation">]</span>
<span class="token comment">-- 是否在MySQL Server启动时就启用某些采集器，由于instruments配置项多达数千个，所以该配置项支持key-value模式，还支持%号进行通配等，如下:</span>
<span class="token comment">-- [=name]可以指定为具体的Instruments名称（但是这样如果有多个需要指定的时候，就需要使用该选项多次），也可以使用通配符，可以指定instruments相同的前缀+通配符，也可以使用%代表所有的instruments</span>

<span class="token comment">-- 指定开启单个instruments</span>
performance<span class="token operator">-</span><span class="token keyword">schema</span><span class="token operator">-</span>instrument<span class="token operator">=</span> <span class="token string">'instrument_name=value'</span>
<span class="token comment">-- 使用通配符指定开启多个instruments</span>
performance<span class="token operator">-</span><span class="token keyword">schema</span><span class="token operator">-</span>instrument<span class="token operator">=</span> <span class="token string">'wait/synch/cond/%=COUNTED'</span>
<span class="token comment">-- 开关所有的instruments</span>
performance<span class="token operator">-</span><span class="token keyword">schema</span><span class="token operator">-</span>instrument<span class="token operator">=</span> <span class="token string">'%=ON'</span>
performance<span class="token operator">-</span><span class="token keyword">schema</span><span class="token operator">-</span>instrument<span class="token operator">=</span> <span class="token string">'%=OFF'</span>
<span class="token comment">-- 注意，这些启动选项要生效的前提是，需要设置performance_schema=ON。另外，这些启动选项虽然无法使用show variables语句查看，但我们可以通过setup_instruments和setup_consumers表查询这些选项指定的值。</span>
</code></pre></div></li> <li><p>系统变量</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%performance_schema%'</span><span class="token punctuation">;</span>
<span class="token comment">--重要的属性解释</span>
performance_schema<span class="token operator">=</span><span class="token keyword">ON</span>
<span class="token comment">/*
控制performance_schema功能的开关，要使用MySQL的performance_schema，需要在mysqld启动时启用，以启用事件收集功能
该参数在5.7.x之前支持performance_schema的版本中默认关闭，5.7.x版本开始默认开启
注意：如果mysqld在初始化performance_schema时发现无法分配任何相关的内部缓冲区，则performance_schema将自动禁用，并将performance_schema设置为OFF
*/</span>

performance_schema_digests_size<span class="token operator">=</span><span class="token number">10000</span>
<span class="token comment">/*
控制events_statements_summary_by_digest表中的最大行数。如果产生的语句摘要信息超过此最大值，便无法继续存入该表，此时performance_schema会增加状态变量
*/</span>
performance_schema_events_statements_history_long_size<span class="token operator">=</span><span class="token number">10000</span>
<span class="token comment">/*
控制events_statements_history_long表中的最大行数，该参数控制所有会话在events_statements_history_long表中能够存放的总事件记录数，超过这个限制之后，最早的记录将被覆盖
全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10000，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10000 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10000
*/</span>
performance_schema_events_statements_history_size<span class="token operator">=</span><span class="token number">10</span>
<span class="token comment">/*
控制events_statements_history表中单个线程（会话）的最大行数，该参数控制单个会话在events_statements_history表中能够存放的事件记录数，超过这个限制之后，单个会话最早的记录将被覆盖
全局变量，只读变量，整型值，5.6.3版本引入 * 5.6.x版本中，5.6.5及其之前的版本默认为10，5.6.6及其之后的版本默认值为-1，通常情况下，自动计算的值都是10 * 5.7.x版本中，默认值为-1，通常情况下，自动计算的值都是10
除了statement(语句)事件之外，wait(等待)事件、state(阶段)事件、transaction(事务)事件，他们与statement事件一样都有三个参数分别进行存储限制配置，有兴趣的同学自行研究，这里不再赘述
*/</span>
performance_schema_max_digest_length<span class="token operator">=</span><span class="token number">1024</span>
<span class="token comment">/*
用于控制标准化形式的SQL语句文本在存入performance_schema时的限制长度，该变量与max_digest_length变量相关(max_digest_length变量含义请自行查阅相关资料)
全局变量，只读变量，默认值1024字节，整型值，取值范围0~1048576
*/</span>
performance_schema_max_sql_text_length<span class="token operator">=</span><span class="token number">1024</span>
<span class="token comment">/*
控制存入events_statements_current，events_statements_history和events_statements_history_long语句事件表中的SQL_TEXT列的最大SQL长度字节数。 超出系统变量performance_schema_max_sql_text_length的部分将被丢弃，不会记录，一般情况下不需要调整该参数，除非被截断的部分与其他SQL比起来有很大差异
全局变量，只读变量，整型值，默认值为1024字节，取值范围为0~1048576，5.7.6版本引入
降低系统变量performance_schema_max_sql_text_length值可以减少内存使用，但如果汇总的SQL中，被截断部分有较大差异，会导致没有办法再对这些有较大差异的SQL进行区分。 增加该系统变量值会增加内存使用，但对于汇总SQL来讲可以更精准地区分不同的部分。
*/</span>
</code></pre></div></li></ul> <h4 id="重要配置表的相关说明"><a href="#重要配置表的相关说明" class="header-anchor">#</a> 重要配置表的相关说明</h4> <blockquote><p>注意：在performance_schema库中还包含了很多其他的库和表，能对数据库的性能做完整的监控，大家需要参考官网详细了解。</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">/*
performance_timers表中记录了server中有哪些可用的事件计时器
字段解释：
	timer_name:表示可用计时器名称，CYCLE是基于CPU周期计数器的定时器
	timer_frequency:表示每秒钟对应的计时器单位的数量,CYCLE计时器的换算值与CPU的频率相关、
	timer_resolution:计时器精度值，表示在每个计时器被调用时额外增加的值
	timer_overhead:表示在使用定时器获取事件时开销的最小周期值
*/</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> performance_timers<span class="token punctuation">;</span>

<span class="token comment">/*
setup_timers表中记录当前使用的事件计时器信息
字段解释：
	name:计时器类型，对应某个事件类别
	timer_name:计时器类型名称
*/</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> setup_timers<span class="token punctuation">;</span>

<span class="token comment">/*
setup_consumers表中列出了consumers可配置列表项
字段解释：
	NAME：consumers配置名称
	ENABLED：consumers是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。
*/</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> setup_consumers<span class="token punctuation">;</span>

<span class="token comment">/*
setup_instruments 表列出了instruments 列表配置项，即代表了哪些事件支持被收集：
字段解释：
	NAME：instruments名称，instruments名称可能具有多个部分并形成层次结构
	ENABLED：instrumetns是否启用，有效值为YES或NO，此列可以使用UPDATE语句修改。如果设置为NO，则这个instruments不会被执行，不会产生任何的事件信息
	TIMED：instruments是否收集时间信息，有效值为YES或NO，此列可以使用UPDATE语句修改，如果设置为NO，则这个instruments不会收集时间信息
*/</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> setup_instruments<span class="token punctuation">;</span>

<span class="token comment">/*
setup_actors表的初始内容是匹配任何用户和主机，因此对于所有前台线程，默认情况下启用监视和历史事件收集功能
字段解释：
	HOST：与grant语句类似的主机名，一个具体的字符串名字，或使用“％”表示“任何主机”
	USER：一个具体的字符串名称，或使用“％”表示“任何用户”
	ROLE：当前未使用，MySQL 8.0中才启用角色功能
	ENABLED：是否启用与HOST，USER，ROLE匹配的前台线程的监控功能，有效值为：YES或NO
	HISTORY：是否启用与HOST， USER，ROLE匹配的前台线程的历史事件记录功能，有效值为：YES或NO
*/</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> setup_actors<span class="token punctuation">;</span>

<span class="token comment">/*
setup_objects表控制performance_schema是否监视特定对象。默认情况下，此表的最大行数为100行。
字段解释：
	OBJECT_TYPE：instruments类型，有效值为：“EVENT”（事件调度器事件）、“FUNCTION”（存储函数）、“PROCEDURE”（存储过程）、“TABLE”（基表）、“TRIGGER”（触发器），TABLE对象类型的配置会影响表I/O事件（wait/io/table/sql/handler instrument）和表锁事件（wait/lock/table/sql/handler instrument）的收集
	OBJECT_SCHEMA：某个监视类型对象涵盖的数据库名称，一个字符串名称，或“％”(表示“任何数据库”)
	OBJECT_NAME：某个监视类型对象涵盖的表名，一个字符串名称，或“％”(表示“任何数据库内的对象”)
	ENABLED：是否开启对某个类型对象的监视功能，有效值为：YES或NO。此列可以修改
	TIMED：是否开启对某个类型对象的时间收集功能，有效值为：YES或NO，此列可以修改
*/</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> setup_objects<span class="token punctuation">;</span>

<span class="token comment">/*
threads表对于每个server线程生成一行包含线程相关的信息，
字段解释：
	THREAD_ID：线程的唯一标识符（ID）
	NAME：与server中的线程检测代码相关联的名称(注意，这里不是instruments名称)
	TYPE：线程类型，有效值为：FOREGROUND、BACKGROUND。分别表示前台线程和后台线程
	PROCESSLIST_ID：对应INFORMATION_SCHEMA.PROCESSLIST表中的ID列。
	PROCESSLIST_USER：与前台线程相关联的用户名，对于后台线程为NULL。
	PROCESSLIST_HOST：与前台线程关联的客户端的主机名，对于后台线程为NULL。
	PROCESSLIST_DB：线程的默认数据库，如果没有，则为NULL。
	PROCESSLIST_COMMAND：对于前台线程，该值代表着当前客户端正在执行的command类型，如果是sleep则表示当前会话处于空闲状态
	PROCESSLIST_TIME：当前线程已处于当前线程状态的持续时间（秒）
	PROCESSLIST_STATE：表示线程正在做什么事情。
	PROCESSLIST_INFO：线程正在执行的语句，如果没有执行任何语句，则为NULL。
	PARENT_THREAD_ID：如果这个线程是一个子线程（由另一个线程生成），那么该字段显示其父线程ID
	ROLE：暂未使用
	INSTRUMENTED：线程执行的事件是否被检测。有效值：YES、NO 
	HISTORY：是否记录线程的历史事件。有效值：YES、NO * 
	THREAD_OS_ID：由操作系统层定义的线程或任务标识符（ID）：
*/</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> threads
</code></pre></div><h4 id="performance-schema实践操作"><a href="#performance-schema实践操作" class="header-anchor">#</a> performance_schema实践操作</h4> <blockquote><p>基本了解了表的相关信息之后，可以通过这些表进行实际的查询操作来进行实际的分析。</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--1、哪类的SQL执行最多？</span>
<span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>COUNT_STAR<span class="token punctuation">,</span>FIRST_SEEN<span class="token punctuation">,</span>LAST_SEEN <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span>
<span class="token comment">--2、哪类SQL的平均响应时间最多？</span>
<span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>AVG_TIMER_WAIT <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span>
<span class="token comment">--3、哪类SQL排序记录数最多？</span>
<span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>SUM_SORT_ROWS <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span>
<span class="token comment">--4、哪类SQL扫描记录数最多？</span>
<span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>SUM_ROWS_EXAMINED <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span>
<span class="token comment">--5、哪类SQL使用临时表最多？</span>
<span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>SUM_CREATED_TMP_TABLES<span class="token punctuation">,</span>SUM_CREATED_TMP_DISK_TABLES <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span>
<span class="token comment">--6、哪类SQL返回结果集最多？</span>
<span class="token keyword">SELECT</span> DIGEST_TEXT<span class="token punctuation">,</span>SUM_ROWS_SENT <span class="token keyword">FROM</span> events_statements_summary_by_digest <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> COUNT_STAR <span class="token keyword">DESC</span>
<span class="token comment">--7、哪个表物理IO最多？</span>
<span class="token keyword">SELECT</span> file_name<span class="token punctuation">,</span>event_name<span class="token punctuation">,</span>SUM_NUMBER_OF_BYTES_READ<span class="token punctuation">,</span>SUM_NUMBER_OF_BYTES_WRITE <span class="token keyword">FROM</span> file_summary_by_instance <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> SUM_NUMBER_OF_BYTES_READ <span class="token operator">+</span> SUM_NUMBER_OF_BYTES_WRITE <span class="token keyword">DESC</span>
<span class="token comment">--8、哪个表逻辑IO最多？</span>
<span class="token keyword">SELECT</span> object_name<span class="token punctuation">,</span>COUNT_READ<span class="token punctuation">,</span>COUNT_WRITE<span class="token punctuation">,</span>COUNT_FETCH<span class="token punctuation">,</span>SUM_TIMER_WAIT <span class="token keyword">FROM</span> table_io_waits_summary_by_table <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> sum_timer_wait <span class="token keyword">DESC</span>
<span class="token comment">--9、哪个索引访问最多？</span>
<span class="token keyword">SELECT</span> OBJECT_NAME<span class="token punctuation">,</span>INDEX_NAME<span class="token punctuation">,</span>COUNT_FETCH<span class="token punctuation">,</span>COUNT_INSERT<span class="token punctuation">,</span>COUNT_UPDATE<span class="token punctuation">,</span>COUNT_DELETE <span class="token keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> SUM_TIMER_WAIT <span class="token keyword">DESC</span>
<span class="token comment">--10、哪个索引从来没有用过？</span>
<span class="token keyword">SELECT</span> OBJECT_SCHEMA<span class="token punctuation">,</span>OBJECT_NAME<span class="token punctuation">,</span>INDEX_NAME <span class="token keyword">FROM</span> table_io_waits_summary_by_index_usage <span class="token keyword">WHERE</span> INDEX_NAME <span class="token operator">IS</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token operator">AND</span> COUNT_STAR <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">AND</span> OBJECT_SCHEMA <span class="token operator">&lt;&gt;</span> <span class="token string">'mysql'</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> OBJECT_SCHEMA<span class="token punctuation">,</span>OBJECT_NAME<span class="token punctuation">;</span>
<span class="token comment">--11、哪个等待事件消耗时间最多？</span>
<span class="token keyword">SELECT</span> EVENT_NAME<span class="token punctuation">,</span>COUNT_STAR<span class="token punctuation">,</span>SUM_TIMER_WAIT<span class="token punctuation">,</span>AVG_TIMER_WAIT <span class="token keyword">FROM</span> events_waits_summary_global_by_event_name <span class="token keyword">WHERE</span> event_name <span class="token operator">!=</span> <span class="token string">'idle'</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> SUM_TIMER_WAIT <span class="token keyword">DESC</span>
<span class="token comment">--12-1、剖析某条SQL的执行情况，包括statement信息，stege信息，wait信息</span>
<span class="token keyword">SELECT</span> EVENT_ID<span class="token punctuation">,</span>sql_text <span class="token keyword">FROM</span> events_statements_history <span class="token keyword">WHERE</span> sql_text <span class="token operator">LIKE</span> <span class="token string">'%count(*)%'</span><span class="token punctuation">;</span>
<span class="token comment">--12-2、查看每个阶段的时间消耗</span>
<span class="token keyword">SELECT</span> event_id<span class="token punctuation">,</span>EVENT_NAME<span class="token punctuation">,</span>SOURCE<span class="token punctuation">,</span>TIMER_END <span class="token operator">-</span> TIMER_START <span class="token keyword">FROM</span> events_stages_history_long <span class="token keyword">WHERE</span> NESTING_EVENT_ID <span class="token operator">=</span> <span class="token number">1553</span><span class="token punctuation">;</span>
<span class="token comment">--12-3、查看每个阶段的锁等待情况</span>
<span class="token keyword">SELECT</span> event_id<span class="token punctuation">,</span>event_name<span class="token punctuation">,</span>source<span class="token punctuation">,</span>timer_wait<span class="token punctuation">,</span>object_name<span class="token punctuation">,</span>index_name<span class="token punctuation">,</span>operation<span class="token punctuation">,</span>nesting_event_id <span class="token keyword">FROM</span> events_waits_history_longWHERE nesting_event_id <span class="token operator">=</span> <span class="token number">1553</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="使用-show-processlist-查看连接的线程个数"><a href="#使用-show-processlist-查看连接的线程个数" class="header-anchor">#</a> 使用 show processlist 查看连接的线程个数</h3> <blockquote><p>可以观察是否有大量线程处于不正常的状态或者其他不正常的特征</p></blockquote> <p><img src="/images/show-processlist.png" alt="show-processlist"></p> <p>属性说明：</p> <ul><li>id表示session id</li> <li>user表示操作的用户</li> <li>host表示操作的主机</li> <li>db表示操作的数据库</li> <li>command表示当前状态
<ul><li>sleep：线程正在等待客户端发送新的请求</li> <li>query：线程正在执行查询或正在将结果发送给客户端</li> <li>locked：在mysql的服务层，该线程正在等待表锁</li> <li>analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划</li> <li>Copying to tmp table：线程正在执行查询，并且将其结果集都复制到一个临时表中</li> <li>sorting result：线程正在对结果集进行排序</li> <li>sending data：线程可能在多个状态之间传送数据，或者在生成结果集或者向客户端返回数据</li></ul></li> <li>time表示相应命令执行时间</li> <li>state表示命令执行状态</li> <li>info表示详细的sql语句</li></ul> <h2 id="schema与数据类型优化"><a href="#schema与数据类型优化" class="header-anchor">#</a> schema与数据类型优化</h2> <h3 id="数据类型的优化"><a href="#数据类型的优化" class="header-anchor">#</a> 数据类型的优化</h3> <h4 id="更小的通常更好"><a href="#更小的通常更好" class="header-anchor">#</a> 更小的通常更好</h4> <blockquote><p>应该尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期更少，但是要确保没有低估需要存储的值的范围，如果无法确认哪个数据类型，就选择你认为不会超过范围的最小类型
案例：设计两张表，设计不同的数据类型，查看表的容量</p></blockquote> <h4 id="简单就好"><a href="#简单就好" class="header-anchor">#</a> 简单就好</h4> <blockquote><p>简单数据类型的操作通常需要更少的CPU周期，例如，
1、整型比字符操作代价更低，因为字符集和校对规则是字符比较比整型比较更复杂，
2、使用mysql自建类型而不是字符串来存储日期和时间
3、用整型存储IP地址
案例：创建两张相同的表，改变日期的数据类型，查看SQL语句执行的速度</p></blockquote> <h4 id="尽量避免null"><a href="#尽量避免null" class="header-anchor">#</a> 尽量避免null</h4> <blockquote><p>如果查询中包含可为NULL的列，对mysql来说很难优化，因为可为null的列使得索引、索引统计和值比较都更加复杂，坦白来说，通常情况下null的列改为not null带来的性能提升比较小，所有没有必要将所有的表的schema进行修改，但是应该尽量避免设计成可为null的列</p></blockquote> <h4 id="实际细则"><a href="#实际细则" class="header-anchor">#</a> 实际细则</h4> <h5 id="整数类型"><a href="#整数类型" class="header-anchor">#</a> 整数类型</h5> <blockquote><p>可以使用的几种整数类型：TINYINT，SMALLINT，MEDIUMINT，INT，BIGINT分别使用8，16，24，32，64位存储空间。
尽量使用满足需求的最小数据类型</p></blockquote> <h5 id="字符和字符串类型"><a href="#字符和字符串类型" class="header-anchor">#</a> 字符和字符串类型</h5> <blockquote><p>1、char长度固定，即每条数据占用等长字节空间；最大长度是255个字符，适合用在身份证号、手机号等定长字符串
2、varchar可变程度，可以设置最大长度；最大空间是65535个字节，适合用在长度可变的属性
3、text不设置长度，当不知道属性的最大长度时，适合用text
按照查询速度：char&gt;varchar&gt;text</p></blockquote> <ul><li>varchar根据实际内容长度保存数据
<ol><li>使用最小的符合需求的长度。</li> <li>varchar(n) n小于等于255使用额外一个字节保存长度，n&gt;255使用额外两个字节保存长度。</li> <li>varchar(5)与varchar(255)保存同样的内容，硬盘存储空间相同，但内存空间占用不同，是指定的大小 。</li> <li>varchar在mysql5.6之前变更长度，或者从255一下变更到255以上时时，都会导致锁表。</li> <li>应用场景
<ul><li>存储长度波动较大的数据，如：文章，有的会很短有的会很长</li> <li>字符串很少更新的场景，每次更新后都会重算并使用额外存储空间保存长度</li> <li>适合保存多字节字符，如：汉字，特殊字符等</li></ul></li></ol></li> <li>char固定长度的字符串
<ol><li>最大长度：255</li> <li>会自动删除末尾的空格</li> <li>检索效率、写效率 会比varchar高，以空间换时间</li> <li>应用场景
<ul><li>存储长度波动不大的数据，如：md5摘要</li> <li>存储短字符串、经常更新的字符串</li></ul></li></ol></li></ul> <h5 id="blob和text类型"><a href="#blob和text类型" class="header-anchor">#</a> BLOB和TEXT类型</h5> <blockquote><p>MySQL 把每个 BLOB 和 TEXT 值当作一个独立的对象处理。
两者都是为了存储很大数据而设计的字符串类型，分别采用二进制和字符方式存储。</p></blockquote> <h5 id="datetime和timestamp"><a href="#datetime和timestamp" class="header-anchor">#</a> datetime和timestamp</h5> <blockquote><p>1、不要使用字符串类型来存储日期时间数据
2、日期时间类型通常比字符串占用的存储空间小
3、日期时间类型在进行查找过滤时可以利用日期来进行比对
4、日期时间类型还有着丰富的处理函数，可以方便的对时间类型进行日期计算
5、使用int存储日期时间不如使用timestamp类型</p></blockquote> <ol><li>datetime
<ul><li>占用8个字节</li> <li>与时区无关，数据库底层时区配置，对datetime无效</li> <li>可保存到毫秒</li> <li>可保存时间范围大</li> <li>不要使用字符串存储日期类型，占用空间大，损失日期类型函数的便捷性</li></ul></li> <li>timestamp
<ul><li>占用4个字节</li> <li>时间范围：1970-01-01到2038-01-19</li> <li>精确到秒</li> <li>采用整形存储</li> <li>依赖数据库设置的时区</li> <li>自动更新timestamp列的值</li></ul></li> <li>date
<ul><li>占用的字节数比使用字符串、datetime、int存储要少，使用date类型只需要3个字节</li> <li>使用date类型还可以利用日期时间函数进行日期之间的计算</li> <li>date类型用于保存1000-01-01到9999-12-31之间的日期</li></ul></li></ol> <h5 id="使用枚举代替字符串类型"><a href="#使用枚举代替字符串类型" class="header-anchor">#</a> 使用枚举代替字符串类型</h5> <blockquote><p>有时可以使用枚举类代替常用的字符串类型，mysql存储枚举类型会非常紧凑，会根据列表值的数据压缩到一个或两个字节中，mysql在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的查找表
create table enum_test(e enum('fish','apple','dog') not null);
insert into enum_test(e) values('fish'),('dog'),('apple');
select e+0 from enum_test;</p></blockquote> <h5 id="特殊类型数据"><a href="#特殊类型数据" class="header-anchor">#</a> 特殊类型数据</h5> <blockquote><p>人们经常使用varchar(15)来存储ip地址，然而，它的本质是32位无符号整数不是字符串，可以使用INET_ATON()和INET_NTOA函数在这两种表示方法之间转换
案例：
select inet_aton('1.1.1.1')
select inet_ntoa(16843009)</p></blockquote> <h3 id="合理使用范式和反范式"><a href="#合理使用范式和反范式" class="header-anchor">#</a> 合理使用范式和反范式</h3> <h4 id="范式"><a href="#范式" class="header-anchor">#</a> 范式</h4> <h5 id="优点："><a href="#优点：" class="header-anchor">#</a> 优点：</h5> <ul><li>范式化的更新通常比反范式要快</li> <li>当数据较好的范式化后，很少或者没有重复的数据</li> <li>范式化的数据比较小，可以放在内存中，操作比较快</li></ul> <h5 id="缺点："><a href="#缺点：" class="header-anchor">#</a> 缺点：</h5> <ul><li>通常需要进行关联</li></ul> <h4 id="反范式"><a href="#反范式" class="header-anchor">#</a> 反范式</h4> <h5 id="优点：-2"><a href="#优点：-2" class="header-anchor">#</a> 优点：</h5> <ul><li>所有的数据都在同一张表中，可以避免关联</li> <li>可以设计有效的索引；</li></ul> <h5 id="缺点：-2"><a href="#缺点：-2" class="header-anchor">#</a> 缺点：</h5> <ul><li>表格内的冗余较多，删除数据时候会造成表有些有用的信息丢失</li></ul> <h4 id="需要注意的是："><a href="#需要注意的是：" class="header-anchor">#</a> 需要注意的是：</h4> <blockquote><p>在企业中很好能做到严格意义上的范式或者反范式，一般需要混合使用</p></blockquote> <ul><li>在一个网站实例中，这个网站，允许用户发送消息，并且一些用户是付费用户。现在想查看付费用户最近的10条信息。 在user表和message表中都存储用户类型(account_type)而不用完全的反范式化。这避免了完全反范式化的插入和删除问题，因为即使没有消息的时候也绝不会丢失用户的信息。这样也不会把user_message表搞得太大，有利于高效地获取数据。</li> <li>另一个从父表冗余一些数据到子表的理由是排序的需要。</li> <li>缓存衍生值也是有用的。如果需要显示每个用户发了多少消息（类似论坛的），可以每次执行一个昂贵的自查询来计算并显示它；也可以在user表中建一个num_messages列，每当用户发新消息时更新这个值。</li></ul> <h3 id="主键的选择"><a href="#主键的选择" class="header-anchor">#</a> 主键的选择</h3> <h4 id="代理主键"><a href="#代理主键" class="header-anchor">#</a> 代理主键</h4> <blockquote><p>与业务无关的，无意义的数字序列</p></blockquote> <h4 id="自然主键"><a href="#自然主键" class="header-anchor">#</a> 自然主键</h4> <blockquote><p>事物属性中的自然唯一标识</p></blockquote> <h4 id="推荐使用代理主键"><a href="#推荐使用代理主键" class="header-anchor">#</a> 推荐使用代理主键</h4> <blockquote><ol><li>它们不与业务耦合，因此更容易维护</li> <li>一个大多数表，最好是全部表，通用的键策略能够减少需要编写的源码数量，减少系统的总体拥有成本</li></ol></blockquote> <h3 id="字符集的选择"><a href="#字符集的选择" class="header-anchor">#</a> 字符集的选择</h3> <blockquote><p>字符集直接决定了数据在MySQL中的存储编码方式，由于同样的内容使用不同字符集表示所占用的空间大小会有较大的差异，所以通过使用合适的字符集，可以帮助我们尽可能减少数据量，进而减少IO操作次数。</p></blockquote> <ol><li>纯拉丁字符能表示的内容，没必要选择 latin1 之外的其他字符编码，因为这会节省大量的存储空间。</li> <li>如果我们可以确定不需要存放多种语言，就没必要非得使用UTF8或者其他UNICODE字符类型，这回造成大量的存储空间浪费。</li> <li>MySQL的数据类型可以精确到字段，所以当我们需要大型数据库中存放多字节数据的时候，可以通过对不同表不同字段使用不同的数据类型来较大程度减小数据存储量，进而降低 IO 操作次数并提高缓存命中率。</li></ol> <h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="header-anchor">#</a> 存储引擎的选择</h3> <blockquote><p>区别在于：数据文件的组织形式</p> <p>聚簇索引：数据和索引存放在一起</p> <p>非聚簇索引：数据和文件没有放在一起</p></blockquote> <p><img src="/images/MySQL%E5%BC%95%E6%93%8E%E5%8C%BA%E5%88%AB.png" alt="MySQL引擎区别"></p> <h4 id="innodb-2"><a href="#innodb-2" class="header-anchor">#</a> InnoDB</h4> <h4 id="myisam-2"><a href="#myisam-2" class="header-anchor">#</a> MyISAM</h4> <h3 id="适当的数据冗余"><a href="#适当的数据冗余" class="header-anchor">#</a> 适当的数据冗余</h3> <ol><li>被频繁引用且只能通过 Join 2张(或者更多)大表的方式才能得到的独立小字段。</li> <li>这样的场景由于每次Join仅仅只是为了取得某个小字段的值，Join到的记录又大，会造成大量不必要的 IO，完全可以通过空间换取时间的方式来优化。不过，冗余的同时需要确保数据的一致性不会遭到破坏，确保更新的同时冗余字段也被更新。</li></ol> <h3 id="适当拆分"><a href="#适当拆分" class="header-anchor">#</a> 适当拆分</h3> <blockquote><p>当我们的表中存在类似于 TEXT 或者是很大的 VARCHAR类型的大字段的时候，如果我们大部分访问这张表的时候都不需要这个字段，我们就该义无反顾的将其拆分到另外的独立表中，以减少常用数据所占用的存储空间。这样做的一个明显好处就是每个数据块中可以存储的数据条数可以大大增加，既减少物理 IO 次数，也能大大提高内存中的缓存命中率。</p></blockquote> <h2 id="执行计划"><a href="#执行计划" class="header-anchor">#</a> 执行计划</h2> <blockquote><p>在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。</p> <p>官网地址： <a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html" target="_blank" rel="noopener noreferrer">https://dev.mysql.com/doc/refman/5.5/en/explain-output.html<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>执行计划中包含的信息：</p> <p><img src="/images/%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92.png" alt="执行计划"></p></blockquote> <p>属性解释：</p> <h3 id="id"><a href="#id" class="header-anchor">#</a> id</h3> <blockquote><p>select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序</p></blockquote> <p>id号分为三种情况：</p> <ol><li><p>如果id相同，那么执行顺序从上到下</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">join</span> dept d <span class="token keyword">on</span> e<span class="token punctuation">.</span>deptno <span class="token operator">=</span> d<span class="token punctuation">.</span>deptno <span class="token keyword">join</span> salgrade sg <span class="token keyword">on</span> e<span class="token punctuation">.</span>sal <span class="token operator">between</span> sg<span class="token punctuation">.</span>losal <span class="token operator">and</span> sg<span class="token punctuation">.</span>hisal<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">where</span> e<span class="token punctuation">.</span>deptno <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> d<span class="token punctuation">.</span>deptno <span class="token keyword">from</span> dept d <span class="token keyword">where</span> d<span class="token punctuation">.</span>dname <span class="token operator">=</span> <span class="token string">'SALES'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>d相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">join</span> dept d <span class="token keyword">on</span> e<span class="token punctuation">.</span>deptno <span class="token operator">=</span> d<span class="token punctuation">.</span>deptno <span class="token keyword">join</span> salgrade sg <span class="token keyword">on</span> e<span class="token punctuation">.</span>sal <span class="token operator">between</span> sg<span class="token punctuation">.</span>losal <span class="token operator">and</span> sg<span class="token punctuation">.</span>hisal <span class="token keyword">where</span> e<span class="token punctuation">.</span>deptno <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> d<span class="token punctuation">.</span>deptno <span class="token keyword">from</span> dept d <span class="token keyword">where</span> d<span class="token punctuation">.</span>dname <span class="token operator">=</span> <span class="token string">'SALES'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <h3 id="select-type"><a href="#select-type" class="header-anchor">#</a> select_type</h3> <blockquote><p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--sample:简单的查询，不包含子查询和union</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span>

<span class="token comment">--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> staname<span class="token punctuation">,</span>ename supname <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> ename staname<span class="token punctuation">,</span>mgr <span class="token keyword">from</span> emp<span class="token punctuation">)</span> t <span class="token keyword">join</span> emp <span class="token keyword">on</span> t<span class="token punctuation">.</span>mgr<span class="token operator">=</span>emp<span class="token punctuation">.</span>empno <span class="token punctuation">;</span>

<span class="token comment">--union:若第二个select出现在union之后，则被标记为union</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">&gt;</span><span class="token number">2000</span><span class="token punctuation">;</span>

<span class="token comment">--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">where</span> e<span class="token punctuation">.</span>empno  <span class="token operator">in</span> <span class="token punctuation">(</span> <span class="token keyword">select</span> empno <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">union</span> <span class="token keyword">select</span> empno <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">&gt;</span><span class="token number">2000</span><span class="token punctuation">)</span>

<span class="token comment">--union result:从union表获取结果的select</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">union</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">&gt;</span><span class="token number">2000</span><span class="token punctuation">;</span>

<span class="token comment">--subquery:在select或者where列表中包含子查询</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> sal <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token function">avg</span><span class="token punctuation">(</span>sal<span class="token punctuation">)</span> <span class="token keyword">from</span> emp<span class="token punctuation">)</span> <span class="token punctuation">;</span>

<span class="token comment">--dependent subquery:subquery的子查询要受到外部表查询的影响</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">where</span> e<span class="token punctuation">.</span>deptno <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">distinct</span> deptno <span class="token keyword">from</span> dept<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">--DERIVED: from子句中出现的子查询，也叫做派生类，</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> staname<span class="token punctuation">,</span>ename supname <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> ename staname<span class="token punctuation">,</span>mgr <span class="token keyword">from</span> emp<span class="token punctuation">)</span> t <span class="token keyword">join</span> emp <span class="token keyword">on</span> t<span class="token punctuation">.</span>mgr<span class="token operator">=</span>emp<span class="token punctuation">.</span>empno <span class="token punctuation">;</span>

<span class="token comment">--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span>
 <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> empno <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">select</span> empno <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno<span class="token operator">=</span>@<span class="token variable">@sort_buffer_size</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span>

</code></pre></div><h3 id="table"><a href="#table" class="header-anchor">#</a> table</h3> <blockquote><p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集</p></blockquote> <ol><li>如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</li> <li>表名是derivedN的形式，表示使用了id为N的查询产生的衍生表</li> <li>当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</li></ol> <h3 id="partitions"><a href="#partitions" class="header-anchor">#</a> partitions</h3> <blockquote><p>使用的分区</p></blockquote> <h3 id="type"><a href="#type" class="header-anchor">#</a> type</h3> <blockquote><p>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p> <p><font color="red">**system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL **</font></p> <p>一般情况下，得保证查询至少达到range级别，最好能达到ref</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span>

<span class="token comment">--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span>
<span class="token keyword">explain</span>  <span class="token keyword">select</span> empno <span class="token keyword">from</span> emp<span class="token punctuation">;</span>

<span class="token comment">--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> empno <span class="token operator">between</span> <span class="token number">7000</span> <span class="token operator">and</span> <span class="token number">7500</span><span class="token punctuation">;</span>

<span class="token comment">--index_subquery：利用索引来关联子查询，不再扫描全表</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> emp<span class="token punctuation">.</span>job <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> job <span class="token keyword">from</span> t_job<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span>
 <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">where</span> e<span class="token punctuation">.</span>deptno <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token keyword">distinct</span> deptno <span class="token keyword">from</span> dept<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span>

<span class="token comment">--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e <span class="token keyword">where</span>  e<span class="token punctuation">.</span>mgr <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token operator">or</span> e<span class="token punctuation">.</span>mgr<span class="token operator">=</span><span class="token number">7369</span><span class="token punctuation">;</span>

<span class="token comment">--ref：使用了非唯一性索引进行数据的查找</span>
 <span class="token keyword">create</span> <span class="token keyword">index</span> idx_3 <span class="token keyword">on</span> emp<span class="token punctuation">(</span>deptno<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp e<span class="token punctuation">,</span>dept d <span class="token keyword">where</span> e<span class="token punctuation">.</span>deptno <span class="token operator">=</span>d<span class="token punctuation">.</span>deptno<span class="token punctuation">;</span>

<span class="token comment">--eq_ref ：使用唯一性索引进行数据查找</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>emp2 <span class="token keyword">where</span> emp<span class="token punctuation">.</span>empno <span class="token operator">=</span> emp2<span class="token punctuation">.</span>empno<span class="token punctuation">;</span>

<span class="token comment">--const：这个表至多有一个匹配行，</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> empno <span class="token operator">=</span> <span class="token number">7369</span><span class="token punctuation">;</span>
 
<span class="token comment">--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span>
</code></pre></div><h3 id="possible-keys"><a href="#possible-keys" class="header-anchor">#</a> possible_keys</h3> <blockquote><p>显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno <span class="token operator">and</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="key"><a href="#key" class="header-anchor">#</a> key</h3> <blockquote><p>实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno <span class="token operator">and</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="key-len"><a href="#key-len" class="header-anchor">#</a> key_len</h3> <blockquote><p>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno <span class="token operator">and</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="ref"><a href="#ref" class="header-anchor">#</a> ref</h3> <blockquote><p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">,</span>dept <span class="token keyword">where</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> dept<span class="token punctuation">.</span>deptno <span class="token operator">and</span> emp<span class="token punctuation">.</span>deptno <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="rows"><a href="#rows" class="header-anchor">#</a> rows</h3> <blockquote><p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp<span class="token punctuation">;</span>
</code></pre></div><h3 id="extra"><a href="#extra" class="header-anchor">#</a> extra</h3> <blockquote><p>包含额外的信息。</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">order</span> <span class="token keyword">by</span> sal<span class="token punctuation">;</span>

<span class="token comment">--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> ename<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> deptno <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">group</span> <span class="token keyword">by</span> ename<span class="token punctuation">;</span>

<span class="token comment">--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> deptno<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> emp <span class="token keyword">group</span> <span class="token keyword">by</span> deptno <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token comment">--using where:使用where进行条件过滤</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">--using join buffer:使用连接缓存，情况没有模拟出来</span>

<span class="token comment">--impossible where：where语句的结果总是false</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> emp <span class="token keyword">where</span> empno <span class="token operator">=</span> <span class="token number">7469</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="通过索引进行优化"><a href="#通过索引进行优化" class="header-anchor">#</a> 通过索引进行优化</h2> <h3 id="索引基本知识"><a href="#索引基本知识" class="header-anchor">#</a> 索引基本知识</h3> <h4 id="索引的优点"><a href="#索引的优点" class="header-anchor">#</a> 索引的优点</h4> <ol><li>大大减少了服务器需要扫描的数据量，加快数据的检索速度</li> <li>帮助服务器避免排序和临时表</li> <li>索引可以将随机I/O变为顺序I/O</li></ol> <h4 id="索引的用处"><a href="#索引的用处" class="header-anchor">#</a> 索引的用处</h4> <ol><li>快速查找匹配WHERE子句的行</li> <li>从consideration中消除行，如果可以在多个索引之间进行选择，mysql通常会使用找到最少行的索引</li> <li>如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行</li> <li>当有表连接的时候，从其他表检索行数据</li> <li>查找特定索引列的min或max值</li> <li>如果排序或分组时在可用索引的最左前缀上完成的，再对表进行排序和分组</li> <li>在某些情况下，可以优化查询以检索值而无需查询数据行</li></ol> <h4 id="索引的分类"><a href="#索引的分类" class="header-anchor">#</a> 索引的分类</h4> <ol><li>主键索引：是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引</li> <li>唯一索引：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</li> <li>普通索引：最基本的索引，它没有任何限制，用于加速查询</li> <li>全文索引：主要用来查找文本中的关键字，而不是直接与索引中的值相比较。fulltext索引配合match against操作使用，而不是一般的where语句加like。目前只有char、varchar，text 列上可以创建全文索引。MyISAM是全文索引，InnoDB5.6以后支持全文索引。</li> <li>组合索引：指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用组合索引时遵循最左前缀集合。</li></ol> <h4 id="面试技术名词"><a href="#面试技术名词" class="header-anchor">#</a> 面试技术名词</h4> <h5 id="回表"><a href="#回表" class="header-anchor">#</a> 回表</h5> <blockquote><p>先根据普通索引定位主键值（普通索引的B+树叶子节点存储的主键而不是数据行记录），然后再根据主键值定位行记录，需要遍历两颗B+树。</p></blockquote> <h5 id="覆盖索引"><a href="#覆盖索引" class="header-anchor">#</a> 覆盖索引</h5> <blockquote><p>索引覆盖是一种避免回表查询的优化策略。具体的做法就是将要查询的数据作为索引列建立普通索引（可以是单列索引，也可以是联合索引），这样的话就可以直接返回索引中的的数据，不需要再通过主键索引去定位行记录，避免了回表的情况发生。</p></blockquote> <h5 id="最左匹配"><a href="#最左匹配" class="header-anchor">#</a> 最左匹配</h5> <blockquote><p>按照索引的字段顺序，先匹配左边的字段</p></blockquote> <h5 id="索引下推"><a href="#索引下推" class="header-anchor">#</a> 索引下推</h5> <blockquote><p>索引下推简而言之就是在复合索引由于某些条件(比如 like %aa)失效的情况下，当存在失效的过滤字段在索引覆盖范围内，使用比较的方式在不回表的情况下进一步缩小查询的范围。其实就是对索引失效的进一步修复，属于最左前缀索引原则的一个意外情况。</p> <p>索引下推触发的条件</p> <ol><li>查询条件是复合索引</li> <li>失效条件的字段在索引覆盖的范围内</li> <li>失效条件是可以通过数据进行比较的简单对比</li></ol> <p>索引下推可以使用的场景：</p> <ol><li>like查询</li> <li>函数在左的查询,比如CHAR_LENGTH(colName)=5</li></ol></blockquote> <h4 id="索引采用的数据结构"><a href="#索引采用的数据结构" class="header-anchor">#</a> 索引采用的数据结构</h4> <ol><li>哈希表（存储引擎是Memory支持）</li> <li>B+树（存储引擎是InnoDB和MyISAM支持）</li></ol> <h4 id="索引匹配方式"><a href="#索引匹配方式" class="header-anchor">#</a> 索引匹配方式</h4> <h5 id="全值匹配"><a href="#全值匹配" class="header-anchor">#</a> 全值匹配</h5> <blockquote><p>全值匹配指的是和索引中的所有列进行匹配</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> staffs <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'July'</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token string">'23'</span> <span class="token operator">and</span> pos <span class="token operator">=</span> <span class="token string">'dev'</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="匹配最左前缀"><a href="#匹配最左前缀" class="header-anchor">#</a> 匹配最左前缀</h5> <blockquote><p>只匹配前面的几列</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> staffs <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'July'</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token string">'23'</span><span class="token punctuation">;</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> staffs <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'July'</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="匹配列前缀"><a href="#匹配列前缀" class="header-anchor">#</a> 匹配列前缀</h5> <blockquote><p>可以匹配某一列的值的开头部分</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 正确</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> staffs <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'J%'</span><span class="token punctuation">;</span>
<span class="token comment">-- 错误</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> staffs <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'%y'</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="匹配范围值"><a href="#匹配范围值" class="header-anchor">#</a> 匹配范围值</h5> <blockquote><p>可以查找某一个范围的数据</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> staffs <span class="token keyword">where</span> name <span class="token operator">&gt;</span> <span class="token string">'Mary'</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="header-anchor">#</a> 精确匹配某一列并范围匹配另外一列</h5> <blockquote><p>可以查询第一列的全部和第二列的部分</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> staffs <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'July'</span> <span class="token operator">and</span> age <span class="token operator">&gt;</span> <span class="token number">25</span><span class="token punctuation">;</span>
</code></pre></div><h5 id="只访问索引的查询"><a href="#只访问索引的查询" class="header-anchor">#</a> 只访问索引的查询</h5> <blockquote><p>查询的时候只需要访问索引，不需要访问数据行，本质上就是覆盖索引</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>pos <span class="token keyword">from</span> staffs <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'July'</span> <span class="token operator">and</span> age <span class="token operator">=</span> <span class="token number">25</span> <span class="token operator">and</span> pos <span class="token operator">=</span> <span class="token string">'dev'</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="哈希索引"><a href="#哈希索引" class="header-anchor">#</a> 哈希索引</h3> <ol><li><p>基于哈希表的实现，只有精确匹配索引所有列的查询才有效</p></li> <li><p>在mysql中，只有memory的存储引擎显式支持哈希索引</p></li> <li><p>哈希索引自身只需存储对应的hash值，所以索引的结构十分紧凑，这让哈希索引查找的速度非常快</p></li> <li><p>哈希索引的限制</p> <ul><li>哈希索引只包含哈希值和行指针，而不存储字段值，索引不能使用索引中的值来避免读取行</li> <li>哈希索引数据并不是按照索引值顺序存储的，所以无法进行排序</li> <li>哈希索引不支持部分列匹配查找，哈希索引是使用索引列的全部内容来计算哈希值</li> <li>哈希索引支持等值比较查询，也不支持任何范围查询</li> <li>访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的行</li> <li>哈希冲突比较多的话，维护的代价也会很高</li></ul></li> <li><p>案例</p> <blockquote><p>当需要存储大量的URL，并且根据URL进行搜索查找，如果使用B+树，存储的内容就会很大
select id from url where url=&quot;&quot;
也可以利用将url使用CRC32做哈希，可以使用以下查询方式：
select id fom url where url=&quot;&quot; and url_crc=CRC32(&quot;&quot;)
此查询性能较高原因是使用体积很小的索引来完成查找</p></blockquote></li></ol> <h3 id="组合索引"><a href="#组合索引" class="header-anchor">#</a> 组合索引</h3> <blockquote><p>当包含多个列作为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要</p></blockquote> <h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="header-anchor">#</a> 聚簇索引与非聚簇索引</h3> <h4 id="聚簇索引"><a href="#聚簇索引" class="header-anchor">#</a> 聚簇索引</h4> <blockquote><p>不是单独的索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起</p></blockquote> <h5 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h5> <ol><li>可以把相关数据保存在一起</li> <li>数据访问更快，因为索引和数据保存在同一个树中</li> <li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li></ol> <h5 id="缺点"><a href="#缺点" class="header-anchor">#</a> 缺点</h5> <ol><li>聚簇数据最大限度地提高了IO密集型应用的性能，如果数据全部在内存，那么聚簇索引就没有什么优势</li> <li>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式</li> <li>更新聚簇索引列的代价很高，因为会强制将每个被更新的行移动到新的位置</li> <li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题</li> <li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候</li></ol> <h4 id="非聚簇索引"><a href="#非聚簇索引" class="header-anchor">#</a> 非聚簇索引</h4> <blockquote><p>数据文件跟索引文件分开存放</p></blockquote> <h3 id="覆盖索引-2"><a href="#覆盖索引-2" class="header-anchor">#</a> 覆盖索引</h3> <h4 id="基本介绍"><a href="#基本介绍" class="header-anchor">#</a> 基本介绍</h4> <ol><li>如果一个索引包含所有需要查询的字段的值，我们称之为覆盖索引</li> <li>不是所有类型的索引都可以称为覆盖索引，覆盖索引必须要存储索引列的值</li> <li>不同的存储实现覆盖索引的方式不同，不是所有的引擎都支持覆盖索引，memory不支持覆盖索引</li></ol> <h4 id="优势"><a href="#优势" class="header-anchor">#</a> 优势</h4> <ol><li>索引条目通常远小于数据行大小，如果只需要读取索引，那么mysql就会极大的较少数据访问量</li> <li>因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少的多</li> <li>一些存储引擎如MYISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用，这可能会导致严重的性能问题</li> <li>由于INNODB的聚簇索引，覆盖索引对INNODB表特别有用</li></ol> <h4 id="案例演示"><a href="#案例演示" class="header-anchor">#</a> 案例演示</h4> <ol><li><p>当发起一个被索引覆盖的查询时，在explain的extra列可以看到using index的信息，此时就使用了覆盖索引</p> <div class="language-sql extra-class"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> store_id<span class="token punctuation">,</span>film_id <span class="token keyword">from</span> inventory\G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: inventory
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: <span class="token keyword">index</span>
possible_keys: <span class="token boolean">NULL</span>
          <span class="token keyword">key</span>: idx_store_id_film_id
      key_len: <span class="token number">3</span>
          ref: <span class="token boolean">NULL</span>
         <span class="token keyword">rows</span>: <span class="token number">4581</span>
     filtered: <span class="token number">100.00</span>
        Extra: <span class="token keyword">Using</span> <span class="token keyword">index</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>

</code></pre></div></li> <li><p>在大多数存储引擎中，覆盖索引只能覆盖那些只访问索引中部分列的查询。不过，可以进一步的进行优化，可以使用innodb的二级索引来覆盖查询。</p> <blockquote><p>二级索引又称辅助索引、非聚集索引(no-clustered index)。b＋tree树结构。然而二级索引的叶子节点不保存记录中的所有列，其叶子节点保存的是&lt;健值，(记录)地址&gt;。好似聚集索引中非叶子节点保存的信息，不同的是二级索引保存的是记录地址，而聚集索引保存的是下一层节点地址。记录的地址一般可以保存两种形式。</p> <ol><li>记录的物理地址，页号：槽号：偏移量</li> <li>记录的主键值</li></ol></blockquote> <p>例如：actor使用innodb存储引擎，并在last_name字段又二级索引，虽然该索引的列不包括主键actor_id，但也能够用于对actor_id做覆盖查询</p> <div class="language-sql extra-class"><pre class="language-sql"><code>mysql<span class="token operator">&gt;</span> <span class="token keyword">explain</span> <span class="token keyword">select</span> actor_id<span class="token punctuation">,</span>last_name <span class="token keyword">from</span> actor <span class="token keyword">where</span> last_name<span class="token operator">=</span><span class="token string">'HOPPER'</span>\G
<span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token number">1.</span> <span class="token keyword">row</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
           id: <span class="token number">1</span>
  select_type: <span class="token keyword">SIMPLE</span>
        <span class="token keyword">table</span>: actor
   partitions: <span class="token boolean">NULL</span>
         <span class="token keyword">type</span>: ref
possible_keys: idx_actor_last_name
          <span class="token keyword">key</span>: idx_actor_last_name
      key_len: <span class="token number">137</span>
          ref: const
         <span class="token keyword">rows</span>: <span class="token number">2</span>
     filtered: <span class="token number">100.00</span>
        Extra: <span class="token keyword">Using</span> <span class="token keyword">index</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

</code></pre></div><blockquote><p><strong>innodb读操作：</strong></p> <p>通过二级索引查询记录仅能得到主键值，要查询完整的记录还需要再通过一次聚集索引查询,这种查询方式为书签查找（bookmark lookup）。</p> <p><strong>innodb写操作：</strong></p> <p>仅当主键发生改变时，才会更新二级索引。</p> <p>二级索引的非叶子节点存放的记录格式为&lt;键值，主键值，地址&gt;，二级索引的非叶子节点依然存在主键信息。二级索引节点的记录不保存隐藏列xid和roll ptr。聚集索引的非叶子节点保存的是下一层节点地址。
由于二级索引不包含记录的完整信息，在innodb存储引擎中二级索引的树高度比聚簇索引的树高度小，二级索引效率低。</p></blockquote></li></ol> <h3 id="优化小细节"><a href="#优化小细节" class="header-anchor">#</a> 优化小细节</h3> <h4 id="当使用索引列进行查询时尽量不要使用表达式"><a href="#当使用索引列进行查询时尽量不要使用表达式" class="header-anchor">#</a> 当使用索引列进行查询时尽量不要使用表达式</h4> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 把计算放到业务层而不是数据库层</span>
<span class="token comment">-- 正确</span>
<span class="token keyword">select</span> actor_id <span class="token keyword">from</span> actor <span class="token keyword">where</span> actor_id<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
<span class="token comment">-- 错误</span>
<span class="token keyword">select</span> actor_id <span class="token keyword">from</span> actor <span class="token keyword">where</span> actor_id<span class="token operator">+</span><span class="token number">1</span><span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="尽量使用主键查询，而不是其他索引"><a href="#尽量使用主键查询，而不是其他索引" class="header-anchor">#</a> 尽量使用主键查询，而不是其他索引</h4> <blockquote><p>因为主键查询不会触发回表查询</p></blockquote> <h4 id="使用前缀索引"><a href="#使用前缀索引" class="header-anchor">#</a> 使用前缀索引</h4> <blockquote><p>​		有时候需要索引很长的字符串，这会让索引变的大且慢，通常情况下可以使用某个列开始的部分字符串，这样大大的节约索引空间，从而提高索引效率，但这会降低索引的选择性，索引的选择性是指不重复的索引值和数据表记录总数的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性更高的索引可以让mysql在查找的时候过滤掉更多的行。</p> <p>​		一般情况下某个列前缀的选择性也是足够高的，足以满足查询的性能，但是对应BLOB,TEXT,VARCHAR类型的列，必须要使用前缀索引，因为mysql不允许索引这些列的完整长度，使用该方法的诀窍在于要选择足够长的前缀以保证较高的选择性，通过又不能太长。</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--创建数据表</span>
<span class="token keyword">create</span> <span class="token keyword">table</span> citydemo<span class="token punctuation">(</span>city <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> citydemo<span class="token punctuation">(</span>city<span class="token punctuation">)</span> <span class="token keyword">select</span> city <span class="token keyword">from</span> city<span class="token punctuation">;</span>

<span class="token comment">--重复执行5次下面的sql语句</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> citydemo<span class="token punctuation">(</span>city<span class="token punctuation">)</span> <span class="token keyword">select</span> city <span class="token keyword">from</span> citydemo<span class="token punctuation">;</span>

<span class="token comment">--更新城市表的名称</span>
<span class="token keyword">update</span> citydemo <span class="token keyword">set</span> city<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">select</span> city <span class="token keyword">from</span> city <span class="token keyword">order</span> <span class="token keyword">by</span> rand<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">limit</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">--查找最常见的城市列表，发现每个值都出现45-65次，</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> cnt<span class="token punctuation">,</span>city <span class="token keyword">from</span> citydemo <span class="token keyword">group</span> <span class="token keyword">by</span> city <span class="token keyword">order</span> <span class="token keyword">by</span> cnt <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token comment">--查找最频繁出现的城市前缀，先从3个前缀字母开始，发现比原来出现的次数更多，可以分别截取多个字符查看城市出现的次数</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> cnt<span class="token punctuation">,</span><span class="token keyword">left</span><span class="token punctuation">(</span>city<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">as</span> pref <span class="token keyword">from</span> citydemo <span class="token keyword">group</span> <span class="token keyword">by</span> pref <span class="token keyword">order</span> <span class="token keyword">by</span> cnt <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> cnt<span class="token punctuation">,</span><span class="token keyword">left</span><span class="token punctuation">(</span>city<span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token keyword">as</span> pref <span class="token keyword">from</span> citydemo <span class="token keyword">group</span> <span class="token keyword">by</span> pref <span class="token keyword">order</span> <span class="token keyword">by</span> cnt <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token comment">--此时前缀的选择性接近于完整列的选择性</span>

<span class="token comment">--还可以通过另外一种方式来计算完整列的选择性，可以看到当前缀长度到达7之后，再增加前缀长度，选择性提升的幅度已经很小了</span>
<span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>city<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sel3<span class="token punctuation">,</span>
<span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>city<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sel4<span class="token punctuation">,</span>
<span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>city<span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sel5<span class="token punctuation">,</span>
<span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>city<span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sel6<span class="token punctuation">,</span>
<span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>city<span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sel7<span class="token punctuation">,</span>
<span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">distinct</span> <span class="token keyword">left</span><span class="token punctuation">(</span>city<span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> sel8 
<span class="token keyword">from</span> citydemo<span class="token punctuation">;</span>

<span class="token comment">--计算完成之后可以创建前缀索引</span>
<span class="token keyword">alter</span> <span class="token keyword">table</span> citydemo <span class="token keyword">add</span> <span class="token keyword">key</span><span class="token punctuation">(</span>city<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">--注意：前缀索引是一种能使索引更小更快的有效方法，但是也包含缺点：mysql无法使用前缀索引做order by 和 group by。 </span>
</code></pre></div><h4 id="使用索引扫描来排序"><a href="#使用索引扫描来排序" class="header-anchor">#</a> 使用索引扫描来排序</h4> <h4 id="推荐使用in"><a href="#推荐使用in" class="header-anchor">#</a> 推荐使用in</h4> <blockquote><p>union all,in,or都能够使用索引，但是推荐使用in</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> actor <span class="token keyword">where</span> actor_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">union</span> <span class="token keyword">all</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> actor <span class="token keyword">where</span> actor_id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> actor <span class="token keyword">where</span> actor_id <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> actor <span class="token keyword">where</span> actor_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">or</span> actor_id <span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="范围列可以用到索引"><a href="#范围列可以用到索引" class="header-anchor">#</a> 范围列可以用到索引</h4> <ol><li>范围条件是：&lt;、&lt;=、&gt;、&gt;=、between</li> <li>范围列可以用到索引，但是范围列后面的列无法用到索引，索引最多用于一个范围列</li></ol> <h4 id="强制类型转换会全表扫描"><a href="#强制类型转换会全表扫描" class="header-anchor">#</a> 强制类型转换会全表扫描</h4> <blockquote><div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token keyword">user</span><span class="token punctuation">(</span>id <span class="token keyword">int</span><span class="token punctuation">,</span>name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>phone <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token keyword">user</span> <span class="token keyword">add</span> <span class="token keyword">index</span> idx_1<span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 不会触发索引</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> phone<span class="token operator">=</span><span class="token number">13800001234</span><span class="token punctuation">;</span>
<span class="token comment">-- 触发索引</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> phone<span class="token operator">=</span><span class="token string">'13800001234'</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="更新频繁，数据区分度不高的字段不宜建立索引"><a href="#更新频繁，数据区分度不高的字段不宜建立索引" class="header-anchor">#</a> 更新频繁，数据区分度不高的字段不宜建立索引</h4> <ol><li>更新会变更B+树，更新频繁的字段建议索引会大大降低数据库性能</li> <li>类似于性别这类区分不大的属性，建立索引是没有意义的，不能有效的过滤数据，</li> <li>一般区分度在80%以上的时候就可以建立索引，区分度可以使用 count(distinct(列名))/count(*) 来计算</li> <li>索引页分裂、索引页合并</li></ol> <h4 id="创建索引的列，不允许为null"><a href="#创建索引的列，不允许为null" class="header-anchor">#</a> 创建索引的列，不允许为null</h4> <blockquote><p>创建索引的列，不允许为null，可能会得到不符合预期的结果</p></blockquote> <h4 id="表连接最好不要超过三张表"><a href="#表连接最好不要超过三张表" class="header-anchor">#</a> 表连接最好不要超过三张表</h4> <blockquote><p>当需要进行表连接的时候，最好不要超过三张表，因为需要join的字段，数据类型必须一致</p></blockquote> <h4 id="能使用limit的时候尽量使用limit"><a href="#能使用limit的时候尽量使用limit" class="header-anchor">#</a> 能使用limit的时候尽量使用limit</h4> <h4 id="单表索引建议控制在5个以内"><a href="#单表索引建议控制在5个以内" class="header-anchor">#</a> 单表索引建议控制在5个以内</h4> <h4 id="单索引字段数不允许超过5个（组合索引）"><a href="#单索引字段数不允许超过5个（组合索引）" class="header-anchor">#</a> 单索引字段数不允许超过5个（组合索引）</h4> <h4 id="创建索引的时候应该避免以下错误概念"><a href="#创建索引的时候应该避免以下错误概念" class="header-anchor">#</a> 创建索引的时候应该避免以下错误概念</h4> <ol><li>索引越多越好</li> <li>过早优化，在不了解系统的情况下进行优化</li></ol> <h3 id="索引监控"><a href="#索引监控" class="header-anchor">#</a> 索引监控</h3> <p><strong>show status like 'Handler_read%';</strong></p> <p><img src="/images/%E7%B4%A2%E5%BC%95%E7%9B%91%E6%8E%A7.png" alt="索引监控"></p> <p>参数解释</p> <ol><li>Handler_read_first：读取索引第一个条目的次数</li> <li>Handler_read_key：通过index获取数据的次数</li> <li>Handler_read_last：读取索引最后一个条目的次数</li> <li>Handler_read_next：通过索引读取下一条数据的次数</li> <li>Handler_read_prev：通过索引读取上一条数据的次数</li> <li>Handler_read_rnd：从固定位置读取数据的次数</li> <li>Handler_read_rnd_next：从数据节点读取下一条数据的次数</li></ol> <h3 id="简单案例"><a href="#简单案例" class="header-anchor">#</a> 简单案例</h3> <h4 id="预先准备好数据"><a href="#预先准备好数据" class="header-anchor">#</a> 预先准备好数据</h4> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SET</span> FOREIGN_KEY_CHECKS<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>itdragon_order_list<span class="token punctuation">`</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>itdragon_order_list<span class="token punctuation">`</span> <span class="token punctuation">(</span>
  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span> <span class="token keyword">COMMENT</span> <span class="token string">'主键id，默认自增长'</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>transaction_id<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">150</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'交易号'</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>gross<span class="token punctuation">`</span> <span class="token keyword">double</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'毛收入(RMB)'</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>net<span class="token punctuation">`</span> <span class="token keyword">double</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'净收入(RMB)'</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>stock_id<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'发货仓库'</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>order_status<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'订单状态'</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>descript<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'客服备注'</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>finance_descript<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'财务备注'</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>create_type<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'创建类型'</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>order_level<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'订单级别'</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>input_user<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'录入人'</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>input_date<span class="token punctuation">`</span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'录入时间'</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">10003</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>

<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> itdragon_order_list <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'10000'</span><span class="token punctuation">,</span> <span class="token string">'81X97310V32236260E'</span><span class="token punctuation">,</span> <span class="token string">'6.6'</span><span class="token punctuation">,</span> <span class="token string">'6.13'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">,</span> <span class="token string">'ok'</span><span class="token punctuation">,</span> <span class="token string">'ok'</span><span class="token punctuation">,</span> <span class="token string">'auto'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'itdragon'</span><span class="token punctuation">,</span> <span class="token string">'2017-08-28 17:01:49'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> itdragon_order_list <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'10001'</span><span class="token punctuation">,</span> <span class="token string">'61525478BB371361Q'</span><span class="token punctuation">,</span> <span class="token string">'18.88'</span><span class="token punctuation">,</span> <span class="token string">'18.79'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">,</span> <span class="token string">'ok'</span><span class="token punctuation">,</span> <span class="token string">'ok'</span><span class="token punctuation">,</span> <span class="token string">'auto'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'itdragon'</span><span class="token punctuation">,</span> <span class="token string">'2017-08-18 17:01:50'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> itdragon_order_list <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'10002'</span><span class="token punctuation">,</span> <span class="token string">'5RT64180WE555861V'</span><span class="token punctuation">,</span> <span class="token string">'20.18'</span><span class="token punctuation">,</span> <span class="token string">'20.17'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">,</span> <span class="token string">'ok'</span><span class="token punctuation">,</span> <span class="token string">'ok'</span><span class="token punctuation">,</span> <span class="token string">'auto'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'itdragon'</span><span class="token punctuation">,</span> <span class="token string">'2017-09-08 17:01:49'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h4 id="第一个案例："><a href="#第一个案例：" class="header-anchor">#</a> 第一个案例：</h4> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> itdragon_order_list <span class="token keyword">where</span> transaction_id <span class="token operator">=</span> <span class="token string">&quot;81X97310V32236260E&quot;</span><span class="token punctuation">;</span>
<span class="token comment">--通过查看执行计划发现type=all,需要进行全表扫描</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> itdragon_order_list <span class="token keyword">where</span> transaction_id <span class="token operator">=</span> <span class="token string">&quot;81X97310V32236260E&quot;</span><span class="token punctuation">;</span>

<span class="token comment">--优化一、为transaction_id创建唯一索引</span>
 <span class="token keyword">create</span> <span class="token keyword">unique</span> <span class="token keyword">index</span> idx_order_transaID <span class="token keyword">on</span> itdragon_order_list <span class="token punctuation">(</span>transaction_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">--当创建索引之后，唯一索引对应的type是const，通过索引一次就可以找到结果，普通索引对应的type是ref，表示非唯一性索引赛秒，找到值还要进行扫描，直到将索引文件扫描完为止，显而易见，const的性能要高于ref</span>
 <span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> itdragon_order_list <span class="token keyword">where</span> transaction_id <span class="token operator">=</span> <span class="token string">&quot;81X97310V32236260E&quot;</span><span class="token punctuation">;</span>
 
 <span class="token comment">--优化二、使用覆盖索引，查询的结果变成 transaction_id,当extra出现using index,表示使用了覆盖索引</span>
 <span class="token keyword">explain</span> <span class="token keyword">select</span> transaction_id <span class="token keyword">from</span> itdragon_order_list <span class="token keyword">where</span> transaction_id <span class="token operator">=</span> <span class="token string">&quot;81X97310V32236260E&quot;</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="第二个案例："><a href="#第二个案例：" class="header-anchor">#</a> 第二个案例：</h4> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">--创建复合索引</span>
<span class="token keyword">create</span> <span class="token keyword">index</span> idx_order_levelDate <span class="token keyword">on</span> itdragon_order_list <span class="token punctuation">(</span>order_level<span class="token punctuation">,</span>input_date<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">--创建索引之后发现跟没有创建索引一样，都是全表扫描，都是文件排序</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> itdragon_order_list <span class="token keyword">order</span> <span class="token keyword">by</span> order_level<span class="token punctuation">,</span>input_date<span class="token punctuation">;</span>

<span class="token comment">--可以使用force index强制指定索引</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> itdragon_order_list <span class="token keyword">force</span> <span class="token keyword">index</span><span class="token punctuation">(</span>idx_order_levelDate<span class="token punctuation">)</span> <span class="token keyword">order</span> <span class="token keyword">by</span> order_level<span class="token punctuation">,</span>input_date<span class="token punctuation">;</span>
<span class="token comment">--其实给订单排序意义不大，给订单级别添加索引意义也不大，因此可以先确定order_level的值，然后再给input_date排序</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> itdragon_order_list <span class="token keyword">where</span> order_level<span class="token operator">=</span><span class="token number">3</span> <span class="token keyword">order</span> <span class="token keyword">by</span> input_date<span class="token punctuation">;</span>
</code></pre></div><h2 id="查询优化"><a href="#查询优化" class="header-anchor">#</a> 查询优化</h2> <h3 id="查询慢的原因"><a href="#查询慢的原因" class="header-anchor">#</a> 查询慢的原因</h3> <ol><li>网络</li> <li>CPU</li> <li>IO</li> <li>内存不足</li> <li>上下文切换</li> <li>系统调用</li> <li>生成统计信息</li> <li>锁等待时间</li></ol> <h3 id="优化数据访问"><a href="#优化数据访问" class="header-anchor">#</a> 优化数据访问</h3> <h4 id="访问的数据太多"><a href="#访问的数据太多" class="header-anchor">#</a> 访问的数据太多</h4> <blockquote><p>查询性能低下的主要原因是访问的数据太多，某些查询不可避免的需要筛选大量的数据，我们可以通过减少访问数据量的方式进行优化</p></blockquote> <ol><li>确认应用程序是否在检索大量超过需要的数据</li> <li>确认mysql服务器层是否在分析大量超过需要的数据行</li></ol> <h4 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="header-anchor">#</a> 是否向数据库请求了不需要的数据</h4> <h5 id="查询不需要的记录"><a href="#查询不需要的记录" class="header-anchor">#</a> 查询不需要的记录</h5> <blockquote><p>我们常常会误以为mysql会只返回需要的数据，实际上mysql却是先返回全部结果再进行计算，在日常的开发习惯中，经常是先用select语句查询大量的结果，然后获取前面的N行后关闭结果集。</p> <p>优化方式是在查询后面添加limit</p></blockquote> <h5 id="多表关联时返回全部列"><a href="#多表关联时返回全部列" class="header-anchor">#</a> 多表关联时返回全部列</h5> <blockquote><p>select * from actor inner join film_actor using(actor_id) inner join film using(film_id) where film.title='Academy Dinosaur';</p> <p>select actor.* from actor...;</p></blockquote> <h5 id="总是取出全部列"><a href="#总是取出全部列" class="header-anchor">#</a> 总是取出全部列</h5> <blockquote><p>在公司的企业需求中，禁止使用select *,虽然这种方式能够简化开发，但是会影响查询的性能，所以尽量不要使用</p></blockquote> <h5 id="重复查询相同的数据"><a href="#重复查询相同的数据" class="header-anchor">#</a> 重复查询相同的数据</h5> <blockquote><p>如果需要不断的重复执行相同的查询，且每次返回完全相同的数据，因此，基于这样的应用场景，我们可以将这部分数据缓存起来，这样的话能够提高查询效率</p></blockquote> <h3 id="执行过程的优化"><a href="#执行过程的优化" class="header-anchor">#</a> 执行过程的优化</h3> <h4 id="查询缓存"><a href="#查询缓存" class="header-anchor">#</a> 查询缓存</h4> <blockquote><p>在解析一个查询语句之前，如果查询缓存是打开的，那么mysql会优先检查这个查询是否命中查询缓存中的数据，如果查询恰好命中了查询缓存，那么会在返回结果之前会检查用户权限，如果权限没有问题，那么mysql会跳过所有的阶段，就直接从缓存中拿到结果并返回给客户端</p></blockquote> <h4 id="查询优化处理"><a href="#查询优化处理" class="header-anchor">#</a> 查询优化处理</h4> <blockquote><p>mysql查询完缓存之后会经过以下几个步骤：解析SQL、预处理、优化SQL执行计划，这几个步骤出现任何的错误，都可能会终止查询</p></blockquote> <h5 id="语法解析器和预处理"><a href="#语法解析器和预处理" class="header-anchor">#</a> 语法解析器和预处理</h5> <blockquote><p>mysql通过关键字将SQL语句进行解析，并生成一颗解析树，mysql解析器将使用mysql语法规则验证和解析查询，例如验证使用使用了错误的关键字或者顺序是否正确等等，预处理器会进一步检查解析树是否合法，例如表名和列名是否存在，是否有歧义，还会验证权限等等</p></blockquote> <h5 id="查询优化器"><a href="#查询优化器" class="header-anchor">#</a> 查询优化器</h5> <blockquote><p>当语法树没有问题之后，相应的要由优化器将其转成执行计划，一条查询语句可以使用非常多的执行方式，最后都可以得到对应的结果，但是不同的执行方式带来的效率是不同的，优化器的最主要目的就是要选择最有效的执行计划</p> <p>mysql使用的是基于成本的优化器，在优化的时候会尝试预测一个查询使用某种查询计划时候的成本，并选择其中成本最小的一个</p></blockquote> <h6 id="查询sql分析"><a href="#查询sql分析" class="header-anchor">#</a> 查询sql分析</h6> <blockquote><div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> film_actor<span class="token punctuation">;</span>
<span class="token keyword">show</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'last_query_cost'</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到这条查询语句大概需要做1104个数据页才能找到对应的数据，这是经过一系列的统计信息计算来的</p></blockquote> <ol><li>每个表或者索引的页面个数</li> <li>索引的基数</li> <li>索引和数据行的长度</li> <li>索引的分布情况</li></ol> <h6 id="mysql可能会选择错误的执行计划"><a href="#mysql可能会选择错误的执行计划" class="header-anchor">#</a> mysql可能会选择错误的执行计划</h6> <blockquote><p>在很多情况下mysql会选择错误的执行计划，原因如下：</p></blockquote> <ol><li>统计信息不准确：InnoDB因为其mvcc的架构，并不能维护一个数据表的行数的精确统计信息</li> <li>执行计划的成本估算不等同于实际执行的成本：有时候某个执行计划虽然需要读取更多的页面，但是他的成本却更小，因为如果这些页面都是顺序读或者这些页面都已经在内存中的话，那么它的访问成本将很小，mysql层面并不知道哪些页面在内存中，哪些在磁盘，所以查询之际执行过程中到底需要多少次IO是无法得知的</li> <li>mysql的最优可能跟你想的不一样：mysql的优化是基于成本模型的优化，但是有可能不是最快的优化</li> <li>mysql不考虑其他并发执行的查询</li> <li>mysql不会考虑不受其控制的操作成本：执行存储过程或者用户自定义函数的成本</li></ol> <h6 id="优化器的优化策略"><a href="#优化器的优化策略" class="header-anchor">#</a> 优化器的优化策略</h6> <ol><li>静态优化：直接对解析树进行分析，并完成优化</li> <li>动态优化：动态优化与查询的上下文有关，也可能跟取值、索引对应的行数有关</li> <li>mysql对查询的静态优化只需要一次，但对动态优化在每次执行时都需要重新评估</li></ol> <h6 id="优化器的优化类型"><a href="#优化器的优化类型" class="header-anchor">#</a> 优化器的优化类型</h6> <ol><li><p>重新定义关联表的顺序：数据表的关联并不总是按照在查询中指定的顺序进行，决定关联顺序时优化器很重要的功能</p></li> <li><p>将外连接转化成内连接，内连接的效率要高于外连接</p></li> <li><p>使用等价变换规则，mysql可以使用一些等价变化来简化并规划表达式</p></li> <li><p>优化count(),min(),max()：索引和列是否可以为空通常可以帮助mysql优化这类表达式：例如，要找到某一列的最小值，只需要查询索引的最左端的记录即可，不需要全文扫描比较</p></li> <li><p>预估并转化为常数表达式，当mysql检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行处理</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">explain</span> <span class="token keyword">select</span> film<span class="token punctuation">.</span>film_id<span class="token punctuation">,</span>film_actor<span class="token punctuation">.</span>actor_id <span class="token keyword">from</span> film <span class="token keyword">inner</span> <span class="token keyword">join</span> film_actor <span class="token keyword">using</span><span class="token punctuation">(</span>film_id<span class="token punctuation">)</span> <span class="token keyword">where</span> film<span class="token punctuation">.</span>film_id <span class="token operator">=</span> <span class="token number">1</span>
</code></pre></div></li> <li><p>索引覆盖扫描，当索引中的列包含所有查询中需要使用的列的时候，可以使用覆盖索引</p></li> <li><p>子查询优化：mysql在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据进行访问，例如将经常查询的数据放入到缓存中</p></li> <li><p>等值传播</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 如果两个列的值通过等式关联，那么mysql能够把其中一个列的where条件传递到另一个上：</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> film<span class="token punctuation">.</span>film_id <span class="token keyword">from</span> film <span class="token keyword">inner</span> <span class="token keyword">join</span> film_actor <span class="token keyword">using</span><span class="token punctuation">(</span>film_id
<span class="token punctuation">)</span> <span class="token keyword">where</span> film<span class="token punctuation">.</span>film_id <span class="token operator">&gt;</span> <span class="token number">500</span><span class="token punctuation">;</span>
<span class="token comment">-- 这里使用film_id字段进行等值关联，film_id这个列不仅适用于film表而且适用于film_actor表</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> film<span class="token punctuation">.</span>film_id <span class="token keyword">from</span> film <span class="token keyword">inner</span> <span class="token keyword">join</span> film_actor <span class="token keyword">using</span><span class="token punctuation">(</span>film_id
<span class="token punctuation">)</span> <span class="token keyword">where</span> film<span class="token punctuation">.</span>film_id <span class="token operator">&gt;</span> <span class="token number">500</span> <span class="token operator">and</span> film_actor<span class="token punctuation">.</span>film_id <span class="token operator">&gt;</span> <span class="token number">500</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <h6 id="关联查询"><a href="#关联查询" class="header-anchor">#</a> 关联查询</h6> <ol><li><p>join的实现方式原理</p> <ul><li><p>Simple Nested-Loop Join</p></li> <li><p>Index Nested-Loop Join</p></li> <li><p>Block Nested-Loop Join</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- （1）Join Buffer会缓存所有参与查询的列而不是只有Join的列。</span>
<span class="token comment">-- （2）可以通过调整join_buffer_size缓存大小</span>
<span class="token comment">-- （3）join_buffer_size的默认值是256K，join_buffer_size的最大值在MySQL 5.1.22版本前是4G-1，而之后的版本才能在64位操作系统下申请大于4G的Join Buffer空间。</span>
<span class="token comment">-- （4）使用Block Nested-Loop Join算法需要开启优化器管理配置的optimizer_switch的设置block_nested_loop为on，默认为开启。</span>

<span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'%optimizer_switch%'</span>
</code></pre></div></li></ul></li> <li><p>案例演示</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 查看不同的顺序执行方式对查询性能的影响：</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> film<span class="token punctuation">.</span>film_id<span class="token punctuation">,</span>film<span class="token punctuation">.</span>title<span class="token punctuation">,</span>film<span class="token punctuation">.</span>release_year<span class="token punctuation">,</span>actor<span class="token punctuation">.</span>actor_id<span class="token punctuation">,</span>actor<span class="token punctuation">.</span>first_name<span class="token punctuation">,</span>actor<span class="token punctuation">.</span>last_name <span class="token keyword">from</span> film <span class="token keyword">inner</span> <span class="token keyword">join</span> f
ilm_actor <span class="token keyword">using</span><span class="token punctuation">(</span>film_id<span class="token punctuation">)</span> <span class="token keyword">inner</span> <span class="token keyword">join</span> actor <span class="token keyword">using</span><span class="token punctuation">(</span>actor_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 查看执行的成本：</span>
<span class="token keyword">show</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'last_query_cost'</span><span class="token punctuation">;</span> 
<span class="token comment">-- 按照自己预想的规定顺序执行：</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> straight_join film<span class="token punctuation">.</span>film_id<span class="token punctuation">,</span>film<span class="token punctuation">.</span>title<span class="token punctuation">,</span>film<span class="token punctuation">.</span>release_year<span class="token punctuation">,</span>actor<span class="token punctuation">.</span>actor_id<span class="token punctuation">,</span>actor<span class="token punctuation">.</span>first_name<span class="token punctuation">,</span>actor<span class="token punctuation">.</span>last_name <span class="token keyword">from</span> fil
m <span class="token keyword">inner</span> <span class="token keyword">join</span> film_actor <span class="token keyword">using</span><span class="token punctuation">(</span>film_id<span class="token punctuation">)</span> <span class="token keyword">inner</span> <span class="token keyword">join</span> actor <span class="token keyword">using</span><span class="token punctuation">(</span>actor_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">-- 查看执行的成本：</span>
<span class="token keyword">show</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'last_query_cost'</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <h6 id="排序算法优化"><a href="#排序算法优化" class="header-anchor">#</a> 排序算法优化</h6> <ol><li><p>两次传输排序：</p> <div class="language- extra-class"><pre class="language-text"><code>第一次数据读取是将需要排序的字段读取出来，然后进行排序，第二次是将排好序的结果按照需要去读取数据行。
这种方式效率比较低，原因是第二次读取数据的时候因为已经排好序，需要去读取所有记录而此时更多的是随机IO，读取数据成本会比较高
两次传输的优势，在排序的时候存储尽可能少的数据，让排序缓冲区可以尽可能多的容纳行数来进行排序操作
</code></pre></div></li> <li><p>单次传输排序</p> <div class="language- extra-class"><pre class="language-text"><code>先读取查询所需要的所有列，然后再根据给定列进行排序，最后直接返回排序结果，此方式只需要一次顺序IO读取所有的数据，而无须任何的随机IO，问题在于查询的列特别多的时候，会占用大量的存储空间，无法存储大量的数据
</code></pre></div></li> <li><p>当需要排序的列的总大小加上orderby的列大小超过max_length_for_sort_data定义的字节，mysql会选择双次排序，反之使用单次排序，当然，用户可以设置此参数的值来选择排序的方式</p></li></ol> <h3 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="header-anchor">#</a> 优化特定类型的查询</h3> <h4 id="优化count-查询"><a href="#优化count-查询" class="header-anchor">#</a> 优化count()查询</h4> <ol><li>总有人认为myisam的count函数比较快，这是有前提条件的，只有没有任何where条件的count(*)才是比较快的</li> <li>使用近似值：在某些应用场景中，不需要完全精确的值，可以参考使用近似值来代替，比如可以使用explain来获取近似的值。其实在很多OLAP的应用中，需要计算某一个列值的基数，有一个计算近似值的算法叫hyperloglog。</li> <li>更复杂的优化：一般情况下，count()需要扫描大量的行才能获取精确的数据，其实很难优化，在实际操作的时候可以考虑使用索引覆盖扫描，或者增加汇总表，或者增加外部缓存系统。</li></ol> <h4 id="优化关联查询"><a href="#优化关联查询" class="header-anchor">#</a> 优化关联查询</h4> <ol><li>确保on或者using子句中的列上有索引，在创建索引的时候就要考虑到关联的顺序</li> <li>确保任何的groupby和order by中的表达式只涉及到一个表中的列，这样mysql才有可能使用索引来优化这个过程</li></ol> <h4 id="优化子查询"><a href="#优化子查询" class="header-anchor">#</a> 优化子查询</h4> <blockquote><p>子查询的优化最重要的优化建议是尽可能使用关联查询代替</p></blockquote> <h4 id="优化limit分页"><a href="#优化limit分页" class="header-anchor">#</a> 优化limit分页</h4> <blockquote><p>优化此类查询的最简单的办法就是尽可能地使用覆盖索引，而不是查询所有的列</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token comment">-- 优化前</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> film_id<span class="token punctuation">,</span>description <span class="token keyword">from</span> film <span class="token keyword">order</span> <span class="token keyword">by</span> title <span class="token keyword">limit</span> <span class="token number">50</span><span class="token punctuation">,</span><span class="token number">5</span>
<span class="token comment">-- 优化后</span>
<span class="token keyword">explain</span> <span class="token keyword">select</span> film<span class="token punctuation">.</span>film_id<span class="token punctuation">,</span>film<span class="token punctuation">.</span>description <span class="token keyword">from</span> film <span class="token keyword">inner</span> <span class="token keyword">join</span> <span class="token punctuation">(</span><span class="token keyword">select</span> film_id <span class="token keyword">from</span> film <span class="token keyword">order</span> <span class="token keyword">by</span> title <span class="token keyword">limit</span> <span class="token number">50</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">as</span> lim <span class="token keyword">using</span><span class="token punctuation">(</span>film_id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="优化union查询"><a href="#优化union查询" class="header-anchor">#</a> 优化union查询</h4> <blockquote><p>除非确实需要服务器消除重复的行，否则一定要使用union all，因此没有all关键字，mysql会在查询的时候给临时表加上distinct的关键字，这个操作的代价很高</p></blockquote> <h4 id="推荐使用用户自定义变量"><a href="#推荐使用用户自定义变量" class="header-anchor">#</a> 推荐使用用户自定义变量</h4> <h5 id="自定义变量的使用"><a href="#自定义变量的使用" class="header-anchor">#</a> 自定义变量的使用</h5> <ol><li>set @one :=1</li> <li>set @min_actor :=(select min(actor_id) from actor)</li> <li>set @last_week :=current_date-interval 1 week;</li></ol> <h5 id="自定义变量的限制"><a href="#自定义变量的限制" class="header-anchor">#</a> 自定义变量的限制</h5> <ol><li>无法使用查询缓存</li> <li>不能在使用常量或者标识符的地方使用自定义变量，例如表名、列名或者limit子句</li> <li>用户自定义变量的生命周期是在一个连接中有效，所以不能用它们来做连接间的通信</li> <li>不能显式地声明自定义变量地类型</li> <li>mysql优化器在某些场景下可能会将这些变量优化掉，这可能导致代码不按预想地方式运行</li> <li>赋值符号：=的优先级非常低，所以在使用赋值表达式的时候应该明确的使用括号</li> <li>使用未定义变量不会产生任何语法错误</li></ol> <h5 id="自定义变量的使用案例"><a href="#自定义变量的使用案例" class="header-anchor">#</a> 自定义变量的使用案例</h5> <ol><li><p>优化排名语句</p> <ul><li><p>在给一个变量赋值的同时使用这个变量</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> actor_id<span class="token punctuation">,</span><span class="token variable">@rownum</span>:<span class="token operator">=</span><span class="token variable">@rownum</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">as</span> rownum <span class="token keyword">from</span> actor <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>查询获取演过最多电影的前10名演员，然后根据出演电影次数做一个排名</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">select</span> actor_id<span class="token punctuation">,</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">as</span> cnt <span class="token keyword">from</span> film_actor <span class="token keyword">group</span> <span class="token keyword">by</span> actor_id <span class="token keyword">order</span> <span class="token keyword">by</span> cnt <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div></li></ul></li> <li><p>避免重新查询刚刚更新的数据：当需要高效的更新一条记录的时间戳，同时希望查询当前记录中存放的时间戳是什么</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">update</span> t1 <span class="token keyword">set</span> lastUpdated<span class="token operator">=</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> lastUpdated <span class="token keyword">from</span> t1 <span class="token keyword">where</span> id <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">update</span> t1 <span class="token keyword">set</span> lastupdated <span class="token operator">=</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token variable">@now</span>:<span class="token operator">=</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token variable">@now</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>确定取值的顺序：在赋值和读取变量的时候可能是在查询的不同阶段</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">set</span> <span class="token variable">@rownum</span>:<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> actor_id<span class="token punctuation">,</span><span class="token variable">@rownum</span>:<span class="token operator">=</span><span class="token variable">@rownum</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">as</span> cnt <span class="token keyword">from</span> actor <span class="token keyword">where</span> <span class="token variable">@rownum</span><span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">-- 因为where和select在查询的不同阶段执行，所以看到查询到两条记录，这不符合预期</span>

<span class="token keyword">set</span> <span class="token variable">@rownum</span>:<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> actor_id<span class="token punctuation">,</span><span class="token variable">@rownum</span>:<span class="token operator">=</span><span class="token variable">@rownum</span><span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">as</span> cnt <span class="token keyword">from</span> actor <span class="token keyword">where</span> <span class="token variable">@rownum</span><span class="token operator">&lt;=</span><span class="token number">1</span> <span class="token keyword">order</span> <span class="token keyword">by</span> first_name
<span class="token comment">-- 当引入了orde;r by之后，发现打印出了全部结果，这是因为order by引入了文件排序，而where条件是在文件排序操作之前取值的</span>

<span class="token comment">-- 解决这个问题的关键在于让变量的赋值和取值发生在执行查询的同一阶段：</span>
<span class="token keyword">set</span> <span class="token variable">@rownum</span>:<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> actor_id<span class="token punctuation">,</span><span class="token variable">@rownum</span> <span class="token keyword">as</span> cnt <span class="token keyword">from</span> actor <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token variable">@rownum</span>:<span class="token operator">=</span><span class="token variable">@rownum</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre></div></li></ol> <h2 id="分区表"><a href="#分区表" class="header-anchor">#</a> 分区表</h2> <h3 id="分区表的应用场景"><a href="#分区表的应用场景" class="header-anchor">#</a> 分区表的应用场景</h3> <ol><li>表非常大以至于无法全部都放在内存中，或者只在表的最后部分有热点数据，其他均是历史数据</li> <li>分区表的数据更容易维护
<ul><li>批量删除大量数据可以使用清除整个分区的方式</li> <li>对一个独立分区进行优化、检查、修复等操作</li></ul></li> <li>分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备</li> <li>可以使用分区表来避免某些特殊的瓶颈
<ul><li>innodb的单个索引的互斥访问</li> <li>ext3文件系统的inode锁竞争</li></ul></li> <li>可以备份和恢复独立的分区</li></ol> <h3 id="分区表的限制"><a href="#分区表的限制" class="header-anchor">#</a> 分区表的限制</h3> <ol><li>一个表最多只能有1024个分区，在5.7版本的时候可以支持8196个分区</li> <li>在早期的mysql中，分区表达式必须是整数或者是返回整数的表达式，在mysql5.5中，某些场景可以直接使用列来进行分区</li> <li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li> <li>分区表无法使用外键约束</li></ol> <h3 id="分区表的原理"><a href="#分区表的原理" class="header-anchor">#</a> 分区表的原理</h3> <blockquote><p>分区表由多个相关的底层表实现，这个底层表也是由句柄对象标识，我们可以直接访问各个分区。存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），分区表的索引知识在各个底层表上各自加上一个完全相同的索引。从存储引擎的角度来看，底层表和普通表没有任何不同，存储引擎也无须知道这是一个普通表还是一个分区表的一部分。</p></blockquote> <p><strong>分区表的操作按照以下的操作逻辑进行：</strong></p> <h4 id="select查询"><a href="#select查询" class="header-anchor">#</a> select查询</h4> <blockquote><p>当查询一个分区表的时候，分区层先打开并锁住所有的底层表，优化器先判断是否可以过滤部分分区，然后再调用对应的存储引擎接口访问各个分区的数据</p></blockquote> <h4 id="insert操作"><a href="#insert操作" class="header-anchor">#</a> insert操作</h4> <blockquote><p>当写入一条记录的时候，分区层先打开并锁住所有的底层表，然后确定哪个分区接受这条记录，再将记录写入对应底层表</p></blockquote> <h4 id="delete操作"><a href="#delete操作" class="header-anchor">#</a> delete操作</h4> <blockquote><p>当删除一条记录时，分区层先打开并锁住所有的底层表，然后确定数据对应的分区，最后对相应底层表进行删除操作</p></blockquote> <h4 id="update操作"><a href="#update操作" class="header-anchor">#</a> update操作</h4> <blockquote><p>当更新一条记录时，分区层先打开并锁住所有的底层表，mysql先确定需要更新的记录再哪个分区，然后取出数据并更新，再判断更新后的数据应该再哪个分区，最后对底层表进行写入操作，并对源数据所在的底层表进行删除操作</p></blockquote> <h4 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h4> <blockquote><p>​		当更新一条记录时，分区层先打开并锁住所有的底层表，mysql先确定需要更新的记录再哪个分区，然后取出数据并更新，再判断更新后的数据应该再哪个分区，最后对底层表进行写入操作，并对源数据所在的底层表进行删除操作。</p> <p>​		有些操作时支持过滤的，例如，当删除一条记录时，MySQL需要先找到这条记录，如果where条件恰好和分区表达式匹配，就可以将所有不包含这条记录的分区都过滤掉，这对update同样有效。如果是insert操作，则本身就是只命中一个分区，其他分区都会被过滤掉。mysql先确定这条记录属于哪个分区，再将记录写入对应得曾分区表，无须对任何其他分区进行操作。</p> <p>​		虽然每个操作都会“先打开并锁住所有的底层表”，但这并不是说分区表在处理过程中是锁住全表的，如果存储引擎能够自己实现行级锁，例如innodb，则会在分区层释放对应表锁。</p></blockquote> <h3 id="分区表的类型"><a href="#分区表的类型" class="header-anchor">#</a> 分区表的类型</h3> <h4 id="范围分区"><a href="#范围分区" class="header-anchor">#</a> 范围分区</h4> <blockquote><p>根据列值在给定范围内将行分配给分区。</p> <p>范围分区表的分区方式是：每个分区都包含行数据且分区的表达式在给定的范围内，分区的范围应该是连续的且不能重叠，可以使用values less than运算符来定义。</p></blockquote> <ol><li><p>创建普通的表</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>
    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>
    job_code <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    store_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>创建带分区的表，下面建表的语句是按照store_id来进行分区的，指定了4个分区</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>
    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>
    job_code <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    store_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span>store_id<span class="token punctuation">)</span> <span class="token punctuation">(</span>
    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">--在当前的建表语句中可以看到，store_id的值在1-5的在p0分区，6-10的在p1分区，11-15的在p3分区，16-20的在p4分区，但是如果插入超过20的值就会报错，因为mysql不知道将数据放在哪个分区</span>
</code></pre></div></li> <li><p>可以使用less than maxvalue来避免此种情况</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>
    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>
    job_code <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    store_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span>store_id<span class="token punctuation">)</span> <span class="token punctuation">(</span>
    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">--maxvalue表示始终大于等于最大可能整数值的整数值</span>
</code></pre></div></li> <li><p>可以使用相同的方式根据员工的职务代码对表进行分区</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>
    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>
    job_code <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    store_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span>job_code<span class="token punctuation">)</span> <span class="token punctuation">(</span>
    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>可以使用date类型进行分区：如虚妄根据每个员工离开公司的年份进行划分，如year(separated)</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>
    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>
    job_code <span class="token keyword">INT</span><span class="token punctuation">,</span>
    store_id <span class="token keyword">INT</span>
<span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>separated<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>
    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1991</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1996</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">2001</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>可以使用函数根据range的值来对表进行分区，如timestampunix_timestamp()</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> quarterly_report_status <span class="token punctuation">(</span>
    report_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    report_status <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    report_updated <span class="token keyword">TIMESTAMP</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span>
<span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span>report_updated<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>
    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-04-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-07-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-10-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p5 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-04-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p6 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-07-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p7 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-10-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p8 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2010-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p9 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">--timestamp不允许使用任何其他涉及值的表达式</span>
</code></pre></div><p><strong>基于时间间隔的分区方案，在mysql5.7中，可以基于范围或事件间隔实现分区方案，有两种选择</strong></p> <ol><li><p>基于范围的分区，对于分区表达式，可以使用操作函数基于date、time、或者datatime列来返回一个整数值</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> members <span class="token punctuation">(</span>
    firstname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    lastname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    joined <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span> <span class="token keyword">YEAR</span><span class="token punctuation">(</span>joined<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>
    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1960</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1970</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1980</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token number">1990</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> quarterly_report_status <span class="token punctuation">(</span>
    report_id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    report_status <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    report_updated <span class="token keyword">TIMESTAMP</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CURRENT_TIMESTAMP</span> <span class="token keyword">ON</span> <span class="token keyword">UPDATE</span> <span class="token keyword">CURRENT_TIMESTAMP</span>
<span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span>report_updated<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">(</span>
    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-04-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-07-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2008-10-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p5 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-04-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p6 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-07-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p7 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2009-10-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p8 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span> UNIX_TIMESTAMP<span class="token punctuation">(</span><span class="token string">'2010-01-01 00:00:00'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p9 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span>MAXVALUE<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>基于范围列的分区，使用date或者datatime列作为分区列</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> members <span class="token punctuation">(</span>
    firstname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    lastname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    username <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    email <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    joined <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE <span class="token keyword">COLUMNS</span><span class="token punctuation">(</span>joined<span class="token punctuation">)</span> <span class="token punctuation">(</span>
    <span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'1960-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'1970-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'1980-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN <span class="token punctuation">(</span><span class="token string">'1990-01-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN MAXVALUE
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><div class="language-sql extra-class"><pre class="language-sql"><code>
<span class="token comment">#不分区的表</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> no_part_tab
<span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
remark <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
d_date <span class="token keyword">DATE</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span>MYISAM<span class="token punctuation">;</span>
<span class="token comment">#分区的表</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> part_tab
<span class="token punctuation">(</span>id <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
remark <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
d_date <span class="token keyword">DATE</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span>MYISAM
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span><span class="token keyword">YEAR</span><span class="token punctuation">(</span>d_date<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>
<span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">1995</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">1996</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">1997</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">PARTITION</span> p3 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">1998</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">PARTITION</span> p4 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">1999</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">PARTITION</span> p5 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">PARTITION</span> p6 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">2001</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">PARTITION</span> p7 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">2002</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">PARTITION</span> p8 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">2003</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">PARTITION</span> p9 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">2004</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">PARTITION</span> p10 <span class="token keyword">VALUES</span> LESS THAN maxvalue<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">#插入未分区表记录</span>
<span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> no_load_part<span class="token punctuation">;</span>
 

<span class="token keyword">DELIMITER</span><span class="token comment">//</span>
<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> no_load_part<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
    <span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span><span class="token punctuation">;</span>
    <span class="token keyword">SET</span> i <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">WHILE</span> i<span class="token operator">&lt;</span><span class="token number">80001</span>
    <span class="token keyword">DO</span>
    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> no_part_tab <span class="token keyword">VALUES</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">'no'</span><span class="token punctuation">,</span>ADDDATE<span class="token punctuation">(</span><span class="token string">'1995-01-01'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>RAND<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">36520</span><span class="token punctuation">)</span> MOD <span class="token number">3652</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">SET</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token comment">//</span>
<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span>
 
<span class="token keyword">CALL</span> no_load_part<span class="token punctuation">;</span>
<span class="token comment">#插入分区表记录</span>
<span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> load_part<span class="token punctuation">;</span>
 
<span class="token keyword">DELIMITER</span><span class="token operator">&amp;&amp;</span> 
<span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> load_part<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">BEGIN</span>
    <span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span><span class="token punctuation">;</span>
    <span class="token keyword">SET</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">WHILE</span> i<span class="token operator">&lt;</span><span class="token number">80001</span>
    <span class="token keyword">DO</span>
    <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> part_tab <span class="token keyword">VALUES</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token string">'partition'</span><span class="token punctuation">,</span>ADDDATE<span class="token punctuation">(</span><span class="token string">'1995-01-01'</span><span class="token punctuation">,</span><span class="token punctuation">(</span>RAND<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">36520</span><span class="token punctuation">)</span> MOD <span class="token number">3652</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">SET</span> i<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span>
<span class="token keyword">END</span><span class="token operator">&amp;&amp;</span>
<span class="token keyword">DELIMITER</span> <span class="token punctuation">;</span>
 
<span class="token keyword">CALL</span> load_part<span class="token punctuation">;</span>
</code></pre></div></li></ol></li></ol> <h4 id="列表分区"><a href="#列表分区" class="header-anchor">#</a> 列表分区</h4> <blockquote><p>类似于按range分区，区别在于list分区是基于列值匹配一个离散值集合中的某个值来进行选择</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>
    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>
    job_code <span class="token keyword">INT</span><span class="token punctuation">,</span>
    store_id <span class="token keyword">INT</span>
<span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> LIST<span class="token punctuation">(</span>store_id<span class="token punctuation">)</span> <span class="token punctuation">(</span>
    <span class="token keyword">PARTITION</span> pNorth <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> pEast <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> pWest <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token keyword">PARTITION</span> pCentral <span class="token keyword">VALUES</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="列分区"><a href="#列分区" class="header-anchor">#</a> 列分区</h4> <blockquote><p>mysql从5.5开始支持column分区，可以认为i是range和list的升级版，在5.5之后，可以使用column分区替代range和list，但是column分区只接受普通列不接受表达式</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>list_c<span class="token punctuation">`</span> <span class="token punctuation">(</span>
 <span class="token punctuation">`</span>c1<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 <span class="token punctuation">`</span>c2<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>latin1
<span class="token comment">/*!50500 PARTITION BY RANGE COLUMNS(c1)
(PARTITION p0 VALUES LESS THAN (5) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (10) ENGINE = InnoDB) */</span>

 <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>list_c<span class="token punctuation">`</span> <span class="token punctuation">(</span>
 <span class="token punctuation">`</span>c1<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 <span class="token punctuation">`</span>c2<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 <span class="token punctuation">`</span>c3<span class="token punctuation">`</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>latin1
<span class="token comment">/*!50500 PARTITION BY RANGE COLUMNS(c1,c3)
(PARTITION p0 VALUES LESS THAN (5,'aaa') ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (10,'bbb') ENGINE = InnoDB) */</span>

 <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>list_c<span class="token punctuation">`</span> <span class="token punctuation">(</span>
 <span class="token punctuation">`</span>c1<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 <span class="token punctuation">`</span>c2<span class="token punctuation">`</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 <span class="token punctuation">`</span>c3<span class="token punctuation">`</span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>latin1
<span class="token comment">/*!50500 PARTITION BY LIST COLUMNS(c3)
(PARTITION p0 VALUES IN ('aaa') ENGINE = InnoDB,
 PARTITION p1 VALUES IN ('bbb') ENGINE = InnoDB) */</span>
</code></pre></div><h4 id="hash分区"><a href="#hash分区" class="header-anchor">#</a> hash分区</h4> <blockquote><p>基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含myql中有效的、产生非负整数值的任何表达式。</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>
    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>
    job_code <span class="token keyword">INT</span><span class="token punctuation">,</span>
    store_id <span class="token keyword">INT</span>
<span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span>store_id<span class="token punctuation">)</span>
PARTITIONS <span class="token number">4</span><span class="token punctuation">;</span>


<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> employees <span class="token punctuation">(</span>
    id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    fname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    lname <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    hired <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'1970-01-01'</span><span class="token punctuation">,</span>
    separated <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'9999-12-31'</span><span class="token punctuation">,</span>
    job_code <span class="token keyword">INT</span><span class="token punctuation">,</span>
    store_id <span class="token keyword">INT</span>
<span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> LINEAR <span class="token keyword">HASH</span><span class="token punctuation">(</span><span class="token keyword">YEAR</span><span class="token punctuation">(</span>hired<span class="token punctuation">)</span><span class="token punctuation">)</span>
PARTITIONS <span class="token number">4</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="key分区"><a href="#key分区" class="header-anchor">#</a> key分区</h4> <blockquote><p>类似于hash分区，区别在于key分区只支持一列或多列，且mysql服务器提供其自身的哈希函数，必须有一列或多列包含整数值</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> tk <span class="token punctuation">(</span>
    col1 <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
    col2 <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    col3 <span class="token keyword">DATE</span>
<span class="token punctuation">)</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> LINEAR <span class="token keyword">KEY</span> <span class="token punctuation">(</span>col1<span class="token punctuation">)</span>
PARTITIONS <span class="token number">3</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="子分区"><a href="#子分区" class="header-anchor">#</a> 子分区</h4> <blockquote><p>在分区的基础之上，再进行分区后存储</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t_partition_by_subpart<span class="token punctuation">`</span>
<span class="token punctuation">(</span>
  <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>sName<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>sAge<span class="token punctuation">`</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> ZEROFILL <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>sAddr<span class="token punctuation">`</span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>sGrade<span class="token punctuation">`</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>sStuId<span class="token punctuation">`</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token punctuation">`</span>sSex<span class="token punctuation">`</span> <span class="token keyword">INT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">UNSIGNED</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span><span class="token punctuation">,</span> <span class="token punctuation">`</span>sGrade<span class="token punctuation">`</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>  <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">INNODB</span>
<span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> RANGE<span class="token punctuation">(</span>id<span class="token punctuation">)</span>
SUBPARTITION <span class="token keyword">BY</span> <span class="token keyword">HASH</span><span class="token punctuation">(</span>sGrade<span class="token punctuation">)</span> SUBPARTITIONS <span class="token number">2</span>
<span class="token punctuation">(</span>
<span class="token keyword">PARTITION</span> p0 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">PARTITION</span> p1 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token keyword">PARTITION</span> p2 <span class="token keyword">VALUES</span> LESS THAN<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="如何使用分区表"><a href="#如何使用分区表" class="header-anchor">#</a> 如何使用分区表</h3> <blockquote><p>如果需要从非常大的表中查询出某一段时间的记录，而这张表中包含很多年的历史数据，数据是按照时间排序的，此时应该如何查询数据呢？
因为数据量巨大，肯定不能在每次查询的时候都扫描全表。考虑到索引在空间和维护上的消耗，也不希望使用索引，即使使用索引，会发现会产生大量的碎片，还会产生大量的随机IO，但是当数据量超大的时候，索引也就无法起作用了，此时可以考虑使用分区来进行解决</p></blockquote> <h4 id="全量扫描数据，不要任何索引"><a href="#全量扫描数据，不要任何索引" class="header-anchor">#</a> 全量扫描数据，不要任何索引</h4> <blockquote><p>使用简单的分区方式存放表，不要任何索引，根据分区规则大致定位需要的数据为止，通过使用where条件将需要的数据限制在少数分区中，这种策略适用于以正常的方式访问大量数据</p></blockquote> <h4 id="索引数据，并分离热点"><a href="#索引数据，并分离热点" class="header-anchor">#</a> 索引数据，并分离热点</h4> <blockquote><p>如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将这部分热点数据单独放在一个分区中，让这个分区的数据能够有机会都缓存在内存中，这样查询就可以只访问一个很小的分区表，能够使用索引，也能够有效的使用缓存</p></blockquote> <h3 id="在使用分区表的时候需要注意的问题"><a href="#在使用分区表的时候需要注意的问题" class="header-anchor">#</a> 在使用分区表的时候需要注意的问题</h3> <ol><li>null值会使分区过滤无效</li> <li>分区列和索引列不匹配，会导致查询无法进行分区过滤</li> <li>选择分区的成本可能很高</li> <li>打开并锁住所有底层表的成本可能很高</li> <li>维护分区的成本可能很高</li></ol> <h2 id="服务器参数设置"><a href="#服务器参数设置" class="header-anchor">#</a> 服务器参数设置</h2> <h3 id="general：通用配置"><a href="#general：通用配置" class="header-anchor">#</a> general：通用配置</h3> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># 数据文件存放的目录</span>
<span class="token attr-name">datadir</span><span class="token punctuation">=</span><span class="token attr-value">/var/lib/mysql</span>
<span class="token comment"># mysql.socket表示server和client在同一台服务器，并且使用localhost进行连接，就会使用socket进行连接</span>
<span class="token attr-name">socket</span><span class="token punctuation">=</span><span class="token attr-value">/var/lib/mysql/mysql.sock</span>
<span class="token comment"># 存储mysql的pid</span>
<span class="token attr-name">pid_file</span><span class="token punctuation">=</span><span class="token attr-value">/var/lib/mysql/mysql.pid</span>
<span class="token comment"># mysql服务的端口号</span>
<span class="token attr-name">port</span><span class="token punctuation">=</span><span class="token attr-value">3306</span>
<span class="token comment"># mysql存储引擎</span>
<span class="token attr-name">default_storage_engine</span><span class="token punctuation">=</span><span class="token attr-value">InnoDB</span>
<span class="token comment"># 当忘记mysql的用户名密码的时候，可以在mysql配置文件中配置该参数，跳过权限表验证，不需要密码即可登录mysql</span>
skip-grant-tables
</code></pre></div><h3 id="character：字符集"><a href="#character：字符集" class="header-anchor">#</a> character：字符集</h3> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># 客户端数据的字符集</span>
<span class="token attr-name">character_set_client</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># mysql处理客户端发来的信息时，会把这些数据转换成连接的字符集格式</span>
<span class="token attr-name">character_set_connection</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># mysql发送给客户端的结果集所用的字符集</span>
<span class="token attr-name">character_set_results</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 数据库默认的字符集</span>
<span class="token attr-name">character_set_database</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># mysql server的默认字符集</span>
<span class="token attr-name">character_set_server</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
</code></pre></div><h3 id="connection：连接-配置"><a href="#connection：连接-配置" class="header-anchor">#</a> connection：连接 配置</h3> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># mysql的最大连接数，如果数据库的并发连接请求比较大，应该调高该值</span>
<span class="token attr-name">max_connections</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 限制每个用户的连接个数</span>
<span class="token attr-name">max_user_connections</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># mysql能够暂存的连接数量，当mysql的线程在一个很短时间内得到非常多的连接请求时，就会起作用，如果mysql的连接数量达到max_connections时，新的请求会被存储在堆栈中，以等待某一个连接释放资源，如果等待连接的数量超过back_log,则不再接受连接资源</span>
<span class="token attr-name">back_log</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># mysql在关闭一个非交互的连接之前需要等待的时长</span>
<span class="token attr-name">wait_timeout</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 关闭一个交互连接之前需要等待的秒数</span>
<span class="token attr-name">interactive_timeout</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
</code></pre></div><h3 id="log：日志配置"><a href="#log：日志配置" class="header-anchor">#</a> log：日志配置</h3> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># 指定错误日志文件名称，用于记录当mysqld启动和停止时，以及服务器在运行中发生任何严重错误时的相关信息</span>
<span class="token attr-name">log_error</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 指定二进制日志文件名称，用于记录对数据造成更改的所有查询语句</span>
<span class="token attr-name">log_bin</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 指定将更新记录到二进制日志的数据库，其他所有没有显式指定的数据库更新将忽略，不记录在日志中</span>
<span class="token attr-name">binlog_do_db</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 指定不将更新记录到二进制日志的数据库</span>
<span class="token attr-name">binlog_ignore_db</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 指定多少次写日志后同步磁盘</span>
<span class="token attr-name">sync_binlog</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 是否开启查询日志记录</span>
<span class="token attr-name">general_log</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 指定查询日志文件名，用于记录所有的查询语句</span>
<span class="token attr-name">general_log_file</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 是否开启慢查询日志记录</span>
<span class="token attr-name">slow_query_log</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 指定慢查询日志文件名称，用于记录耗时比较长的查询语句</span>
<span class="token attr-name">slow_query_log_file</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 设置慢查询的时间，超过这个时间的查询语句才会记录日志</span>
<span class="token attr-name">long_query_time</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 是否将管理语句写入慢查询日志</span>
log_slow_admin_statements
</code></pre></div><h3 id="cache：缓存"><a href="#cache：缓存" class="header-anchor">#</a> cache：缓存</h3> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># 索引缓存去的大小（只对myisam表起作用）</span>
<span class="token attr-name">key_buffer_size</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># query cache</span>
<span class="token comment"># 查询缓存的大小，未来版本被删除</span>
<span class="token attr-name">query_cache_size</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>

<span class="token comment"># 查看缓存的相关属性</span>
<span class="token attr-name">show</span> <span class="token attr-value">status like '%Qcache%';</span>
<span class="token comment"># 缓存中相邻内存块的个数，如果值比较大，那么查询缓存中碎片比较多</span>
<span class="token attr-name">Qcache_free_blocks</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 查询缓存中剩余的内存大小</span>
<span class="token attr-name">Qcache_free_memory</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 表示有多少此命中缓存</span>
<span class="token attr-name">Qcache_hits</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 表示多少次未命中而插入</span>
<span class="token attr-name">Qcache_inserts</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 多少条query因为内存不足而被移除cache</span>
<span class="token attr-name">Qcache_lowmen_prunes</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 当前cache中缓存的query数量</span>
<span class="token attr-name">Qcache_queries_in_cache</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 当前cache中block的数量</span>
<span class="token attr-name">Qcache_total_blocks</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>

<span class="token comment"># 超出此大小的查询将不被缓存</span>
<span class="token attr-name">query_cache_limit</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 缓存块最小大小</span>
<span class="token attr-name">query_cache_min_res_unit</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 缓存类型，决定缓存什么样的查询：</span>
<span class="token comment"># 0表示禁用；</span>
<span class="token comment"># 1表示将缓存所有结果，除非sql语句中使用sql_no_cache金庸查询缓存；</span>
<span class="token comment"># 2表示只缓存select语句中通过sql_cache指定需要缓存的查询</span>
<span class="token attr-name">query_cache_type</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>

<span class="token comment"># 每个需要排序的线程分派该大小的缓冲区</span>
<span class="token attr-name">sort_buffer_size</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 限制server接受的数据包大小</span>
<span class="token attr-name">max_allowed_packet</span><span class="token punctuation">=</span><span class="token attr-value">32M</span>
<span class="token comment"># 表示关联缓存的大小</span>
<span class="token attr-name">join_buffer_size</span><span class="token punctuation">=</span><span class="token attr-value">2M</span>
<span class="token comment"># Threads_cached：代表当前此时此刻线程缓存中有多少空闲线程</span>
<span class="token comment"># Threads_connected：代表当前已简历连接的数量</span>
<span class="token comment"># Threads_created：代表最近一次服务启动，已创建现成的数量，如果该值比较大，那么服务器会一直再创建线程</span>
<span class="token comment"># Threads_running：代表当前激活的线程数</span>
<span class="token attr-name">thread_cache_size</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
</code></pre></div><h3 id="innodb-3"><a href="#innodb-3" class="header-anchor">#</a> innodb</h3> <div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># 该参数指定大小的内存来缓冲数据和索引，最大可以设置为物理内存的80%</span>
<span class="token attr-name">innodb_buffer_pool_size</span> <span class="token attr-value">=</span>
<span class="token comment"># 主要控制innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，值分别为0，1，2</span>
<span class="token attr-name">innodb_flush_log_at_trx_commit</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 设置innodb线程的并发数，默认为0表示不受限制，如果要设置建议跟服务器的cpu核心数一致或者是cpu核心数的两倍</span>
<span class="token attr-name">innodb_thread_concurrency</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 此参数确定日志文件所用的内存大小，以M为单位</span>
<span class="token attr-name">innodb_log_buffer_size</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 此参数确定数据日志文件的大小，以M为单位</span>
<span class="token attr-name">innodb_log_file_size</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 以循环方式将日志文件写到多个文件中</span>
<span class="token attr-name">innodb_log_files_in_group</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># mysql读入缓冲区大小，对表进行顺序扫描的请求将分配到一个读入缓冲区</span>
<span class="token attr-name">read_buffer_size</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># mysql随机读的缓冲区大小</span>
<span class="token attr-name">read_rnd_buffer_size</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 此参数确定为每张表分配一个新的文件</span>
<span class="token attr-name">innodb_file_per_table</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
</code></pre></div><h2 id="mysql集群"><a href="#mysql集群" class="header-anchor">#</a> mysql集群</h2> <h3 id="主从复制"><a href="#主从复制" class="header-anchor">#</a> 主从复制</h3> <h4 id="为什么需要主从复制"><a href="#为什么需要主从复制" class="header-anchor">#</a> 为什么需要主从复制</h4> <blockquote><ol><li>在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。</li> <li>做数据的热备</li> <li>架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。</li></ol></blockquote> <h4 id="什么是mysql的主从复制"><a href="#什么是mysql的主从复制" class="header-anchor">#</a> 什么是mysql的主从复制</h4> <blockquote><p>MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。</p></blockquote> <h4 id="mysql复制原理"><a href="#mysql复制原理" class="header-anchor">#</a> mysql复制原理</h4> <h5 id="原理"><a href="#原理" class="header-anchor">#</a> 原理</h5> <ol><li>master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中。</li> <li>slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/O Thread请求master二进制事件。</li> <li>同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/O Thread和SQLThread将进入睡眠状态，等待下一次被唤醒。</li></ol> <h5 id="也就是说"><a href="#也就是说" class="header-anchor">#</a> 也就是说</h5> <ol><li>从库会生成两个线程,一个I/O线程,一个SQL线程;</li> <li>I/O线程会去请求主库的binlog,并将得到的binlog写到本地的relay-log(中继日志)文件中;</li> <li>主库会生成一个log dump线程,用来给从库I/O线程传binlog;</li> <li>SQL线程,会读取relay log文件中的日志,并解析成sql语句逐一执行;</li></ol> <h5 id="需要注意"><a href="#需要注意" class="header-anchor">#</a> 需要注意</h5> <ol><li>master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。</li> <li>slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。</li> <li>Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。</li> <li>Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）。</li> <li>master和slave两节点间时间需同步。</li></ol> <h5 id="具体步骤"><a href="#具体步骤" class="header-anchor">#</a> 具体步骤</h5> <ol><li>从库通过手工执行change  master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）；    start  slave</li> <li>从库的IO线程和主库的dump线程建立连接。</li> <li>从库根据change  master  to 语句提供的file名和position号，IO线程向主库发起binlog的请求。</li> <li>主库dump线程根据从库的请求，将本地binlog以events的方式发给从库IO线程。</li> <li>从库IO线程接收binlog  events，并存放到本地relay-log中，传送过来的信息，会记录到master.info中</li> <li>从库SQL线程应用relay-log，并且把应用过的记录到relay-log.info中，默认情况下，已经应用过的relay 会自动被清理purge</li></ol> <h4 id="mysql主从形式"><a href="#mysql主从形式" class="header-anchor">#</a> mysql主从形式</h4> <h5 id="一主一从"><a href="#一主一从" class="header-anchor">#</a> 一主一从</h5> <p><img src="/images/MySQL%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E.png" alt="MySQL一主一从"></p> <h5 id="主主复制"><a href="#主主复制" class="header-anchor">#</a> 主主复制</h5> <p><img src="/images/MySQL%E4%B8%BB%E4%B8%BB%E5%A4%8D%E5%88%B6.png" alt="MySQL主主复制"></p> <h5 id="一主多从"><a href="#一主多从" class="header-anchor">#</a> 一主多从</h5> <p><img src="/images/MySQL%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E.png" alt="MySQL一主多从"></p> <h5 id="多主一从"><a href="#多主一从" class="header-anchor">#</a> 多主一从</h5> <p><img src="/images/MySQL%E5%A4%9A%E4%B8%BB%E4%B8%80%E4%BB%8E.png" alt="MySQL多主一从"></p> <h5 id="联级复制"><a href="#联级复制" class="header-anchor">#</a> 联级复制</h5> <p><img src="/images/MySQL%E8%81%94%E6%9C%BA%E5%A4%8D%E5%88%B6.png" alt="MySQL联机复制"></p> <h4 id="mysql主从同步延时分析"><a href="#mysql主从同步延时分析" class="header-anchor">#</a> mysql主从同步延时分析</h4> <blockquote><p>mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高，slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多，另一方面，由于sql thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。</p></blockquote> <h5 id="解决方案"><a href="#解决方案" class="header-anchor">#</a> 解决方案</h5> <ol><li>业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。</li> <li>单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库。</li> <li>服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。</li> <li>不同业务的mysql物理上放在不同机器，分散压力。</li> <li>使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。</li> <li>使用更加强劲的硬件设备</li></ol> <h5 id="mysql5-6-基于schema的并行复制"><a href="#mysql5-6-基于schema的并行复制" class="header-anchor">#</a> MySQL5.6 基于schema的并行复制</h5> <blockquote><div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># 即可有4个SQL Thread（coordinator线程）来进行并行复制，其状态为：Waiting for an evant from Coordinator</span>
<span class="token attr-name">slave_parallel_workers</span> <span class="token punctuation">=</span> <span class="token attr-value">4</span>
</code></pre></div></blockquote> <p>MySQL从5.6开始有了SQL Thread多个的概念，可以并发还原数据，即并行复制技术。其并行只是基于Schema的，也就是基于库的。如果数据库实例中存在多个Schema，这样设置对于Slave复制的速度可以有比较大的提升。通常情况下单库多表是更常见的一种情形，</p> <p>那基于库的并发就没有卵用。其核心思想是：不同 schema 下的表并发提交时的数据不会相互影响，即 slave 节点可以用对 relay log 中不同的 schema 各分配一个类似 SQL 功能的线程，来重放 relay log 中主库已经提交的事务，保持数据与主库一致。</p> <h5 id="mysql5-7-基于group-commit的并行复制"><a href="#mysql5-7-基于group-commit的并行复制" class="header-anchor">#</a> MySQL5.7 基于group commit的并行复制</h5> <blockquote><div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># 即可有4个SQL Thread（coordinator线程）来进行并行复制</span>
<span class="token attr-name">slave_parallel_workers</span><span class="token punctuation">=</span><span class="token attr-value">4</span>
<span class="token comment"># 变量slave-parallel-type可以有两个值：DATABASE 默认值，基于库的并行复制方式；LOGICAL_CLOCK：基于组提交的并行复制方式</span>
<span class="token attr-name">slave_parallel_type</span><span class="token punctuation">=</span><span class="token attr-value">LOGICAL_CLOCK</span>
</code></pre></div></blockquote> <p>一个组提交的事务都是可以并行回放，因为这些事务都已进入到事务的prepare阶段，则说明事务之间没有任何冲突（否则就不可能提交）。</p> <p>为了兼容MySQL 5.6基于库的并行复制，5.7引入了新的变量slave-parallel-type，其可以配置的值有：</p> <ol><li>DATABASE：默认值，基于库的并行复制方式</li> <li>LOGICAL_CLOCK：基于组提交的并行复制方式</li></ol> <p>由于MTS机制基于组提交实现，简单来说在主上是怎样并行执行的，从服务器上就怎么回放。这里存在一个可能，即若主服务器的并行度不够，则从机的并行机制效果就会大打折扣。</p> <h5 id="mysql8-0-基于write-set的并行复制"><a href="#mysql8-0-基于write-set的并行复制" class="header-anchor">#</a> MySQL8.0 基于write-set的并行复制</h5> <blockquote><div class="language-properties extra-class"><pre class="language-properties"><code><span class="token comment"># 用于控制如何决定事务的依赖关系。该值有三个选项：默认的 COMMIT_ORDERE 表示继续使用5.7中的基于组提交的方式决定事务的依赖关系；WRITESET 表示使用写集合来决定事务的依赖关系；还有一个选项 WRITESET_SESSION 表示使用 WriteSet 来决定事务的依赖关系，但是同一个Session内的事务不会有相同的 last_committed 值。</span>
<span class="token attr-name">binlog_transaction_depandency_tracking</span> <span class="token punctuation">=</span> <span class="token attr-value">COMMIT_ORDERE</span>
<span class="token comment"># 取值范围为 1-1000000 ，初始默认值为 25000</span>
<span class="token attr-name">binlog_transaction_dependency_history_size</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
<span class="token comment"># 控制检测事务依赖关系时采用的HASH算法，有三个取值 OFF| XXHASH64 | MURMUR32</span>
<span class="token comment"># 如果 binlog_transaction_depandency_tracking 取值为 WRITESET 或 WRITESET_SESSION, 那么该值取值不能为OFF，且不能变更。</span>
<span class="token attr-name">transaction_write_set_extraction</span> <span class="token punctuation">=</span><span class="token attr-value"> </span>
</code></pre></div></blockquote> <p>​		WriteSet 是通过检测两个事务是否更新了相同的记录来判断事务能否并行回放的，因此需要在运行时保存已经提交的事务信息以记录历史事务更新了哪些行。记录历史事务的参数为 binlog_transaction_dependency_history_size. 该值越大可以记录更多的已经提交的事务信息，不过需要注意的是，这个值并非指事务大小，而是指追踪的事务更新信息的数量。在开启了 WRITESET 或 WRITESET_SESSION 后，MySQL 按以下的方式标识并记录事务的更新。</p> <ul><li>如果事务当前更新的行有主键（Primary Key），则将 HASH(DB名，TABLE名，KEY名称，KEY_VALUE1, KEY_VALUE2,.....) 加入到当前事务的 vector write_set 中。</li> <li>如果事务当前更新的行有非空的唯一键 （Unique Key Not NULL）， 同样将 HASH(DB名, TABLE名，KEY名, KEY_VALUE1, ....)加入到当前事务的 write_set 中。</li> <li>如果事务更新的行有外键约束( FOREIGN KEY )且不为空，则将该 外键信息与VALUE 的HASH加到当前事务的 write_set 中</li> <li>如果事务当前更新的表的主键是其他某个表的外键，并设置当前事务 has_related_foreign_key = true</li> <li>如果事务更新了某一行且没有任何数据被加入到 write_set 中，则标记当前事务 has_missing_key = true</li></ul> <p>​		在执行冲突检测的时候，先会检查 has_related_foreign_key 和 has_missing_key ， 如果为true， 则退到 COMMIT_ORDER 模式。否则，会依照事务的 write_set 中的HASH值与已提交的事务的 write_set 进行比对，如果没有冲突，则当前事务与最后一个已提交的事务共享相同的 last_commited, 否则将从全局已提交的 write_set 中删除那个冲突的事务之前提交的所有write_set，并退化到 COMMIT_ORDER 计算last_committed 。 每次计算完事务的 last_committed 值以后，检测当前全局已提交事务的 write_set 是否已经超过了 binlog_transaction_dependency_history_size 设置的值，如果超过，则清空已提交事务的全局 write_set。</p> <p>​		从检测条件上看，该特性依赖于 主键和唯一索引，如果事务涉及的表中没有主键且没有唯一非空索引，那么将无法从此特性中获得性能的提升。除此之外，还需要将 Binlog 格式设置为 Row 格式。</p> <h5 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h5> <p>​		从 MySQL Hight Availability 的测试中可以看到，开启了基于 WriteSet 的事务依赖后，对Slave上RelayLog回放速度提升显著。Slave上的 RelayLog 回放速度将不再依赖于 Master 上提交时的并行程度，使得Slave上可以发挥其最大的吞吐能力， 这个特性在Slave上复制停止一段时间后恢复复制时尤其有效。</p> <p>​		这个特性使得 Slave 上可能拥有比 Master 上更大的吞吐量，同时可能在保证事务依赖关系的情况下，在 Slave 上产生 Master 上没有产生过的提交场景，事务的提交顺序可能会在 Slave 上发生改变。 虽然在5.7 的并行复制中就可能发生这种情况，不过在8.0中由于 Slave 上更高的并发能力，会使该场景更加常见。 通常情况下这不是什么大问题，不过如果在 Slave 上做基于 Binlog 的增量备份，可能就需要保证在 Slave 上与Master 上一致的提交顺序，这种情况下可以开启 <code>slave_preserve_commit_order</code> 这是一个 5.7 就引入的参数，可以保证 Slave 上并行回放的线程按 RelayLog 中写入的顺序 Commit。</p> <h3 id="读写分离"><a href="#读写分离" class="header-anchor">#</a> 读写分离</h3> <blockquote><p>MySQL读写分离基本原理是让master数据库处理写操作，slave数据库处理读操作。master将写操作的变更同步到各个slave节点。</p></blockquote> <h4 id="mysql读写分离能提高系统性能的原因"><a href="#mysql读写分离能提高系统性能的原因" class="header-anchor">#</a> MySQL读写分离能提高系统性能的原因</h4> <ol><li>物理服务器增加，机器处理能力提升。拿硬件换性能。</li> <li>主从只负责各自的读和写，极大程度缓解X锁和S锁争用。</li> <li>slave可以配置myiasm引擎，提升查询性能以及节约系统开销。</li> <li>master直接写是并发的，slave通过主库发送来的binlog恢复数据是异步。</li> <li>slave可以单独设置一些参数来提升其读的性能。</li> <li>增加冗余，提高可用性。</li></ol> <h4 id="mysql读写分离中间代理层"><a href="#mysql读写分离中间代理层" class="header-anchor">#</a> MySQL读写分离中间代理层</h4> <ol><li>mysql-proxy</li> <li>Amoeba</li> <li>MyCat</li></ol> <h2 id="mysql事务"><a href="#mysql事务" class="header-anchor">#</a> MySQL事务</h2> <h3 id="事务的处理"><a href="#事务的处理" class="header-anchor">#</a> 事务的处理</h3> <ol><li>正常的事务提交(commit)或者回滚(rollback)</li> <li>自动提交，但是一般情况下要将自动提交进行关闭，影响效率</li> <li>用户关闭会话，会自动提交事务</li> <li>系统崩溃或者断电的时候，自动回滚事务</li> <li>当一次执行多条sql（同时包含DML语句和DDL语句）时，当在执行DDL语句之前，会自动提交事务，所以当遇到这种情况时，应当把DDL语句放在最后执行。</li> <li>sql分类：
<ol><li>DML 数据操控:如select,insert,update,delete</li> <li>DCL 数据控制:如权限控制，grant,revoke</li> <li>DDL 数据定义:如create,alter,drop等表定义语句</li></ol></li></ol> <h3 id="事务的基本特性"><a href="#事务的基本特性" class="header-anchor">#</a> 事务的基本特性</h3> <blockquote><p>事务的基本特性<font color="red">ACID</font>：</p> <ol><li><strong>原子性（Atomicity）</strong>：一个原子事务要么完整执行，要么干脆不执行。这意味着，工作单元中的每项任务都必须正确执行。如果有任一任务执行失败，则整个工作单元或事务就会被终止。即此前对数据所作的任何修改都将被撤销。如果所有任务都被成功执行，事务就会被提交，即对数据所作的修改将会是永久性的。</li> <li><strong>一致性（Consistency）</strong>：一致性代表了底层数据存储的完整性。它必须由事务系统和应用开发人员共同来保证。事务系统通过保证事务的原子性，隔离性和持久性来满足这一要求; 应用开发人员则需要保证数据库有适当的约束(主键，引用完整性等)，并且工作单元中所实现的业务逻辑不会导致数据的不一致(即，数据预期所表达的现实业务情况不相一致)。例如，在一次转账过程中，从某一账户中扣除的金额必须与另一账户中存入的金额相等。支付宝账号100 你读到余额要取，有人向你转100 但是事物没提交（这时候你读到的余额应该是100，而不是200） 这种就是一致性。</li> <li><strong>隔离性（Isolation）</strong>：隔离性意味着事务必须在不干扰其他进程或事务的前提下独立执行。换言之，在事务或工作单元执行完毕之前，其所访问的数据不能受系统其他部分的影响。</li> <li><strong>持久性（Durability）</strong>：持久性表示在某个事务的执行过程中，对数据所作的所有改动都必须在事务成功结束前保存至某种物理存储设备。这样可以保证，所作的修改在任何系统瘫痪时不至于丢失。</li></ol></blockquote> <h3 id="隔离级别"><a href="#隔离级别" class="header-anchor">#</a> 隔离级别</h3> <blockquote><ol><li><strong>脏读</strong></li></ol> <p><strong>所谓脏读，就是指事务A读到了事务B还没有提交的数据</strong>，比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务--&gt;取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读。</p> <ol start="2"><li><strong>不可重复读</strong></li></ol> <p>所谓不可重复读，就是指<strong>在一个事务里面读取了两次某个数据，读出来的数据不一致</strong>。还是以银行取钱为例，事务A开启事务--&gt;查出银行卡余额为1000元，此时切换到事务B事务B开启事务--&gt;事务B取走100元--&gt;提交，数据库里面余额变为900元，此时切换回事务A，事务A再查一次查出账户余额为900元，这样对事务A而言，在同一个事务内两次读取账户余额数据不一致，这就是不可重复读。</p> <ol start="3"><li><strong>幻读</strong></li></ol> <p>所谓幻读，就是指<strong>在一个事务里面的操作中发现了未被操作的数据</strong>。比如学生信息，事务A开启事务--&gt;修改所有学生当天签到状况为false，此时切换到事务B，事务B开启事务--&gt;事务B插入了一条学生数据，此时切换回事务A，事务A提交的时候发现了一条自己没有修改过的数据，这就是幻读，就好像发生了幻觉一样。幻读出现的前提是并发的事务中有事务发生了插入、删除操作。</p></blockquote> <table><thead><tr><th>MySQL的事务隔离级别：默认可重复读</th> <th>脏读</th> <th>不可重复读</th> <th>幻读</th></tr></thead> <tbody><tr><td>读未提交（read-uncommitted）</td> <td>是</td> <td>是</td> <td>是</td></tr> <tr><td>读已提交（read-committed）</td> <td>否</td> <td>是</td> <td>是</td></tr> <tr><td>可重复读（repeatable-read）</td> <td>否</td> <td>否</td> <td>是</td></tr> <tr><td>序列化（serializable）</td> <td>否</td> <td>否</td> <td>否</td></tr></tbody></table> <table><thead><tr><th>Oracle的事务隔离级别:默认读已提交</th> <th>脏读</th> <th>不可重复读</th> <th>幻读</th></tr></thead> <tbody><tr><td>读已提交（read-committed）</td> <td>否</td> <td>是</td> <td>是</td></tr> <tr><td>只读（read only）</td> <td>否</td> <td>否</td> <td>是</td></tr> <tr><td>序列化（serializable）</td> <td>否</td> <td>否</td> <td>否</td></tr></tbody></table></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">8/11/2020, 9:48:01 AM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/tiankafei-docs-架构/mysql主从复制安装配置.html">
        mysql主从复制安装配置
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.2037e208.js" defer></script><script src="/assets/js/2.39facb6e.js" defer></script><script src="/assets/js/96.c8852b6e.js" defer></script>
  </body>
</html>
