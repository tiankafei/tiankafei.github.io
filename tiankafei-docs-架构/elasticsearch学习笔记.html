<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Elasticsearch学习笔记 | tiankafei - java相关技术栈</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="自己写的一些东西的记录，包括代码与笔记，jdk最低支持1.8">
    
    <link rel="preload" href="/assets/css/0.styles.992cb7aa.css" as="style"><link rel="preload" href="/assets/js/app.0c8fedd9.js" as="script"><link rel="preload" href="/assets/js/2.01d54993.js" as="script"><link rel="preload" href="/assets/js/109.e00fbc70.js" as="script"><link rel="prefetch" href="/assets/js/10.58f35d33.js"><link rel="prefetch" href="/assets/js/100.84acf76d.js"><link rel="prefetch" href="/assets/js/101.e221b0fe.js"><link rel="prefetch" href="/assets/js/102.36f7f518.js"><link rel="prefetch" href="/assets/js/103.09a81bba.js"><link rel="prefetch" href="/assets/js/104.e17749cc.js"><link rel="prefetch" href="/assets/js/105.7544910c.js"><link rel="prefetch" href="/assets/js/106.245ef0b3.js"><link rel="prefetch" href="/assets/js/107.b0baa158.js"><link rel="prefetch" href="/assets/js/108.bde0b667.js"><link rel="prefetch" href="/assets/js/11.8b67ea4c.js"><link rel="prefetch" href="/assets/js/110.ac42c960.js"><link rel="prefetch" href="/assets/js/111.9e55c36b.js"><link rel="prefetch" href="/assets/js/112.40a75b78.js"><link rel="prefetch" href="/assets/js/113.730f0c75.js"><link rel="prefetch" href="/assets/js/114.cd1c6b8e.js"><link rel="prefetch" href="/assets/js/12.e4797305.js"><link rel="prefetch" href="/assets/js/13.2d85b92c.js"><link rel="prefetch" href="/assets/js/14.2bc1fdb5.js"><link rel="prefetch" href="/assets/js/15.49ea1e69.js"><link rel="prefetch" href="/assets/js/16.9937b620.js"><link rel="prefetch" href="/assets/js/17.fc4b47cc.js"><link rel="prefetch" href="/assets/js/18.e71556ea.js"><link rel="prefetch" href="/assets/js/19.64c8d43a.js"><link rel="prefetch" href="/assets/js/20.94d72ec6.js"><link rel="prefetch" href="/assets/js/21.6e71044d.js"><link rel="prefetch" href="/assets/js/22.4dfd648a.js"><link rel="prefetch" href="/assets/js/23.2735fc15.js"><link rel="prefetch" href="/assets/js/24.96da47ed.js"><link rel="prefetch" href="/assets/js/25.d3a64953.js"><link rel="prefetch" href="/assets/js/26.49ae9931.js"><link rel="prefetch" href="/assets/js/27.ffe2ff7f.js"><link rel="prefetch" href="/assets/js/28.ceee6202.js"><link rel="prefetch" href="/assets/js/29.5b430924.js"><link rel="prefetch" href="/assets/js/3.351222b0.js"><link rel="prefetch" href="/assets/js/30.9c5198e3.js"><link rel="prefetch" href="/assets/js/31.44022a56.js"><link rel="prefetch" href="/assets/js/32.91854b18.js"><link rel="prefetch" href="/assets/js/33.2741799d.js"><link rel="prefetch" href="/assets/js/34.d61e93c3.js"><link rel="prefetch" href="/assets/js/35.d28b7f5d.js"><link rel="prefetch" href="/assets/js/36.b646bfa4.js"><link rel="prefetch" href="/assets/js/37.675752e5.js"><link rel="prefetch" href="/assets/js/38.02c1902d.js"><link rel="prefetch" href="/assets/js/39.619db316.js"><link rel="prefetch" href="/assets/js/4.09fd2c39.js"><link rel="prefetch" href="/assets/js/40.40114a7e.js"><link rel="prefetch" href="/assets/js/41.3333f019.js"><link rel="prefetch" href="/assets/js/42.062a57df.js"><link rel="prefetch" href="/assets/js/43.b98eeccd.js"><link rel="prefetch" href="/assets/js/44.07744a1c.js"><link rel="prefetch" href="/assets/js/45.710abf0f.js"><link rel="prefetch" href="/assets/js/46.03d81f06.js"><link rel="prefetch" href="/assets/js/47.71d843a3.js"><link rel="prefetch" href="/assets/js/48.165ad08f.js"><link rel="prefetch" href="/assets/js/49.c3bdf6cb.js"><link rel="prefetch" href="/assets/js/5.b99a1609.js"><link rel="prefetch" href="/assets/js/50.4cdf3914.js"><link rel="prefetch" href="/assets/js/51.9cc34600.js"><link rel="prefetch" href="/assets/js/52.d136f074.js"><link rel="prefetch" href="/assets/js/53.7d6c4853.js"><link rel="prefetch" href="/assets/js/54.266352df.js"><link rel="prefetch" href="/assets/js/55.9c7abe31.js"><link rel="prefetch" href="/assets/js/56.cc13690d.js"><link rel="prefetch" href="/assets/js/57.ad23abd1.js"><link rel="prefetch" href="/assets/js/58.b421ad53.js"><link rel="prefetch" href="/assets/js/59.772d89ce.js"><link rel="prefetch" href="/assets/js/6.ffe6f60a.js"><link rel="prefetch" href="/assets/js/60.cac6aca8.js"><link rel="prefetch" href="/assets/js/61.59fc7ed6.js"><link rel="prefetch" href="/assets/js/62.46487051.js"><link rel="prefetch" href="/assets/js/63.0571f56e.js"><link rel="prefetch" href="/assets/js/64.72dabea2.js"><link rel="prefetch" href="/assets/js/65.41225f22.js"><link rel="prefetch" href="/assets/js/66.4e19dd3e.js"><link rel="prefetch" href="/assets/js/67.2f155615.js"><link rel="prefetch" href="/assets/js/68.96903420.js"><link rel="prefetch" href="/assets/js/69.be7e8a2e.js"><link rel="prefetch" href="/assets/js/7.7600938e.js"><link rel="prefetch" href="/assets/js/70.9015f675.js"><link rel="prefetch" href="/assets/js/71.98690377.js"><link rel="prefetch" href="/assets/js/72.121d7122.js"><link rel="prefetch" href="/assets/js/73.4d3a3fac.js"><link rel="prefetch" href="/assets/js/74.011b1551.js"><link rel="prefetch" href="/assets/js/75.c567ff6d.js"><link rel="prefetch" href="/assets/js/76.6334001e.js"><link rel="prefetch" href="/assets/js/77.67ac655a.js"><link rel="prefetch" href="/assets/js/78.281d465d.js"><link rel="prefetch" href="/assets/js/79.c178a2b9.js"><link rel="prefetch" href="/assets/js/8.c1a7f057.js"><link rel="prefetch" href="/assets/js/80.bd7ebfcf.js"><link rel="prefetch" href="/assets/js/81.c34a169b.js"><link rel="prefetch" href="/assets/js/82.3f41273f.js"><link rel="prefetch" href="/assets/js/83.b01cd471.js"><link rel="prefetch" href="/assets/js/84.7cd30602.js"><link rel="prefetch" href="/assets/js/85.0e12ef40.js"><link rel="prefetch" href="/assets/js/86.8d04b4e9.js"><link rel="prefetch" href="/assets/js/87.5a7c4bcd.js"><link rel="prefetch" href="/assets/js/88.73e54d2e.js"><link rel="prefetch" href="/assets/js/89.2428cbf7.js"><link rel="prefetch" href="/assets/js/9.af38beaa.js"><link rel="prefetch" href="/assets/js/90.6742014d.js"><link rel="prefetch" href="/assets/js/91.1cc77556.js"><link rel="prefetch" href="/assets/js/92.f6881b21.js"><link rel="prefetch" href="/assets/js/93.3ff97c94.js"><link rel="prefetch" href="/assets/js/94.cfade6b9.js"><link rel="prefetch" href="/assets/js/95.84213e8e.js"><link rel="prefetch" href="/assets/js/96.df85149f.js"><link rel="prefetch" href="/assets/js/97.bb0c49a5.js"><link rel="prefetch" href="/assets/js/98.e24468d8.js"><link rel="prefetch" href="/assets/js/99.291b658f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.992cb7aa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">tiankafei - java相关技术栈</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/tiankafei-docs-java/Java基础.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/tiankafei-docs-spring/spring学习笔记/" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/tiankafei-docs-架构/MySQL调优/" class="nav-link">
  架构
</a></div><div class="nav-item"><a href="/tiankafei-docs-大数据/centos7安装配置Hadoop/" class="nav-link">
  大数据
</a></div><div class="nav-item"><a href="/tiankafei-docs-linux/centos常用命令/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/tiankafei-docs-云/Centos7安装Docker并配置使用/" class="nav-link">
  云
</a></div><div class="nav-item"><a href="/tiankafei-docs-other/git命令/" class="nav-link">
  其他
</a></div><div class="nav-item"><a href="/tiankafei-docs-en/词性语法学习/" class="nav-link">
  英语
</a></div><div class="nav-item"><a href="https://github.com/tiankafei/tiankafei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/tiankafei-docs-java/Java基础.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/tiankafei-docs-spring/spring学习笔记/" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/tiankafei-docs-架构/MySQL调优/" class="nav-link">
  架构
</a></div><div class="nav-item"><a href="/tiankafei-docs-大数据/centos7安装配置Hadoop/" class="nav-link">
  大数据
</a></div><div class="nav-item"><a href="/tiankafei-docs-linux/centos常用命令/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/tiankafei-docs-云/Centos7安装Docker并配置使用/" class="nav-link">
  云
</a></div><div class="nav-item"><a href="/tiankafei-docs-other/git命令/" class="nav-link">
  其他
</a></div><div class="nav-item"><a href="/tiankafei-docs-en/词性语法学习/" class="nav-link">
  英语
</a></div><div class="nav-item"><a href="https://github.com/tiankafei/tiankafei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>架构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tiankafei-docs-架构/MySQL调优.html" class="sidebar-link">MySQL调优</a></li><li><a href="/tiankafei-docs-架构/mysql主从复制安装配置.html" class="sidebar-link">mysql主从复制安装配置</a></li><li><a href="/tiankafei-docs-架构/使用amoeba实现mysql读写分离.html" class="sidebar-link">使用amoeba实现mysql读写分离</a></li><li><a href="/tiankafei-docs-架构/redis学习笔记.html" class="sidebar-link">redis介绍</a></li><li><a href="/tiankafei-docs-架构/zookeeper学习笔记.html" class="sidebar-link">zookeeper学习笔记</a></li><li><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html" class="active sidebar-link">Elasticsearch学习笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#帮助文档" class="sidebar-link">帮助文档</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#中文官方文档-较老" class="sidebar-link">中文官方文档（较老）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#英文最新文档-较新" class="sidebar-link">英文最新文档（较新）</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es核心概念和原理" class="sidebar-link">ES核心概念和原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#什么是搜索" class="sidebar-link">什么是搜索</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#如何实现搜索功能" class="sidebar-link">如何实现搜索功能</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#倒排索引、lucene和全文检索" class="sidebar-link">倒排索引、Lucene和全文检索</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#倒排索引的特点" class="sidebar-link">倒排索引的特点</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#elasticsearch" class="sidebar-link">Elasticsearch</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-核心概念" class="sidebar-link">ES 核心概念</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#环境安装" class="sidebar-link">环境安装</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#docker-安装配置-es" class="sidebar-link">docker 安装配置 es</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#docker-安装配置-kibana" class="sidebar-link">docker 安装配置 kibana</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-健康检查" class="sidebar-link">es 健康检查</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es节点有哪些类型" class="sidebar-link">ES节点有哪些类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_1-主节点-master-node" class="sidebar-link">1. 主节点（Master node）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_2-数据节点-data-node" class="sidebar-link">2. 数据节点（Data node）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_3-预处理节点-ingest-node" class="sidebar-link">3. 预处理节点（ingest node）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_4-协调节点-coordinating-node" class="sidebar-link">4. 协调节点（Coordinating node）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_5-部落节点-trible-node" class="sidebar-link">5. 部落节点（Trible node）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_6-投票节点-voting-node" class="sidebar-link">6. 投票节点（voting node）</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es如何实现高可用" class="sidebar-link">ES如何实现高可用</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es容错机制" class="sidebar-link">ES容错机制</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#如何提高es分布式系统的可用性及性能最大化" class="sidebar-link">如何提高ES分布式系统的可用性及性能最大化</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#master选举流程" class="sidebar-link">Master选举流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#findmaster" class="sidebar-link">findMaster</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#简单curd" class="sidebar-link">简单CURD</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#创建索引" class="sidebar-link">创建索引</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#查询索引状态" class="sidebar-link">查询索引状态</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#删除索引" class="sidebar-link">删除索引</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#查看索引信息" class="sidebar-link">查看索引信息</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#插入数据" class="sidebar-link">插入数据</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#查询数据" class="sidebar-link">查询数据</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#更新数据" class="sidebar-link">更新数据</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#删除数据" class="sidebar-link">删除数据</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-常用查询" class="sidebar-link">ES 常用查询</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_1-search-timeout" class="sidebar-link">1. search timeout</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_2-query-string" class="sidebar-link">2. query_string</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_3-match-all-匹配所有" class="sidebar-link">3. match_all：匹配所有</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_4-match-name中包含-nfc" class="sidebar-link">4. match：name中包含“nfc”</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_5-sort-按照加个倒序排序" class="sidebar-link">5. sort：按照加个倒序排序</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_6-multi-match-根据多个字段查询一个关键词" class="sidebar-link">6. multi_match：根据多个字段查询一个关键词</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_7-source-元数据-想要查询多个字段" class="sidebar-link">7. _source：元数据，想要查询多个字段</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_8-分页-查询第一页-每页两条数据" class="sidebar-link">8. 分页：查询第一页（每页两条数据）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_9-全文检索-term-不会被分词" class="sidebar-link">9. 全文检索：term：不会被分词</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_10-全文检索-match-会被分词" class="sidebar-link">10. 全文检索：match：会被分词</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_11-短语搜索-match-phrase-和全文检索相反" class="sidebar-link">11. 短语搜索：match_phrase：和全文检索相反</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_12-查询过滤" class="sidebar-link">12. 查询过滤</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_13-compound-queries组合查询" class="sidebar-link">13. Compound queries组合查询</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_14-highlight-search高亮查询" class="sidebar-link">14. Highlight search高亮查询</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_15-deep-paging" class="sidebar-link">15. Deep paging</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_16-scroll-search" class="sidebar-link">16. Scroll search</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_17-filter缓存原理" class="sidebar-link">17. filter缓存原理</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#mapping" class="sidebar-link">Mapping</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_1-概念" class="sidebar-link">1. 概念</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_2-查看mapping" class="sidebar-link">2. 查看mapping</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_3-动态mapping" class="sidebar-link">3. 动态mapping</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_4-搜索方式" class="sidebar-link">4. 搜索方式</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_5-es数据类型" class="sidebar-link">5. ES数据类型</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_6-手工创建mapping" class="sidebar-link">6. 手工创建Mapping</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_7-mapping-parameters" class="sidebar-link">7. Mapping parameters</a></li></ul></li></ul></li><li><a href="/tiankafei-docs-架构/Tomcat源码分析.html" class="sidebar-link">Tomcat源码分析</a></li><li><a href="/tiankafei-docs-架构/Netty源码分析.html" class="sidebar-link">Netty源码分析</a></li><li><a href="/tiankafei-docs-架构/分布式架构.html" class="sidebar-link">分布式架构</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="elasticsearch学习笔记"><a href="#elasticsearch学习笔记" class="header-anchor">#</a> Elasticsearch学习笔记</h1> <h2 id="帮助文档"><a href="#帮助文档" class="header-anchor">#</a> 帮助文档</h2> <h3 id="中文官方文档-较老"><a href="#中文官方文档-较老" class="header-anchor">#</a> 中文官方文档（较老）</h3> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">https:</span>//www.elastic.co/guide/cn/elasticsearch/guide/current/getting-started.html#getting-started
</code></pre></div><h3 id="英文最新文档-较新"><a href="#英文最新文档-较新" class="header-anchor">#</a> 英文最新文档（较新）</h3> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">https:</span>//www.elastic.co/guide/en/elasticsearch/reference/7.10/getting-started.html
</code></pre></div><h2 id="es核心概念和原理"><a href="#es核心概念和原理" class="header-anchor">#</a> ES核心概念和原理</h2> <h3 id="什么是搜索"><a href="#什么是搜索" class="header-anchor">#</a> 什么是搜索</h3> <p>百度、垂直搜索（站内搜索）。搜索：通过一个<strong>关键词</strong>或一段描述，得到你想要（相关度高）的结果</p> <h3 id="如何实现搜索功能"><a href="#如何实现搜索功能" class="header-anchor">#</a> 如何实现搜索功能</h3> <p>关系型数据库：性能差、不可靠、结果不准确（相关度低）</p> <h3 id="倒排索引、lucene和全文检索"><a href="#倒排索引、lucene和全文检索" class="header-anchor">#</a> 倒排索引、<code>Lucene</code>和全文检索</h3> <ol><li>倒排索引的数据结构（存储的数据）
<ol><li>包含这个关键词的<code>document list</code></li> <li>关键词在每个doc中出现的次数<code>TF term frequency</code></li> <li>关键词在整个索引中出现的次数<code>IDF inverse doc frequency</code>（值越大，代表相关度越低）</li> <li>关键词在当前<code>doc</code>中出现的次数</li> <li>每个<code>doc</code>的长度，越长相关度越低</li> <li>包含这个关键词的所有<code>doc</code>的平均长度</li></ol></li> <li><code>Lucene</code>：<code>jar</code>包，帮我们创建倒排索引，提供了复杂的<code>API</code></li> <li>如果用<code>Luncene</code>做集群，会有哪些问题
<ul><li>节点一旦宕机，节点数据丢失，后果不堪设想，可用性差</li> <li>自己维护，麻烦（自己创建管理索引），单台节点的承载请求的能里是有限的，需要人工做负载。</li></ul></li></ol> <p><img src="/images/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png" alt="倒排索引"></p> <h3 id="倒排索引的特点"><a href="#倒排索引的特点" class="header-anchor">#</a> 倒排索引的特点</h3> <ol><li>倒排索引的数据量 &gt; 原始数据量</li> <li>倒排索引做的是完全匹配，不需要全表扫描</li> <li>倒排索引记录着这个词出现在原始数据的那个主键，根据主键去原始数据中查询是很快的</li></ol> <h3 id="elasticsearch"><a href="#elasticsearch" class="header-anchor">#</a> Elasticsearch</h3> <ol><li>特点
<ul><li>分布式</li> <li>高性能</li> <li>高可用</li> <li>可伸缩</li> <li>易维护</li></ul></li> <li>优点
<ul><li>面向开发者友好，屏蔽了Lucene的复杂特性，集群自动发现（cluster discovery）</li> <li>自动维护数据在多个节点上的建立</li> <li>会帮我们做搜索请求的负载均衡</li> <li>自动维护冗余副本，保证了部分节点宕机的情况下仍然不会有任何数据丢失</li> <li><code>ES</code>基于<code>Lucene</code>提供了很多高级功能：复合查询、聚合分析、基于地理位置等</li> <li>对于大公司，可以构建几百台服务器的大型分布式集群，处理PB级别数据；对于小公司，开箱即用，门槛低上手简单</li> <li>相比传统数据库，提供了全文检索，同义词处理（美丽的 cls &gt; 漂亮的 cls），相关度排名。聚合分析以及海量数据的近实时（NTR）处理，这些传统数据库完全做不到</li></ul></li> <li>应用领域
<ul><li>百度（全文检索，高亮、搜索推荐）</li> <li>各大网站的用户行为日志（用户点击、浏览、收藏、评论）</li> <li>BI（business Intelligence商业智能），数据分析，数据挖掘统计</li> <li>Github：代码托管平台，几千亿行代码</li> <li>ELK：Elasticsearch（数据存储）、Logstash（日志采集）、Kibana（可视化）</li></ul></li></ol> <h3 id="es-核心概念"><a href="#es-核心概念" class="header-anchor">#</a> ES 核心概念</h3> <ol><li><code>cluster</code>（集群）：每个集群至少包含两个节点</li> <li><code>node</code>：集群中的每个节点，一个节点不代表一台服务器</li> <li><code>field</code>：一个数据字段，与<code>index</code>和<code>type</code>一起，可以定位一个<code>doc</code></li> <li><code>document</code>：<code>es</code>最小的数据单元，通常是以<code>json</code>的形式存储的</li> <li><code>type</code>：逻辑上的数据分类，<code>es7.x</code>中删除了<code>type</code>的概念</li> <li><code>index</code>：一类相同或者类似的<code>doc</code>，比如一个员工索引，商品索引</li> <li><code>shard</code>分片：P分片，R副本
<ul><li>一个<code>index</code>包含多个<code>shard</code>，默认5个分片，默认每个分片分配一个副本，分片的数量在创建索引的时候设置，如果想修改，需要重建索引</li> <li>每个<code>shard</code>都是一个<code>lucene</code>实例，有完整的创建索引的处理请求能力</li> <li>es会自动在<code>nodes</code>上为我们做<code>shard</code>均衡</li> <li>一个<code>doc</code>是不可能同时存在与多个分片中的，但是可以存在于多个副本中</li> <li>分片和对应的副本不能同时存在于同一个节点，所以最低的可用配置是两个节点，互为主备</li></ul></li></ol> <h2 id="环境安装"><a href="#环境安装" class="header-anchor">#</a> 环境安装</h2> <h3 id="docker-安装配置-es"><a href="#docker-安装配置-es" class="header-anchor">#</a> docker 安装配置 es</h3> <h4 id="拉取镜像"><a href="#拉取镜像" class="header-anchor">#</a> 拉取镜像</h4> <div class="language-sh extra-class"><pre class="language-sh"><code>docker pull elasticsearch:7.6.2
</code></pre></div><h4 id="启动es"><a href="#启动es" class="header-anchor">#</a> 启动es</h4> <div class="language-shell extra-class"><pre class="language-shell"><code>docker run -d -p <span class="token number">9200</span>:9200 -p <span class="token number">9300</span>:9300 --restart<span class="token operator">=</span>always -e <span class="token string">&quot;discovery.type=single-node&quot;</span> --name<span class="token operator">=</span>elasticsearch elasticsearch:7.6.2
</code></pre></div><h4 id="修改配置"><a href="#修改配置" class="header-anchor">#</a> 修改配置</h4> <ol><li><p>进入容器</p> <div class="language-shell extra-class"><pre class="language-shell"><code>docker <span class="token builtin class-name">exec</span> -it elasticsearch <span class="token function">bash</span>
</code></pre></div></li> <li><p>vi config/elasticsearch.yml</p> <div class="language-shell extra-class"><pre class="language-shell"><code>cluster.name: <span class="token string">&quot;my-application&quot;</span>
node.name: <span class="token string">&quot;node-1&quot;</span>
network.host: <span class="token number">0.0</span>.0.0
</code></pre></div></li> <li><p>重启容器</p> <div class="language-shell extra-class"><pre class="language-shell"><code>docker restart elasticsearch
</code></pre></div></li></ol> <h4 id="访问地址"><a href="#访问地址" class="header-anchor">#</a> 访问地址</h4> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">http:</span>//&lt;IP&gt;:&lt;PORT&gt;
<span class="token header-name keyword">http:</span>//192.168.21.123:9200/
</code></pre></div><h3 id="docker-安装配置-kibana"><a href="#docker-安装配置-kibana" class="header-anchor">#</a> docker 安装配置 kibana</h3> <h4 id="拉取镜像-2"><a href="#拉取镜像-2" class="header-anchor">#</a> 拉取镜像</h4> <div class="language-shell extra-class"><pre class="language-shell"><code>docker pull kibana:7.6.2
</code></pre></div><h4 id="启动kibana"><a href="#启动kibana" class="header-anchor">#</a> 启动kibana</h4> <div class="language-shell extra-class"><pre class="language-shell"><code>docker run -d -p <span class="token number">5601</span>:5601 --restart<span class="token operator">=</span>always --name kibana kibana:7.6.2
</code></pre></div><h4 id="出现的问题修改配置"><a href="#出现的问题修改配置" class="header-anchor">#</a> 出现的问题修改配置</h4> <ol><li><p>如果出现以下页面：Kibana server is not ready yet，说明Kibana没有找到ES节点</p></li> <li><p>进入容器</p> <div class="language-shell extra-class"><pre class="language-shell"><code>docker <span class="token builtin class-name">exec</span> -it kibana <span class="token function">bash</span>
</code></pre></div></li> <li><p>vi config/kibana.yml</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token comment">#</span>
<span class="token comment"># ** THIS IS AN AUTO-GENERATED FILE **</span>
<span class="token comment">#</span>

<span class="token comment"># Default Kibana configuration for docker target</span>
<span class="token key atrule">server.name</span><span class="token punctuation">:</span> kibana
<span class="token key atrule">server.host</span><span class="token punctuation">:</span> <span class="token string">&quot;0&quot;</span>
<span class="token comment"># 中文配置</span>
<span class="token key atrule">i18n.locale</span><span class="token punctuation">:</span> <span class="token string">&quot;zh-CN&quot;</span>
<span class="token key atrule">elasticsearch.hosts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;http://192.168.21.123:9200&quot;</span> <span class="token punctuation">]</span>
<span class="token key atrule">xpack.monitoring.ui.container.elasticsearch.enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre></div></li> <li><p>重启容器</p> <div class="language-shell extra-class"><pre class="language-shell"><code>docker restart kibana
</code></pre></div></li></ol> <h4 id="访问地址-2"><a href="#访问地址-2" class="header-anchor">#</a> 访问地址</h4> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">http:</span>//&lt;IP&gt;:&lt;PORT&gt;
<span class="token header-name keyword">http:</span>//192.168.21.123:5601/
</code></pre></div><h3 id="es-健康检查"><a href="#es-健康检查" class="header-anchor">#</a> es 健康检查</h3> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">http:</span>//&lt;IP&gt;:9200/_cluster/health
<span class="token header-name keyword">http:</span>//192.168.21.123:9200/_cluster/health
</code></pre></div><h4 id="集群状态"><a href="#集群状态" class="header-anchor">#</a> 集群状态</h4> <ol><li><code>cluster_name</code>集群名称</li> <li><code>status</code>集群状态<code>green</code>代表健康；<code>yellow</code>代表分配了所有主分片，但至少缺少一个副本，此时集群数据仍旧完整；<code>red</code>代表部分主分片不可用，可能已经丢失数据。</li> <li><code>number_of_nodes</code>代表在线的节点总数量</li> <li><code>number_of_data_nodes</code>代表在线的数据节点的数量</li> <li><code>active_shards</code>存活的分片数量</li> <li><code>active_primary_shards</code>存活的主分片数量 正常情况下 <code>shards</code>的数量是<code>pri</code>的两倍</li> <li><code>relocating_shards</code>迁移中的分片数量，正常情况为 0</li> <li><code>initializing_shards</code>初始化中的分片数量，正常情况为 0</li> <li><code>unassigned_shards</code>未分配的分片，正常情况为 0</li> <li><code>delayed_unassigned_shards</code></li> <li><code>number_of_pending_tasks</code>，准备中的任务，任务指迁移分片等，正常情况为 0</li> <li><code>number_of_in_flight_fetch</code></li> <li><code>task_max_waiting_in_queue_millis</code>任务最长等待时间</li> <li><code>active_shards_percent_as_number</code>正常分片百分比 正常情况为 100%</li></ol> <h4 id="api"><a href="#api" class="header-anchor">#</a> API</h4> <ol><li><code>/_cat/allocation</code>      	#查看单节点的shard分配整体情况</li> <li><code>/_cat/shards</code>          	#查看各shard的详细情况</li> <li><code>/_cat/shards/{index}</code>  	#查看指定分片的详细情况</li> <li><code>/_cat/master</code>          	#查看master节点信息</li> <li><code>/_cat/nodes</code>           	#查看所有节点信息</li> <li><code>/_cat/indices</code>         	#查看集群中所有index的详细信息</li> <li><code>/_cat/indices/{index}</code> 	#查看集群中指定index的详细信息</li> <li><code>/_cat/segments</code>        	#查看各index的segment详细信息,包括segment名, 所属shard, 内存(磁盘)占用大小, 是否刷盘</li> <li><code>/_cat/segments/{index}</code>	#查看指定index的segment详细信息</li> <li><code>/_cat/count</code>           	#查看当前集群的doc数量</li> <li><code>/_cat/count/{index}</code>   	#查看指定索引的doc数量</li> <li><code>/_cat/recovery</code>        	#查看集群内每个shard的recovery过程.调整replica。</li> <li><code>/_cat/recovery/{index}</code>	#查看指定索引shard的recovery过程</li> <li><code>/_cat/health</code>          	#查看集群当前状态：红、黄、绿</li> <li><code>/_cat/pending_tasks</code>   	#查看当前集群的pending task</li> <li><code>/_cat/aliases</code>         	#查看集群中所有alias信息,路由配置等</li> <li><code>/_cat/aliases/{alias}</code> 	#查看指定索引的alias信息</li> <li><code>/_cat/thread_pool</code>     	#查看集群各节点内部不同类型的threadpool的统计信息,</li> <li><code>/_cat/plugins</code>         	#查看集群各个节点上的plugin信息</li> <li><code>/_cat/fielddata</code>       	#查看当前集群各个节点的fielddata内存使用情况</li> <li><code>/_cat/fielddata/{fields}</code>	#查看指定field的内存使用情况,里面传field属性对应的值</li> <li><code>/_cat/nodeattrs</code>			#查看单节点的自定义属性</li> <li><code>/_cat/repositories</code>		#输出集群中注册快照存储库</li> <li><code>/_cat/templates</code>			#输出当前正在存在的模板信息</li></ol> <h4 id="健康值状态"><a href="#健康值状态" class="header-anchor">#</a> 健康值状态</h4> <ol><li>Green：所有Primary和Replica均为active，集群健康</li> <li>Yellow：至少一个Replica不可用，但是所有Primary均为active，数据仍然是可以保证完整性的</li> <li>Red：至少有一个Primary为不可用状态，数据不完整，集群不可用</li></ol> <h2 id="es节点有哪些类型"><a href="#es节点有哪些类型" class="header-anchor">#</a> ES节点有哪些类型</h2> <h3 id="_1-主节点-master-node"><a href="#_1-主节点-master-node" class="header-anchor">#</a> 1. 主节点（Master node）</h3> <ol><li><p>主节点的主要职责是负责集群层面的相关操作，管理集群变更，如创建或删除索引，跟踪哪些节点是集群的一部分，并决定哪些分片分配给哪些相关的节点</p></li> <li><p>主节点也可以作为数据节点，但稳定的主节点对集群的健康是非常重要的，默认情况下任何一个集群中的节点都有可能被选为主节点，索引数据和搜索查询等操作会占用大量的cpu，内存，io资源，为了确保一个集群的稳定，分离主节点和数据节点是一个比较好的选择</p></li> <li><p>通过配置<code>node.master: true</code>(默认)使节点具有被选举为<code>Master</code>的资格。主节点是全局唯一的，从有资格成为<code>Master</code>的节点中选举</p></li> <li><p>为了防止数据丢失，每个主节点应该知道有资格升为主节点的数量，默认为1，为了避免网络分区出现多主的情况，配置<code>discovery.zen.minimun_master_nodes</code>原则上最小值应该为：<code>(master_eligible_nodes/2)+1</code></p></li> <li><div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
</code></pre></div></li></ol> <h3 id="_2-数据节点-data-node"><a href="#_2-数据节点-data-node" class="header-anchor">#</a> 2. 数据节点（Data node）</h3> <ol><li><p>数据节点主要是存储索引数据的节点，执行数据相关操作：CRUD、搜索，聚合操作等。数据节点对cpu，内存，I/O要求较高， 在优化的时候需要监控数据节点的状态，当资源不够的时候，需要在集群中添加新的节点。</p></li> <li><p>通过配置<code>node.data: true</code>(默认来是一个节点成为数据节点)，也可以通过下面配置创建一个数据节点</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">node.ingest</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
</code></pre></div></li></ol> <h3 id="_3-预处理节点-ingest-node"><a href="#_3-预处理节点-ingest-node" class="header-anchor">#</a> 3. 预处理节点（ingest node）</h3> <ol><li><p>这是从5.0版本开始引入的概念。预处理操作运行在索引文档之前，即写入数据之前，通过事先定义好的一系列<code>processors</code>(处理器)和<code>pipeline</code>（管道），对数据进行某种转换、富化。<code>processors</code>和<code>pipeline</code>拦截<code>bulk</code>和<code>index</code>请求，在应用相关操作后将文档传回给<code>index</code>或<code>bulk API</code></p></li> <li><p>默认情况下，在所有的节点启用<code>ingest</code>。如果想在某个节点上禁用<code>ingest</code>，则可以填写配置<code>node.ingest: false</code>，也可以通过下面的配置创建一个仅用于预处理的节点：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.ingest</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre></div></li></ol> <h3 id="_4-协调节点-coordinating-node"><a href="#_4-协调节点-coordinating-node" class="header-anchor">#</a> 4. 协调节点（Coordinating node）</h3> <ol><li><p>客户端请求可以发送到集群的任何节点，每个节点都知道任意文档所处的位置，然后转发这些请求，收集数据并返回给客户端，处理客户端请求的节点称为协调节点。</p></li> <li><p>协调节点将请求转发给保存数据的数据节点。每个数据节点在本地执行请求，并将结果返回给协调节点。协调节点收集完数据后，将每个数据节点的结果合并为单个全局结果。对结果收集和排序的过程可能需要很多CPU和内存资源。</p></li> <li><p>通过下面配置创建一个仅用于协调的节点：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.ingest</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
</code></pre></div></li></ol> <h3 id="_5-部落节点-trible-node"><a href="#_5-部落节点-trible-node" class="header-anchor">#</a> 5. 部落节点（Trible node）</h3> <ol><li><code>tribes</code>功能允许部落节点在多个集群之间充当联合客户端</li> <li>部落节点是一个单独的节点，其主要工作是嗅探远程集群的集群状态，并将它们合并在一起。为了做到这一点，它加入了所有的远程集群，使它成为一个非特殊的节点，它不属于自己的集群，而是加入了多个集群。</li> <li>也被称为<code>跨集群搜索</code>的功能，该功能<code>允许用户不仅跨本地索引，而且跨集群撰写搜索</code>。这意味着可以搜索属于其他远程集群的数据。</li></ol> <h3 id="_6-投票节点-voting-node"><a href="#_6-投票节点-voting-node" class="header-anchor">#</a> 6. 投票节点（voting node）</h3> <ol><li><code>node.voting_only: true</code>（仅投票节点，即使配置了<code>data.master: true</code>，也不会参选</li> <li>仍然可以作为数据节点<code>node.data: true</code></li></ol> <h2 id="es如何实现高可用"><a href="#es如何实现高可用" class="header-anchor">#</a> ES如何实现高可用</h2> <ol><li>ES在分配单个索引的分片时会将每个分片尽可能分配到更多的节点上。但是，实际情况取决于集群拥有的分片和索引的数量以及它们的大小，不一定总是能均匀地分布</li> <li>ES不允许Primary和它的Replica放在同一个节点中，并且同一个节点不接受完全相同的两个Replica</li> <li>同一个节点允许多个索引的分片同时存在</li></ol> <h2 id="es容错机制"><a href="#es容错机制" class="header-anchor">#</a> ES容错机制</h2> <ol><li>Master选举（假如宕机节点是Master）
<ul><li>脑裂：可能会产生多个Master节点</li> <li>解决：discovery.zen.minimum_master_nodes=N/2+1</li></ul></li> <li><code>Replica</code>容错，新的（或者原有）Master节点会将丢失的Primary对应的某个副本提升为Primary</li> <li>Master节点会尝试重启故障机</li> <li>数据同步，Master会将宕机期间丢失的数据同步到重启机器对应的分片上去</li></ol> <h2 id="如何提高es分布式系统的可用性及性能最大化"><a href="#如何提高es分布式系统的可用性及性能最大化" class="header-anchor">#</a> 如何提高ES分布式系统的可用性及性能最大化</h2> <ol><li>每台节点的<code>shard</code>数量越少，每个<code>shard</code>分配的CPU、内存和IO资源越多，单个<code>shard</code>的性能越好，当一台机器一个<code>shard</code>时，单个<code>shard</code>性能最好</li> <li>稳定的<code>Master节点</code>对于集群的健康非常重要！理论上讲，应该尽可能的减轻<code>Master节点</code>的压力，分片数量越多，<code>Master节点</code>维护管理<code>shard</code>的任务越重，并且节点可能就要承担更多的数据转发任务，可增加<code>仅协调节点</code>来缓解<code>Master节点</code>和<code>Data节点</code>的压力，但是在集群中添加过多的<code>仅协调节点</code>会增加整个集群的负担，因为选择的主节点必须等待每个节点的集群状态更新确认。</li> <li>反过来说，如果相同资源分配相同的前提下，<code>shard</code>数量越少，单个<code>shard</code>的体积越大，查询性能越低，速度越慢，这个取舍应根据实际集群状况和结合应用场景等因素综合考虑</li> <li><code>data节点</code>和<code>Master节点</code>一定要分开，集群规模越大，这样做的意义也就越大</li> <li><code>data节点</code>处理与数据相关的操作，例如<code>CRUD</code>，搜索和聚合。这些操作是<code>I/O</code>，内存和<code>CPU</code>密集型的，所以他们需要更高配置的服务器以及更高的带宽，并且集群的性能冗余非常重要</li> <li>由于<code>仅投票节</code>不参与<code>Master</code>竞选，所以和真正的<code>Master</code>节点相比，它需要的内存和CPU较少。但是，所有<code>候选节点</code>以及<code>仅投票节点</code>都可能是<code>数据节点</code>，所以他们都需要快速稳定低延迟的网络</li> <li>高可用性（HA）群集至少需要三个主节点，其中<code>至少两个不是仅投票节点</code>。即使其中一个节点发生故障，这样的群集也将能够选举一个主节点。生产环境最好设置3台仅Master候选节点（node.master = true	 node.data = true）</li> <li>为确保集群仍然可用，集群不能同时停止投票配置中的一半或更多节点。只要有一半以上的投票节点可用，集群仍可以正常工作。这意味着，如果存在三个或四个主节点合格的节点，则集群可以容忍其中一个节点不可用。如果有两个或更少的主机资格节点，则它们必须都保持可用</li></ol> <h2 id="master选举流程"><a href="#master选举流程" class="header-anchor">#</a> Master选举流程</h2> <h3 id="findmaster"><a href="#findmaster" class="header-anchor">#</a> findMaster</h3> <h2 id="简单curd"><a href="#简单curd" class="header-anchor">#</a> 简单CURD</h2> <h3 id="创建索引"><a href="#创建索引" class="header-anchor">#</a> 创建索引</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 格式</span>
PUT /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>?pretty
<span class="token comment"># demo</span>
PUT /product?pretty
</code></pre></div><h3 id="查询索引状态"><a href="#查询索引状态" class="header-anchor">#</a> 查询索引状态</h3> <div class="language-shell extra-class"><pre class="language-shell"><code>GET /_cat/indices?v
</code></pre></div><h3 id="删除索引"><a href="#删除索引" class="header-anchor">#</a> 删除索引</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 格式</span>
DELETE /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>?pretty
<span class="token comment"># demo</span>
DELETE /product?pretty
</code></pre></div><h3 id="查看索引信息"><a href="#查看索引信息" class="header-anchor">#</a> 查看索引信息</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 查看索引 map 映射信息</span>
GET /product
<span class="token comment"># 查看索引数据</span>
GET /product/_search
</code></pre></div><h3 id="插入数据"><a href="#插入数据" class="header-anchor">#</a> 插入数据</h3> <div class="language-shell extra-class"><pre class="language-shell"><code>PUT /product/_doc/1
<span class="token punctuation">{</span>
    <span class="token string">&quot;name&quot;</span> <span class="token builtin class-name">:</span> <span class="token string">&quot;xiaomi phone&quot;</span>,
    <span class="token string">&quot;desc&quot;</span> <span class="token builtin class-name">:</span>  <span class="token string">&quot;shouji zhong de zhandouji&quot;</span>,
    <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">3999</span>,
    <span class="token string">&quot;tags&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;xingjiabi&quot;</span>, <span class="token string">&quot;fashao&quot;</span>, <span class="token string">&quot;buka&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
PUT /product/_doc/2
<span class="token punctuation">{</span>
    <span class="token string">&quot;name&quot;</span> <span class="token builtin class-name">:</span> <span class="token string">&quot;xiaomi nfc phone&quot;</span>,
    <span class="token string">&quot;desc&quot;</span> <span class="token builtin class-name">:</span>  <span class="token string">&quot;zhichi quangongneng nfc,shouji zhong de jianjiji&quot;</span>,
    <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">4999</span>,
    <span class="token string">&quot;tags&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;xingjiabi&quot;</span>, <span class="token string">&quot;fashao&quot;</span>, <span class="token string">&quot;gongjiaoka&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
PUT /product/_doc/3
<span class="token punctuation">{</span>
    <span class="token string">&quot;name&quot;</span> <span class="token builtin class-name">:</span> <span class="token string">&quot;nfc phone&quot;</span>,
    <span class="token string">&quot;desc&quot;</span> <span class="token builtin class-name">:</span>  <span class="token string">&quot;shouji zhong de hongzhaji&quot;</span>,
    <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">2999</span>,
    <span class="token string">&quot;tags&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;xingjiabi&quot;</span>, <span class="token string">&quot;fashao&quot;</span>, <span class="token string">&quot;menjinka&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
PUT /product/_doc/4
<span class="token punctuation">{</span>
    <span class="token string">&quot;name&quot;</span> <span class="token builtin class-name">:</span> <span class="token string">&quot;xiaomi erji&quot;</span>,
    <span class="token string">&quot;desc&quot;</span> <span class="token builtin class-name">:</span>  <span class="token string">&quot;erji zhong de huangmenji&quot;</span>,
    <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">999</span>,
    <span class="token string">&quot;tags&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;low&quot;</span>, <span class="token string">&quot;bufangshui&quot;</span>, <span class="token string">&quot;yinzhicha&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
PUT /product/_doc/5
<span class="token punctuation">{</span>
    <span class="token string">&quot;name&quot;</span> <span class="token builtin class-name">:</span> <span class="token string">&quot;hongmi erji&quot;</span>,
    <span class="token string">&quot;desc&quot;</span> <span class="token builtin class-name">:</span>  <span class="token string">&quot;erji zhong de kendeji&quot;</span>,
    <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">399</span>,
    <span class="token string">&quot;tags&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;lowbee&quot;</span>, <span class="token string">&quot;xuhangduan&quot;</span>, <span class="token string">&quot;zhiliangx&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="查询数据"><a href="#查询数据" class="header-anchor">#</a> 查询数据</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 查询单个document</span>
<span class="token comment"># 格式</span>
GET /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>/_doc/<span class="token punctuation">{</span>id<span class="token punctuation">}</span>
<span class="token comment"># demo</span>
GET /product/_doc/1

<span class="token comment"># 查看所有的document</span>
<span class="token comment"># 格式</span>
GET /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>/_search
<span class="token comment"># demo</span>
GET /product/_search

<span class="token comment"># 查询多个结果的排序</span>
<span class="token comment"># 格式</span>
GET /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>/_search?sort<span class="token operator">=</span>排序的字段:<span class="token operator">&lt;</span>asc<span class="token operator">&gt;</span><span class="token operator">&lt;</span>desc<span class="token operator">&gt;</span>
<span class="token comment"># demo</span>
GET /product/_search?sort<span class="token operator">=</span>price
GET /product/_search?sort<span class="token operator">=</span>price:asc
GET /product/_search?sort<span class="token operator">=</span>price:desc
GET /product/_search?q<span class="token operator">=</span>price:2999<span class="token operator">&amp;</span><span class="token assign-left variable">sort</span><span class="token operator">=</span>price:desc
</code></pre></div><h3 id="更新数据"><a href="#更新数据" class="header-anchor">#</a> 更新数据</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 全量更新（完全覆盖）</span>
<span class="token comment"># 格式</span>
PUT /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>/_doc/<span class="token punctuation">{</span>id<span class="token punctuation">}</span>
json格式的数据

<span class="token comment"># demo</span>
PUT /product/_doc/1
<span class="token punctuation">{</span>
    <span class="token string">&quot;name&quot;</span> <span class="token builtin class-name">:</span> <span class="token string">&quot;xiaomi phone&quot;</span>,
    <span class="token string">&quot;desc&quot;</span> <span class="token builtin class-name">:</span>  <span class="token string">&quot;shouji zhong de zhandouji&quot;</span>,
    <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">3999</span>,
    <span class="token string">&quot;tags&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;xingjiabi&quot;</span>, <span class="token string">&quot;fashao&quot;</span>, <span class="token string">&quot;buka&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 增量更新</span>
<span class="token comment"># 格式</span>
POST /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>/_doc/<span class="token punctuation">{</span>id<span class="token punctuation">}</span>/_update
<span class="token punctuation">{</span>
    <span class="token string">&quot;doc&quot;</span><span class="token builtin class-name">:</span> json格式的数据
<span class="token punctuation">}</span>

<span class="token comment"># demo</span>
POST /product/_doc/1/_update
<span class="token punctuation">{</span>
    <span class="token string">&quot;doc&quot;</span>:<span class="token punctuation">{</span>
        <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">23999</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="删除数据"><a href="#删除数据" class="header-anchor">#</a> 删除数据</h3> <blockquote><p>先逻辑删除，没有立即删除，后续才会物理删除</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 格式</span>
DELETE /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>/_doc/<span class="token punctuation">{</span>id<span class="token punctuation">}</span>
<span class="token comment"># demo</span>
DELETE /product/_doc/1
</code></pre></div><h2 id="es-常用查询"><a href="#es-常用查询" class="header-anchor">#</a> ES 常用查询</h2> <h3 id="_1-search-timeout"><a href="#_1-search-timeout" class="header-anchor">#</a> 1. search timeout</h3> <ol><li>设置：默认没有<code>timeout</code>，如果设置了<code>timeout</code>，那么会执行<code>timeout</code>机制</li> <li><code>timeout</code>机制：假设用户查询结果有1W条数据，但是需要10s才能查询完毕，但是用户设置了1s的<code>timeout</code>，那么不管当前一共查询到了多少数据，都会在1s后停止查询，并返回当前数据</li> <li>用法：GET /product/_search?timeout=1s/ms/m</li></ol> <h3 id="_2-query-string"><a href="#_2-query-string" class="header-anchor">#</a> 2. query_string</h3> <ol><li>查询所有：GET /product/_search</li> <li>带参数：GET /product/_search?q=name:xiaomi</li> <li>分页+排序：GET /product/_search?from=0&amp;size=2&amp;sort=price:asc</li></ol> <h3 id="_3-match-all-匹配所有"><a href="#_3-match-all-匹配所有" class="header-anchor">#</a> 3. match_all：匹配所有</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  }
}
</code></pre></div><h3 id="_4-match-name中包含-nfc"><a href="#_4-match-name中包含-nfc" class="header-anchor">#</a> 4. match：name中包含“nfc”</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name&quot;: &quot;nfc&quot;
    }
  }
}
</code></pre></div><h3 id="_5-sort-按照加个倒序排序"><a href="#_5-sort-按照加个倒序排序" class="header-anchor">#</a> 5. sort：按照加个倒序排序</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;multi_match&quot;: {
      &quot;query&quot;: &quot;nfc&quot;,
      &quot;fields&quot;: [&quot;name&quot;,&quot;desc&quot;]
    }
  },
  &quot;sort&quot;: [
    {
      &quot;price&quot;: &quot;desc&quot;
    }
  ]
}
</code></pre></div><h3 id="_6-multi-match-根据多个字段查询一个关键词"><a href="#_6-multi-match-根据多个字段查询一个关键词" class="header-anchor">#</a> 6. multi_match：根据多个字段查询一个关键词</h3> <blockquote><p>name和desc中包含“nfc”</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;multi_match&quot;: {
      &quot;query&quot;: &quot;nfc&quot;,
      &quot;fields&quot;: [&quot;name&quot;,&quot;desc&quot;]
    }
  },
  &quot;sort&quot;: [
    {
      &quot;price&quot;: &quot;desc&quot;
    }
  ]
}
</code></pre></div><h3 id="_7-source-元数据-想要查询多个字段"><a href="#_7-source-元数据-想要查询多个字段" class="header-anchor">#</a> 7. _source：元数据，想要查询多个字段</h3> <blockquote><p>① 例子中为只查询“name”和“price”字段。</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;:{
    &quot;match&quot;: {
      &quot;name&quot;: &quot;nfc&quot;
    }
  },
  &quot;_source&quot;: [&quot;name&quot;,&quot;price&quot;]
}
</code></pre></div><h3 id="_8-分页-查询第一页-每页两条数据"><a href="#_8-分页-查询第一页-每页两条数据" class="header-anchor">#</a> 8. 分页：查询第一页（每页两条数据）</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  },
  &quot;sort&quot;: [
    {
      &quot;price&quot;: &quot;asc&quot;
    }
  ], 
  &quot;from&quot;: 0,
  &quot;size&quot;: 2
}
</code></pre></div><h3 id="_9-全文检索-term-不会被分词"><a href="#_9-全文检索-term-不会被分词" class="header-anchor">#</a> 9. 全文检索：term：不会被分词</h3> <blockquote><p>查询不会被分词，eq相等匹配倒排索引；文档内容会被分词，相当于eq的是倒排索引</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;name&quot;: &quot;nfc&quot;
    }
  }
}
GET /product/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;name&quot;: &quot;nfc phone&quot; 这里因为没有分词，所以查询没有结果
    }
  }
}
</code></pre></div><h3 id="_10-全文检索-match-会被分词"><a href="#_10-全文检索-match-会被分词" class="header-anchor">#</a> 10. 全文检索：match：会被分词</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name&quot;: &quot;xiaomi nfc zhineng phone&quot;
    }
  }
}
#验证分词
GET /_analyze 
{
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;:&quot;xiaomi nfc zhineng phone&quot;
}
</code></pre></div><h3 id="_11-短语搜索-match-phrase-和全文检索相反"><a href="#_11-短语搜索-match-phrase-和全文检索相反" class="header-anchor">#</a> 11. 短语搜索：match_phrase：和全文检索相反</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;match_phrase&quot;: {
      &quot;name&quot;: &quot;nfc phone&quot;
    }
  }
}
</code></pre></div><h3 id="_12-查询过滤"><a href="#_12-查询过滤" class="header-anchor">#</a> 12. 查询过滤</h3> <ol><li><code>bool</code>：可以<code>组合多个查询条件</code>，<code>bool</code>查询也是采用<code>more_matches_is_better</code>的机制，因此满足<code>must</code>和<code>should</code>子句的文档将会合并起来计算分值</li> <li><code>must</code>：<code>必须满足</code>（子查询必须出现在匹配的文档中，并将有助于得分）</li> <li><code>should</code>：<code>可能满足</code> <code>or</code>（子查询可能会出现在匹配的文档中）</li> <li><code>must_not</code>：<code>必须不满足</code> <code>不计算相关度分数</code> <code>not</code>（子查询不得出现在匹配的文档中，子句在过滤器上下文中执行，这意味着计分被忽略，并且子句被视为用于缓存）</li> <li><code>filter</code>：<code>过滤器</code> <code>不计算相关度分数</code>，<code>cache</code>（子查询必须出现在匹配的文档中，但是不像<code>must</code>查询的分数将忽略。<code>filter</code>子句在<code>filter</code>上下文中优先执行，这意味着计分被忽略，并且子句被考虑用于缓存）</li> <li><code>minimum_should_match</code>：参数指定<code>should</code>返回的文档必须匹配的子句的数量或百分比。如果<code>bool</code>查询包含至少一个<code>should</code>子句，而没有<code>must</code>或<code>filter</code>子句，则默认值为1。否则，默认值为0</li></ol> <h4 id="_1-bool单条件查询"><a href="#_1-bool单条件查询" class="header-anchor">#</a> 1. bool单条件查询</h4> <blockquote><p>首先筛选<code>name</code>包含<code>xiaomi phone</code>并且价格大于1999的数据（不排序），然后搜索<code>name</code>包含<code>xiaomi</code>and <code>desc</code> 包含<code>shouji</code></p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;:{
      &quot;must&quot;: [
        {&quot;match&quot;: { &quot;name&quot;: &quot;xiaomi&quot;}},
        {&quot;match&quot;: {&quot;desc&quot;: &quot;shouji&quot;}}
      ],
      &quot;filter&quot;: [
        {&quot;match_phrase&quot;:{&quot;name&quot;:&quot;xiaomi phone&quot;}},
        {&quot;range&quot;: {
          &quot;price&quot;: {
            &quot;gt&quot;: 1999
          }
        }}
      ]
    }
  }
}
</code></pre></div><h4 id="_2-bool多条件"><a href="#_2-bool多条件" class="header-anchor">#</a> 2. bool多条件</h4> <blockquote><p>name包含xiaomi 不包含erji 描述里包不包含nfc都可以，价钱要大于等于4999</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      # name中必须包含&quot;xiaomi&quot;
      &quot;must&quot;: [
        {
          &quot;match&quot;: {&quot;name&quot;: &quot;xiaomi&quot;}
        }
      ],
      # name中必须不能包含&quot;erji&quot;
      &quot;must_not&quot;: [
        {
          &quot;match&quot;: {&quot;name&quot;: &quot;erji&quot;}
        }
      ],
      # should中至少满足0个条件，参见下面的 minimum_should_match 的解释
      &quot;should&quot;: [
        {
          &quot;match&quot;: {&quot;desc&quot;: &quot;nfc&quot;}
        }
      ],
      # 筛选价格大于4999的doc
      &quot;filter&quot;: [
        {
          &quot;range&quot;: {
            &quot;price&quot;: {&quot;gt&quot;: 4999}
          }
        }
      ]
    }
  }
}
</code></pre></div><h4 id="_3-minimum-should-match的嵌套查询"><a href="#_3-minimum-should-match的嵌套查询" class="header-anchor">#</a> 3. minimum_should_match的嵌套查询</h4> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;:{
      &quot;must&quot;: [
        {&quot;match&quot;: { &quot;name&quot;: &quot;nfc&quot;}}
      ],
      &quot;should&quot;: [
        {&quot;range&quot;: {
          &quot;price&quot;: {&quot;gt&quot;:1999}
        }},
         {&quot;range&quot;: {
          &quot;price&quot;: {&quot;gt&quot;:3999}
        }}
      ],
      &quot;minimum_should_match&quot;: 1
    }
  }
}
# demo
GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: {
        &quot;bool&quot;: {
          &quot;should&quot;: [
            { &quot;range&quot;: {&quot;price&quot;: {&quot;gt&quot;: 1999}}},
            { &quot;range&quot;: {&quot;price&quot;: {&quot;gt&quot;: 3999}}}
          ],
          &quot;must&quot;: [
            { &quot;match&quot;: {&quot;name&quot;: &quot;nfc&quot;}}
          ]
        }
      }
    }
  }
}
</code></pre></div><blockquote><ol><li>当<code>bool</code>处在<code>query</code>上下文中时，如果<code>must</code>或者<code>filter</code>匹配了<code>doc</code>，那么<code>should</code>即便一条都不满足也可以召回<code>doc</code></li> <li>当<code>bool</code>处在父<code>bool</code>的<code>filter</code>上下文中时 或者 <code>bool</code>处在<code>query</code>上下文且没有<code>must</code>/<code>filter</code>子句的时候，<code>should</code>至少匹配1个才能召回<code>doc</code></li></ol> <p>如果需要类似这种查询：where name='nfc phone' and (price='2999' or desc='shouji zhong de hongzhaji')，就有2种做法：</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code># 走嵌套bool，让should进入filter上下文：
GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: [
        [
          {&quot;match_phrase&quot;: {&quot;name&quot;: &quot;nfc phone&quot;}},
          {&quot;term&quot;: {&quot;name&quot;: &quot;nfc&quot;}}
        ],
        {
          &quot;bool&quot;: {
            &quot;should&quot;: [
              { &quot;match_phrase&quot;: {&quot;price&quot;: &quot;2999&quot;}},
              { &quot;match_phrase&quot;: {&quot;desc&quot;: &quot;shouji zhong de hongzhaji&quot;}}
            ]
          }
        }
      ]
    }
  }
}
# 走单bool，query上下文，需要显式指定minimum_should_match=1
GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: [
        [
          {&quot;match_phrase&quot;: {&quot;name&quot;: &quot;nfc phone&quot;}},
          {&quot;term&quot;: {&quot;name&quot;: &quot;nfc&quot;}}
        ]
      ],
      &quot;should&quot;: [
        { &quot;match_phrase&quot;: {&quot;price&quot;: &quot;2999&quot;}},
        { &quot;match_phrase&quot;: {&quot;desc&quot;: &quot;shouji zhong de hongzhaji&quot;}}
      ],
      &quot;minimum_should_match&quot;: 1
    }
  }
}
# 其实作为一个可扩展的查询接口，一般来说嵌套bool表达力更丰富，扩展性更好，所以不建议用第二种方式开发业务
</code></pre></div><h4 id="_4-constant-score-不计算得分"><a href="#_4-constant-score-不计算得分" class="header-anchor">#</a> 4. constant_score：不计算得分</h4> <blockquote><p>当我们不关心检索词频率<code>TF</code>（<code>Term Frequency</code>）对搜索结果排序的影响时，可以使用<code>constant_score</code>将查询语句<code>query</code>或者过滤语句<code>filter</code>包装起来</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;:{
      &quot;filter&quot;: {
        &quot;bool&quot;: {
          &quot;should&quot;:[
            {&quot;term&quot;:{&quot;name&quot;:&quot;xiaomi&quot;}},
            {&quot;term&quot;:{&quot;name&quot;:&quot;nfc&quot;}}
            ],
          &quot;must_not&quot;:[
            {&quot;term&quot;:{&quot;name&quot;:&quot;erji&quot;}}
            ]
        }
      },
      &quot;boost&quot;: 1.2
    }
  }
}
</code></pre></div><h3 id="_13-compound-queries组合查询"><a href="#_13-compound-queries组合查询" class="header-anchor">#</a> 13. Compound queries组合查询</h3> <blockquote><p>想要一台带<code>NFC</code>功能的 或者 小米的手机 但是不要耳机</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> product <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token operator">like</span> <span class="token string">&quot;%xiaomi%&quot;</span> <span class="token operator">or</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token operator">like</span> <span class="token string">'%nfc%'</span><span class="token punctuation">)</span> <span class="token operator">AND</span> <span class="token punctuation">`</span>name<span class="token punctuation">`</span> <span class="token operator">not</span> <span class="token operator">LIKE</span> <span class="token string">'%erji%'</span>
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;:{
      &quot;filter&quot;: {
        &quot;bool&quot;: {
          &quot;should&quot;:[
            {&quot;term&quot;:{&quot;name&quot;:&quot;xiaomi&quot;}},
            {&quot;term&quot;:{&quot;name&quot;:&quot;nfc&quot;}}
            ],
          &quot;must_not&quot;:[
            {&quot;term&quot;:{&quot;name&quot;:&quot;erji&quot;}}
            ]
        }
      },
      &quot;boost&quot;: 1.2
    }
  }
}
</code></pre></div><blockquote><p>搜索一台xiaomi nfc phone或者一台满足 是一台手机 并且 价格小于等于2999</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> NAME <span class="token operator">LIKE</span> <span class="token string">'%xiaomi nfc phone%'</span> <span class="token operator">OR</span> <span class="token punctuation">(</span>NAME <span class="token operator">LIKE</span> <span class="token string">'%phone%'</span> <span class="token operator">AND</span> price <span class="token operator">&gt;</span> <span class="token number">399</span> <span class="token operator">AND</span> price <span class="token operator">&lt;=</span><span class="token number">999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;: {
      &quot;filter&quot;: { 
        &quot;bool&quot;:{
          &quot;should&quot;:[
            {
              &quot;match_phrase&quot;: {
                &quot;name&quot;:&quot;xiaomi nfc phone&quot;
              }
            },
            {
              &quot;bool&quot;:{
                &quot;must&quot;:[
                  {&quot;term&quot;:{&quot;name&quot;:&quot;phone&quot;}},
                  {&quot;range&quot;:{&quot;price&quot;:{&quot;lte&quot;:&quot;2999&quot;}}}
                  ]
              }
            }
          ]
        }
      }
    }
  }
}
</code></pre></div><h3 id="_14-highlight-search高亮查询"><a href="#_14-highlight-search高亮查询" class="header-anchor">#</a> 14. Highlight search高亮查询</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
    &quot;query&quot; : {
        &quot;match_phrase&quot; : {
            &quot;name&quot; : &quot;nfc phone&quot;
        }
    },
    &quot;highlight&quot;:{
      &quot;fields&quot;:{
         &quot;name&quot;:{}
      }
    }
}
</code></pre></div><h3 id="_15-deep-paging"><a href="#_15-deep-paging" class="header-anchor">#</a> 15. Deep paging</h3> <h4 id="_1-deep-paging概念"><a href="#_1-deep-paging概念" class="header-anchor">#</a> 1. deep paging概念</h4> <p><strong>查询的很深，比如一个索引有三个 <code>primary shard</code>，分别存储了<code>6000</code>条数据，我们要得到第<code>100</code>页的数据（每页<code>10</code>条），类似这种情况就叫<code>deep paging</code></strong></p> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  },
  &quot;sort&quot;: [
    {
      &quot;price&quot;: &quot;asc&quot;
    }
  ], 
  &quot;from&quot;: 0,
  &quot;size&quot;: 2
}
</code></pre></div><h4 id="_2-查询原理-如何得到第100页的10条数据"><a href="#_2-查询原理-如何得到第100页的10条数据" class="header-anchor">#</a> 2. 查询原理：如何得到第100页的10条数据？</h4> <h5 id="错误的做法"><a href="#错误的做法" class="header-anchor">#</a> 错误的做法</h5> <p>在每个 <code>shard</code> 中搜索<code>990</code>到<code>999</code>这<code>10</code>条数据，然后用这<code>30</code>条数据排序，排序之后取<code>10</code>条数据就是要搜索的数据，这种做法是错的；因为3个 <code>shard</code> 中的数据的 <code>_score</code> 分数不一样，可能这某一个 <code>shard</code> 中第一条数据的 <code>_score</code> 分数比另一个 <code>shard</code> 中第<code>1000</code>条都高，所以在每个 <code>shard</code> 中搜索<code>990</code>到<code>999</code>这<code>10</code>条数据然后排序的做法是不正确的。</p> <h5 id="正确的做法"><a href="#正确的做法" class="header-anchor">#</a> 正确的做法</h5> <p>正确的做法是每个 <code>shard</code> 把<code>0</code>到<code>999</code>条数据全部搜索出来（按排序顺序），然后全部返回给 <code>coordinate node</code>，由 <code>coordinate node</code> 按 <code>_score</code> 分数排序后，取出第<code>100</code>页的<code>10</code>条数据，然后返回给客户端</p> <p><img src="/images/elasticsearch-deep-paging.png" alt="elasticsearch-deep-paging"></p> <h4 id="_3-性能问题"><a href="#_3-性能问题" class="header-anchor">#</a> 3. 性能问题</h4> <ol><li>消耗网络带宽，因为所搜过深的话，各 <code>shard</code> 要把数据传递给 <code>coordinate node</code>，这个过程是有大量数据传递的，消耗网络</li> <li>消耗内存，各 <code>shard</code> 要把数据传送给 <code>coordinate node</code>，这个传递回来的数据，是被 <code>coordinate node</code> 保存在内存中的，这样会大量消耗内存</li> <li>消耗<code>cup</code>，<code>coordinate node</code> 要把传回来的数据进行排序，这个排序过程很消耗<code>cpu</code></li></ol> <h4 id="_4-结论"><a href="#_4-结论" class="header-anchor">#</a> 4. 结论</h4> <p><font color="red"><strong>鉴于deep paging的性能问题，所有应尽量减少使用</strong></font></p> <h3 id="_16-scroll-search"><a href="#_16-scroll-search" class="header-anchor">#</a> 16. Scroll search</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search?scroll=1m
{
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  },
  &quot;sort&quot;: [
    {
      &quot;price&quot;: &quot;desc&quot;
    }
  ],
  &quot;size&quot;: 2
}
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code>GET /_search/scroll
{
  # 每次查询更新scroll的时间，相当于延期
  &quot;scroll&quot;:&quot;1m&quot;
  &quot;scroll_id&quot;: &quot;&quot;
}
</code></pre></div><h4 id="_1-基于scroll滚动技术实现大数据量搜索"><a href="#_1-基于scroll滚动技术实现大数据量搜索" class="header-anchor">#</a> 1. 基于scroll滚动技术实现大数据量搜索</h4> <p><strong>如果一次性要查出来比如10万条数据，那么性能会很差，此时一般会采取用scroll滚动查询，一批一批的查，直到所有数据都查询完为止。</strong></p> <ol><li><p><code>scroll</code>搜索会在第一次搜索的时候，保存一个当时的视图快照，之后只会基于该旧的视图快照提供数据搜索，如果这个期间数据变更，是不会让用户看到的</p></li> <li><p>采用基于<code>_doc</code>（不使用<code>_score</code>）进行排序的方式，性能较高</p></li> <li><p>每次发送<code>scroll</code>请求，我们还需要指定一个<code>scroll</code>参数，指定一个<code>时间窗口</code>，每次搜索请求只要在这个事件窗口内能完成就可以了</p> <div class="language-http extra-class"><pre class="language-http"><code># sort默认是相关度排序（&quot;sort&quot;:[{&quot;FIELD&quot;:{&quot;order&quot;:&quot;desc&quot;}}]）,不按_score排序，按_doc排序
# size设置的是每页显示的记录数
# 第一次查询会生成快照
GET /lib3/user/_search?scroll=1m #这一批查询在一分钟内完成
{
	&quot;query&quot;:{
		&quot;match&quot;:{}
	},
	&quot;sort&quot;:[  
		&quot;_doc&quot;
	],
	&quot;size&quot;:3 
}
# 第二次查询通过第一次的快照ID来查询，后面以此类推
GET /_search/scroll
{
  &quot;scroll&quot;:&quot;1m&quot;, 
  &quot;scroll_id&quot;:&quot;&quot;
}
</code></pre></div></li></ol> <h4 id="_2-基于-scroll-解决深度分页问题"><a href="#_2-基于-scroll-解决深度分页问题" class="header-anchor">#</a> 2. 基于 scroll 解决深度分页问题</h4> <p><strong>原理上是对某次查询生成一个游标 <code>scroll_id</code> ， 后续的查询只需要根据这个游标去取数据，直到结果集中返回的 <code>hits</code> 字段为空，就表示遍历结束。</strong></p> <p><font color="red"><strong>注意</strong>：<code>scroll_id</code> 的生成可以理解为建立了一个临时的<code>历史快照</code>，在此之后的增删改查等操作不会影响到这个快照的结果。</font></p> <p>使用 curl 进行分页读取过程如下：</p> <ol><li>先获取第一个 scroll_id，url 参数包括 /index/_type/ 和 scroll，scroll 字段指定了scroll_id 的<strong>有效生存期，以分钟为单位，过期之后会被es 自动清理</strong>。如果文档不需要特定排序，可以指定按照文档创建的时间返回会使迭代更高效</li> <li>后续的文档读取上一次查询返回的<code>scroll_id</code> 来不断的取下一页，如果<code>srcoll_id</code> 的生存期很长，那么每次返回的 <code>scroll_id</code> 都是一样的，直到该 <code>scroll_id</code> 过期，才会返回一个新的 <code>scroll_id</code>。请求指定的 <code>scroll_id</code> 时就不需要 /index/_type 等信息了。每读取一页都会重新设置 <code>scroll_id</code> 的生存时间，所以这个时间只需要满足读取当前页就可以，不需要满足读取所有的数据的时间，1 分钟足以。</li> <li>所有文档获取完毕之后，需要手动清理掉 <code>scroll_id</code> 。虽然<code>es</code>会有自动清理机制，但是 <code>srcoll_id</code> 的存在会耗费大量的资源来保存一份当前查询结果集映像，并且会占用文件描述符。所以用完之后要及时清理。使用 <code>es</code> 提供的 <code>CLEAR_API</code> 来删除指定的 <code>scroll_id</code></li></ol> <h4 id="_3-基于-search-after-实现深度分页"><a href="#_3-基于-search-after-实现深度分页" class="header-anchor">#</a> 3. 基于 search_after 实现深度分页</h4> <p><code>search_after</code> 是 <code>ES5.0</code> 及之后版本提供的新特性，<code>search_after</code> 有点类似 <code>scroll</code>，但是和 <code>scroll</code> 又不一样，它提供一个活动的游标，通过上一次查询最后一条数据来进行下一次查询。<code>search_after</code> 分页的方式和 <code>scroll</code> 有一些显著的区别：首先它是<strong>根据上一页的最后一条数据来确定下一页的位置</strong>，同时在分页请求的过程中，如果有索引数据的增删改查，这些变更也会实时的反映到游标上。</p> <ol><li><p>第一页的请求和正常的请求一样</p> <div class="language-http extra-class"><pre class="language-http"><code>GET /order/info/_search
{
    &quot;size&quot;: 10,
    &quot;query&quot;: {
        &quot;match_all&quot; : {
        }
    },
    &quot;sort&quot;: [
        {&quot;date&quot;: &quot;asc&quot;}
    ]
}
# 返回结果
{
    &quot;_index&quot;: &quot;zmrecall&quot;,
    &quot;_type&quot;: &quot;recall&quot;,
    &quot;_id&quot;: &quot;60310505115909&quot;,
    &quot;_score&quot;: null,
    &quot;_source&quot;: {
      ...
      &quot;date&quot;: 1545037514
    },
    &quot;sort&quot;: [
    	1545037514
    ]
  }
</code></pre></div></li> <li><p>第二页的请求，使用第一页返回结果的最后一个数据的值，加上 <code>search_after</code> 字段来取下一页。<strong>注意</strong>：使用 <code>search_after</code> 的时候要将 <code>from</code> 置为 0 或 -1。</p> <div class="language-http extra-class"><pre class="language-http"><code>curl -XGET 127.0.0.1:9200/order/info/_search
{
    &quot;size&quot;: 10,
    &quot;query&quot;: {
        &quot;match_all&quot; : {
        }
    },
    &quot;search_after&quot;: [1545037514], # 这个值与上次查询最后一条数据的sort值一致，支持多个
    &quot;sort&quot;: [
        {&quot;date&quot;: &quot;asc&quot;}
    ]
}
</code></pre></div></li></ol> <h4 id="_4-需要注意的点"><a href="#_4-需要注意的点" class="header-anchor">#</a> 4. 需要注意的点</h4> <ol><li>如果 <code>search_after</code> 中的关键字为654，那么654323的文档也会被搜索到，所以在选择 <code>search_after</code> 的排序字段时需要谨慎，可以使用比如<code>文档的id</code>或者<code>时间戳</code>等</li> <li><code>search_after</code> <strong>适用于深度分页+ 排序</strong>，因为每一页的数据依赖于上一页最后一条数据，所以<strong>无法跳页请求</strong>。</li> <li>返回的始终是<strong>最新的数据</strong>，在分页过程中数据的位置可能会有变更。这种分页方式更加符合 <code>moa</code> 的业务场景</li></ol> <h4 id="_5-番外篇-moa业务场景"><a href="#_5-番外篇-moa业务场景" class="header-anchor">#</a> 5. 番外篇：MOA业务场景</h4> <ol><li>医疗大数据 看病更便捷</li> <li>金融大数据 赚钱更给力</li> <li>交通大数据 出行更方便</li> <li>环保大数据 治污更给力</li> <li>舆情大数据 网络管理利器</li></ol> <h3 id="_17-filter缓存原理"><a href="#_17-filter缓存原理" class="header-anchor">#</a> 17. filter缓存原理</h3> <h2 id="mapping"><a href="#mapping" class="header-anchor">#</a> Mapping</h2> <h3 id="_1-概念"><a href="#_1-概念" class="header-anchor">#</a> 1. 概念</h3> <p><code>mapping</code>就是<code>ES</code>数据字段<code>field</code>的<code>type</code>元数据，<code>ES</code>在创建索引的时候，<code>dynamic mapping</code>会自动为不同的数据指定相应<code>mapping</code>，<code>mapping</code>中包含了字段的类型、搜索方式（<code>exact value</code>或者<code>full text</code>）、分词器等。</p> <h3 id="_2-查看mapping"><a href="#_2-查看mapping" class="header-anchor">#</a> 2. 查看mapping</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_mappings
</code></pre></div><h3 id="_3-动态mapping"><a href="#_3-动态mapping" class="header-anchor">#</a> 3. 动态mapping</h3> <ol><li>Elasticsearch：text / keyword</li> <li>123456             =&gt;	long			？为什么不是integer</li> <li>123.123            =&gt;	double</li> <li>true false          =&gt;	boolean</li> <li>2020-05-20       =&gt;	date</li></ol> <blockquote><p><font color="red">为啥<code>123456</code>是<code>long</code>类型而不是<code>integer</code>？因为<code>es</code>的<code>mapping_type</code>是由<code>JSON</code>分析器检测数据类型，而<code>Json</code>没有隐式类型转换（<code>integer</code>=&gt;<code>long</code> or <code>float</code>=&gt; <code>double</code>），所以<code>dynamic mapping</code>会选择一个比较宽的数据类型。</font></p></blockquote> <h3 id="_4-搜索方式"><a href="#_4-搜索方式" class="header-anchor">#</a> 4. 搜索方式</h3> <ol><li>exact value 精确匹配：在倒排索引过程中，分词器会将<code>field</code>作为一个整体创建到索引中</li> <li>full text全文检索： 分词、近义词同义词、混淆词、大小写、词性、过滤、时态转换等</li></ol> <div class="language-http extra-class"><pre class="language-http"><code># 搜索所有字段包含de的doc
GET /product/_search?q=de
# 搜索name字段包含de的doc
GET /product/_search?q=name:de
# name.keyword 不会被分词，有点儿类似 match_phrase 短语搜索，eq文档doc的属性
GET /product/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name.keyword&quot;: &quot;xiaomi phone&quot;
    }
  }
}
GET /product/_search
{
  &quot;query&quot;: {
    &quot;match_phrase&quot;: {
      &quot;name&quot;: &quot;xiaomi phone&quot;
    }
  }
}
# 全文检索可能会搜索出多条结果 eq倒排索引
GET /product/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name&quot;: &quot;xiaomi phone&quot;
    }
  }
}
</code></pre></div><h3 id="_5-es数据类型"><a href="#_5-es数据类型" class="header-anchor">#</a> 5. ES数据类型</h3> <h4 id="_1-核心类型"><a href="#_1-核心类型" class="header-anchor">#</a> 1. 核心类型</h4> <ol><li><p>数字类型</p> <ul><li>long</li> <li>integer</li> <li>short</li> <li>byte</li> <li>double</li> <li>float</li> <li>half_float</li> <li>scaled_float</li> <li>在满足需求的情况下，尽可能选择范围小的数据类型</li></ul></li> <li><p>字符串</p> <ul><li><p>keyword：适用于索引结构化的字段，可以用于过滤、排序、聚合。<code>keyword</code>类型的字段只能通过精确值搜索列。ID应该用<code>keyword</code></p></li> <li><p>text：当一个字段是要被全文搜索的，比如<code>Email</code>内容、产品描述，这些字段应该使用<code>text</code>类型。设置<code>text</code>类型以后，字段内容会被分析，在生成倒排索引之前，字符串会被分析器分成一个一个词项。<code>text</code>类型的字段不用于排序，很少用于聚合。</p> <blockquote><p>解释一下为啥不会为<code>text</code>创建索引：字段数据会占用大量堆空间，尤其是在加载高基数<code>text</code>字段时。字段数据一旦加载到堆中，就在该段的生命周期内保持在那里。同样，加载字段数据是一个昂贵的过程，可能导致用户遇到延迟问题。这就是默认情况下禁用字段数据的原因。</p> <p>有时，在同一字段中同时具有全文本<code>text</code>和关键字<code>keyword</code>版本会很有用：一个用于全文本搜索，另一个用于聚合和排序</p></blockquote></li> <li><p>date（时间类型）：exact value</p></li> <li><p>boolean（布尔类型）</p></li> <li><p>binary（二进制）：binary</p></li> <li><p>range（区间类型）：integer_range、float_range、long_range、double_range、date_range</p></li></ul></li></ol> <h4 id="_2-复杂类型"><a href="#_2-复杂类型" class="header-anchor">#</a> 2. 复杂类型</h4> <ol><li>Object：用于单个JSON对象</li> <li>Nested：用于JSON对象数组</li></ol> <h4 id="_3-地理位置"><a href="#_3-地理位置" class="header-anchor">#</a> 3. 地理位置</h4> <ol><li>Geo-point：纬度 / 经度积分</li> <li>Geo-shape：用于多边形等复杂形状</li></ol> <h4 id="_4-特有类型"><a href="#_4-特有类型" class="header-anchor">#</a> 4. 特有类型</h4> <ol><li>IP地址：ip 用于IPv4和IPv6地址</li> <li>Completion：提供自动完成建议</li> <li>Tocken_count：计算字符串中令牌的数量</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/7.7/mapper-murmur3.html" target="_blank" rel="noopener noreferrer">Murmur3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：在索引时计算值的哈希并将其存储在索引中</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/7.7/mapper-annotated-text.html" target="_blank" rel="noopener noreferrer">Annotated-text<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：索引包含特殊标记的文本（通常用于标识命名实体）</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/percolator.html" target="_blank" rel="noopener noreferrer">Percolator<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：接受来自query-dsl的查询</li> <li>Join：为同一索引内的文档定义父/子关系</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rank-features.html" target="_blank" rel="noopener noreferrer">Rank features<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：记录数字功能以提高查询时的点击率。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dense-vector.html" target="_blank" rel="noopener noreferrer">Dense vector<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：记录浮点值的密集向量。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sparse-vector.html" target="_blank" rel="noopener noreferrer">Sparse vector<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：记录浮点值的稀疏向量。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-as-you-type.html" target="_blank" rel="noopener noreferrer">Search-as-you-type<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：针对查询优化的文本字段，以实现按需输入的完成</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/alias.html" target="_blank" rel="noopener noreferrer">Alias<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：为现有字段定义别名。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/flattened.html" target="_blank" rel="noopener noreferrer">Flattened<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：允许将整个JSON对象索引为单个字段。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/shape.html" target="_blank" rel="noopener noreferrer">Shape<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：shape 对于任意笛卡尔几何。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/histogram.html" target="_blank" rel="noopener noreferrer">Histogram<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：histogram 用于百分位数聚合的预聚合数值。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/constant-keyword.html" target="_blank" rel="noopener noreferrer">Constant keyword<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：keyword当所有文档都具有相同值时的情况的 专业化。</li></ol> <h4 id="_5-array-数组"><a href="#_5-array-数组" class="header-anchor">#</a> 5. Array（数组）</h4> <p>在Elasticsearch中，数组不需要专用的字段数据类型。默认情况下，任何字段都可以包含零个或多个值，但是，数组中的所有值都必须具有相同的数据类型。</p> <h4 id="_6-es7新增"><a href="#_6-es7新增" class="header-anchor">#</a> 6. ES7新增</h4> <ol><li>Date_nanos：date plus 纳秒</li> <li>Features：</li> <li>Vector：as</li></ol> <h3 id="_6-手工创建mapping"><a href="#_6-手工创建mapping" class="header-anchor">#</a> 6. 手工创建Mapping</h3> <div class="language-http extra-class"><pre class="language-http"><code>PUT /product
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
        &quot;field&quot;: {
          &quot;mapping_parameter&quot;: &quot;parameter_value&quot;
        }
      }
  }
}
</code></pre></div><h3 id="_7-mapping-parameters"><a href="#_7-mapping-parameters" class="header-anchor">#</a> 7. Mapping parameters</h3> <ol><li><p><code>index</code>：是否对创建对当前字段创建索引，默认true，如果不创建索引，该字段不会通过索引被搜索到，但是仍然会在<code>source</code>元数据中展示</p></li> <li><p><code>analyzer</code>：指定分析器（character filter、tokenizer、Token filters）。</p></li> <li><p><code>boost</code>：对当前字段相关度的评分权重，默认1</p></li> <li><p><code>coerce</code>：是否允许强制类型转换  true “1”=&gt; 1  false “1”=&lt; 1</p></li> <li><p><code>copy_to</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;field&quot;: {
   &quot;type&quot;: &quot;text&quot;,
   &quot;copy_to&quot;: &quot;other_field_name&quot; 
}
</code></pre></div></li> <li><p><code>doc_values</code>：为了提升排序和聚合效率，默认true，如果确定不需要对字段进行排序或聚合，也不需要通过脚本访问字段值，则可以禁用<code>doc</code>值以节省磁盘空间（不支持<code>text</code>和<code>annotated_text</code>）</p></li> <li><p><code>dynamic</code>：控制是否可以动态添加新字段</p> <ul><li>true 新检测到的字段将添加到映射中。（默认）</li> <li>false 新检测到的字段将被忽略。这些字段将不会被索引，因此将无法搜索，但仍会出现在_source返回的匹配项中。这些字段不会添加到映射中，必须显式添加新字段。</li> <li>strict 如果检测到新字段，则会引发异常并拒绝文档。必须将新字段显式添加到映射中</li></ul></li> <li><p><code>eager_global_ordinals</code>：用于聚合的字段上，优化聚合性能。</p> <ul><li><code>Frozen indices</code>（冻结索引）：有些索引使用率很高，会被保存在内存中，有些使用率特别低，宁愿在使用的时候重新创建，在使用完毕后丢弃数据，<code>Frozen indices</code>的数据命中频率小，不适用于高搜索负载，数据不会被保存在内存中，堆空间占用比普通索引少得多，<code>Frozen indices</code>是只读的，请求可能是秒级或者分钟级。<code>eager_global_ordinals</code>不适用于<code>Frozen indices</code></li></ul></li> <li><p><code>enable</code>：是否创建倒排索引，可以对字段操作，也可以对索引操作，如果不创建索引，仍然可以检索并在<code>_source</code>元数据中展示，谨慎使用，该状态无法修改。</p> <div class="language-http extra-class"><pre class="language-http"><code>PUT my_index 
{
  &quot;mappings&quot;: {
    &quot;enabled&quot;: false 
  }
}
PUT my_index
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;session_data&quot;: {
        &quot;type&quot;: &quot;object&quot;,
        &quot;enabled&quot;: false
      }
    }
  }
}
</code></pre></div><blockquote><p><font color="red"><strong>注意：enable只能在最顶层，并且type为object的时候设置才生效。</strong></font></p></blockquote></li> <li><p><code>fielddata</code>：查询时<code>内存</code>数据结构，在首次用当前字段聚合、排序或者在脚本中使用时，需要字段为<code>fielddata</code>数据结构，并且创建倒排索引保存到堆中</p></li> <li><p><code>fields</code>：给<code>field</code>创建多字段，用于不同目的（全文检索或者聚合分析排序）</p></li> <li><p><code>format</code>：格式化</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;date&quot;: {
      &quot;type&quot;:   &quot;date&quot;,
      &quot;format&quot;: &quot;yyyy-MM-dd&quot;
 }
</code></pre></div></li> <li><p><code>ignore_above</code>：超过长度将被忽略</p></li> <li><p><code>ignore_malformed</code>：忽略类型错误</p> <div class="language-http extra-class"><pre class="language-http"><code>PUT my_index{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;number_one&quot;: {
        &quot;type&quot;: &quot;integer&quot;,
        &quot;ignore_malformed&quot;: true
      },
      &quot;number_two&quot;: {
        &quot;type&quot;: &quot;integer&quot;
      }
    }
  }
}
PUT my_index/_doc/1{
  &quot;text&quot;:       &quot;Some text value&quot;,
  &quot;number_one&quot;: &quot;foo&quot;    //虽然有异常 但是不抛出
}
PUT my_index/_doc/2{
  &quot;text&quot;:       &quot;Some text value&quot;,
  &quot;number_two&quot;: &quot;foo&quot;   //数据格式不对	
}
</code></pre></div></li> <li><p><code>index_options</code>：控制将哪些信息添加到反向索引中以进行搜索和突出显示。仅用于<code>text</code>字段</p></li> <li><p><code>Index_phrases</code>：提升<code>exact_value</code>查询速度，但是要消耗更多磁盘空间</p></li> <li><p><code>Index_prefixes</code>：前缀搜索</p> <ol><li><p><code>min_chars</code>：前缀最小长度，&gt;0，默认2（包含）</p></li> <li><p><code>max_chars</code>：前缀最大长度，&lt;20，默认5（包含）</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;index_prefixes&quot;: {
	&quot;min_chars&quot; : 1,
	&quot;max_chars&quot; : 10
}	
</code></pre></div></li></ol></li> <li><p><code>meta</code>：附加元数据</p></li> <li><p><code>normalizer</code>：</p></li> <li><p><code>norms</code>：是否禁用评分（在<code>filter</code>和<code>聚合字段</code>上应该禁用）</p></li> <li><p><code>null_value</code>：为null值设置默认值（&quot;null_value&quot;: &quot;NULL&quot;）</p></li> <li><p><code>position_increment_gap</code>：</p></li> <li><p><code>proterties</code>：除了<code>mapping</code>还可用于<code>object</code>的属性设置</p></li> <li><p><code>search_analyzer</code>：设置单独的查询时分析器</p> <div class="language-http extra-class"><pre class="language-http"><code>PUT my_index{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;filter&quot;: {
        &quot;autocomplete_filter&quot;: {
          &quot;type&quot;: &quot;edge_ngram&quot;,
          &quot;min_gram&quot;: 1,
          &quot;max_gram&quot;: 20
        }
      },
      &quot;analyzer&quot;: {
        &quot;autocomplete&quot;: { 
          &quot;type&quot;: &quot;custom&quot;,
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;lowercase&quot;,
            &quot;autocomplete_filter&quot;
          ]
        }
      }
    }
  },
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;text&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;autocomplete&quot;, 
        &quot;search_analyzer&quot;: &quot;standard&quot; 
      }
    }
  }
}
PUT my_index/_doc/1{
  &quot;text&quot;: &quot;Quick Brown Fox&quot; 
}
GET my_index/_search{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;text&quot;: {
        &quot;query&quot;: &quot;Quick Br&quot;, 
        &quot;operator&quot;: &quot;and&quot;
      }
    }
  }
}
</code></pre></div></li> <li><p><code>similarity</code>：为字段设置相关度算法，支持<code>BM25</code>、<code>claassic（TF-IDF）</code>、<code>boolean</code></p></li> <li><p><code>store</code>：设置字段是否仅查询</p></li> <li><p><code>term_vector</code>：</p></li></ol></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">12/29/2020, 7:05:09 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/tiankafei-docs-架构/zookeeper学习笔记.html" class="prev">
        zookeeper学习笔记
      </a></span> <span class="next"><a href="/tiankafei-docs-架构/Tomcat源码分析.html">
        Tomcat源码分析
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0c8fedd9.js" defer></script><script src="/assets/js/2.01d54993.js" defer></script><script src="/assets/js/109.e00fbc70.js" defer></script>
  </body>
</html>
