<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Elasticsearch学习笔记 | tiankafei - java相关技术栈</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="自己写的一些东西的记录，包括代码与笔记，jdk最低支持1.8">
    
    <link rel="preload" href="/assets/css/0.styles.d6ad21ed.css" as="style"><link rel="preload" href="/assets/js/app.a9dae821.js" as="script"><link rel="preload" href="/assets/js/2.63c13255.js" as="script"><link rel="preload" href="/assets/js/108.b9cdff35.js" as="script"><link rel="prefetch" href="/assets/js/10.63a451e7.js"><link rel="prefetch" href="/assets/js/100.ffa5fdd6.js"><link rel="prefetch" href="/assets/js/101.f8810a98.js"><link rel="prefetch" href="/assets/js/102.dc5c5b06.js"><link rel="prefetch" href="/assets/js/103.2bbb57b2.js"><link rel="prefetch" href="/assets/js/104.0e06cbf9.js"><link rel="prefetch" href="/assets/js/105.80388754.js"><link rel="prefetch" href="/assets/js/106.efe79d8e.js"><link rel="prefetch" href="/assets/js/107.c315bce6.js"><link rel="prefetch" href="/assets/js/109.ef62cb54.js"><link rel="prefetch" href="/assets/js/11.723eb809.js"><link rel="prefetch" href="/assets/js/110.2178b947.js"><link rel="prefetch" href="/assets/js/111.0ad18f88.js"><link rel="prefetch" href="/assets/js/112.55c9a439.js"><link rel="prefetch" href="/assets/js/113.31ed11d3.js"><link rel="prefetch" href="/assets/js/12.54a5ae97.js"><link rel="prefetch" href="/assets/js/13.1e60f441.js"><link rel="prefetch" href="/assets/js/14.7f60d340.js"><link rel="prefetch" href="/assets/js/15.e2ad08cf.js"><link rel="prefetch" href="/assets/js/16.cb787676.js"><link rel="prefetch" href="/assets/js/17.6a7e1cc0.js"><link rel="prefetch" href="/assets/js/18.bcd99a51.js"><link rel="prefetch" href="/assets/js/19.d868c980.js"><link rel="prefetch" href="/assets/js/20.cd1d3aec.js"><link rel="prefetch" href="/assets/js/21.1cbdeb82.js"><link rel="prefetch" href="/assets/js/22.200922b5.js"><link rel="prefetch" href="/assets/js/23.7aaf2e55.js"><link rel="prefetch" href="/assets/js/24.68b66e3a.js"><link rel="prefetch" href="/assets/js/25.d3706361.js"><link rel="prefetch" href="/assets/js/26.60467ea8.js"><link rel="prefetch" href="/assets/js/27.c9d89620.js"><link rel="prefetch" href="/assets/js/28.04e72281.js"><link rel="prefetch" href="/assets/js/29.88491397.js"><link rel="prefetch" href="/assets/js/3.4c9060ec.js"><link rel="prefetch" href="/assets/js/30.049ea996.js"><link rel="prefetch" href="/assets/js/31.d8fa6176.js"><link rel="prefetch" href="/assets/js/32.64be24c1.js"><link rel="prefetch" href="/assets/js/33.50a4f525.js"><link rel="prefetch" href="/assets/js/34.984e4c0d.js"><link rel="prefetch" href="/assets/js/35.b5807b4d.js"><link rel="prefetch" href="/assets/js/36.b3552f1e.js"><link rel="prefetch" href="/assets/js/37.3d64ff94.js"><link rel="prefetch" href="/assets/js/38.ee6eb07d.js"><link rel="prefetch" href="/assets/js/39.ecb8e9fa.js"><link rel="prefetch" href="/assets/js/4.94733d25.js"><link rel="prefetch" href="/assets/js/40.53032794.js"><link rel="prefetch" href="/assets/js/41.74dc1c8b.js"><link rel="prefetch" href="/assets/js/42.c3123f54.js"><link rel="prefetch" href="/assets/js/43.eda3fce2.js"><link rel="prefetch" href="/assets/js/44.29d9a9c9.js"><link rel="prefetch" href="/assets/js/45.cc68a0a2.js"><link rel="prefetch" href="/assets/js/46.aa00e89a.js"><link rel="prefetch" href="/assets/js/47.3378a4d7.js"><link rel="prefetch" href="/assets/js/48.b964e43f.js"><link rel="prefetch" href="/assets/js/49.b1256dc5.js"><link rel="prefetch" href="/assets/js/5.2ea06e07.js"><link rel="prefetch" href="/assets/js/50.ee5ba818.js"><link rel="prefetch" href="/assets/js/51.1454b738.js"><link rel="prefetch" href="/assets/js/52.f804a4d4.js"><link rel="prefetch" href="/assets/js/53.a54e2f3a.js"><link rel="prefetch" href="/assets/js/54.978bb8ed.js"><link rel="prefetch" href="/assets/js/55.324e1abb.js"><link rel="prefetch" href="/assets/js/56.67def1c2.js"><link rel="prefetch" href="/assets/js/57.8efdacf3.js"><link rel="prefetch" href="/assets/js/58.a8a5419d.js"><link rel="prefetch" href="/assets/js/59.e6e825b3.js"><link rel="prefetch" href="/assets/js/6.8d81f0ec.js"><link rel="prefetch" href="/assets/js/60.1a8fb4b8.js"><link rel="prefetch" href="/assets/js/61.7803f21b.js"><link rel="prefetch" href="/assets/js/62.a79a20ee.js"><link rel="prefetch" href="/assets/js/63.c9821bae.js"><link rel="prefetch" href="/assets/js/64.54435ae4.js"><link rel="prefetch" href="/assets/js/65.4569f93a.js"><link rel="prefetch" href="/assets/js/66.4a50b72f.js"><link rel="prefetch" href="/assets/js/67.7c1b3a9b.js"><link rel="prefetch" href="/assets/js/68.218dfc69.js"><link rel="prefetch" href="/assets/js/69.b685730f.js"><link rel="prefetch" href="/assets/js/7.a054ba90.js"><link rel="prefetch" href="/assets/js/70.b64a7073.js"><link rel="prefetch" href="/assets/js/71.f59c809d.js"><link rel="prefetch" href="/assets/js/72.9f19043b.js"><link rel="prefetch" href="/assets/js/73.9afc612e.js"><link rel="prefetch" href="/assets/js/74.9db3e6cb.js"><link rel="prefetch" href="/assets/js/75.eb8c0c13.js"><link rel="prefetch" href="/assets/js/76.d2029c62.js"><link rel="prefetch" href="/assets/js/77.64d7f71a.js"><link rel="prefetch" href="/assets/js/78.87612624.js"><link rel="prefetch" href="/assets/js/79.665071de.js"><link rel="prefetch" href="/assets/js/8.95d6723a.js"><link rel="prefetch" href="/assets/js/80.0d287af5.js"><link rel="prefetch" href="/assets/js/81.b1ca2efe.js"><link rel="prefetch" href="/assets/js/82.70887aa9.js"><link rel="prefetch" href="/assets/js/83.01b5392f.js"><link rel="prefetch" href="/assets/js/84.45f0d71f.js"><link rel="prefetch" href="/assets/js/85.83aaf33d.js"><link rel="prefetch" href="/assets/js/86.fea15cee.js"><link rel="prefetch" href="/assets/js/87.d95cc309.js"><link rel="prefetch" href="/assets/js/88.23544aef.js"><link rel="prefetch" href="/assets/js/89.e048a592.js"><link rel="prefetch" href="/assets/js/9.d08f0e4c.js"><link rel="prefetch" href="/assets/js/90.f0b260f4.js"><link rel="prefetch" href="/assets/js/91.7d2be649.js"><link rel="prefetch" href="/assets/js/92.d09eb325.js"><link rel="prefetch" href="/assets/js/93.d29388bb.js"><link rel="prefetch" href="/assets/js/94.40904e43.js"><link rel="prefetch" href="/assets/js/95.c2dcf5bb.js"><link rel="prefetch" href="/assets/js/96.8661e51c.js"><link rel="prefetch" href="/assets/js/97.a1f2ef5f.js"><link rel="prefetch" href="/assets/js/98.07dab9bf.js"><link rel="prefetch" href="/assets/js/99.bbb5044b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d6ad21ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">tiankafei - java相关技术栈</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/tiankafei-docs-java/Java基础.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/tiankafei-docs-spring/spring学习笔记/" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/tiankafei-docs-架构/MySQL调优/" class="nav-link">
  架构
</a></div><div class="nav-item"><a href="/tiankafei-docs-大数据/centos7安装配置Hadoop/" class="nav-link">
  大数据
</a></div><div class="nav-item"><a href="/tiankafei-docs-linux/centos常用命令/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/tiankafei-docs-云/Centos7安装Docker并配置使用/" class="nav-link">
  云
</a></div><div class="nav-item"><a href="/tiankafei-docs-other/git命令/" class="nav-link">
  其他
</a></div><div class="nav-item"><a href="/tiankafei-docs-en/词性语法学习/" class="nav-link">
  英语
</a></div><div class="nav-item"><a href="https://github.com/tiankafei/tiankafei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/tiankafei-docs-java/Java基础.html" class="nav-link">
  Java
</a></div><div class="nav-item"><a href="/tiankafei-docs-spring/spring学习笔记/" class="nav-link">
  Spring
</a></div><div class="nav-item"><a href="/tiankafei-docs-架构/MySQL调优/" class="nav-link">
  架构
</a></div><div class="nav-item"><a href="/tiankafei-docs-大数据/centos7安装配置Hadoop/" class="nav-link">
  大数据
</a></div><div class="nav-item"><a href="/tiankafei-docs-linux/centos常用命令/" class="nav-link">
  Linux
</a></div><div class="nav-item"><a href="/tiankafei-docs-云/Centos7安装Docker并配置使用/" class="nav-link">
  云
</a></div><div class="nav-item"><a href="/tiankafei-docs-other/git命令/" class="nav-link">
  其他
</a></div><div class="nav-item"><a href="/tiankafei-docs-en/词性语法学习/" class="nav-link">
  英语
</a></div><div class="nav-item"><a href="https://github.com/tiankafei/tiankafei" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>架构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/tiankafei-docs-架构/MySQL调优.html" class="sidebar-link">MySQL调优</a></li><li><a href="/tiankafei-docs-架构/mysql主从复制安装配置.html" class="sidebar-link">mysql主从复制安装配置</a></li><li><a href="/tiankafei-docs-架构/使用amoeba实现mysql读写分离.html" class="sidebar-link">使用amoeba实现mysql读写分离</a></li><li><a href="/tiankafei-docs-架构/redis学习笔记.html" class="sidebar-link">redis介绍</a></li><li><a href="/tiankafei-docs-架构/zookeeper学习笔记.html" class="sidebar-link">zookeeper学习笔记</a></li><li><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html" class="active sidebar-link">Elasticsearch学习笔记</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#帮助文档" class="sidebar-link">帮助文档</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#中文官方文档-较老" class="sidebar-link">中文官方文档（较老）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#英文最新文档-较新" class="sidebar-link">英文最新文档（较新）</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es核心概念和原理" class="sidebar-link">ES核心概念和原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#什么是搜索" class="sidebar-link">什么是搜索</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#如何实现搜索功能" class="sidebar-link">如何实现搜索功能</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#倒排索引、lucene和全文检索" class="sidebar-link">倒排索引、Lucene和全文检索</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#倒排索引的特点" class="sidebar-link">倒排索引的特点</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#elasticsearch" class="sidebar-link">Elasticsearch</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-核心概念" class="sidebar-link">ES 核心概念</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#环境安装" class="sidebar-link">环境安装</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#docker-安装配置-es" class="sidebar-link">docker 安装配置 es</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#docker-安装配置-kibana" class="sidebar-link">docker 安装配置 kibana</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-健康检查" class="sidebar-link">es 健康检查</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es节点有哪些类型" class="sidebar-link">ES节点有哪些类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_1-主节点-master-node" class="sidebar-link">1. 主节点（Master node）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_2-数据节点-data-node" class="sidebar-link">2. 数据节点（Data node）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_3-预处理节点-ingest-node" class="sidebar-link">3. 预处理节点（ingest node）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_4-协调节点-coordinating-node" class="sidebar-link">4. 协调节点（Coordinating node）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_5-部落节点-trible-node" class="sidebar-link">5. 部落节点（Trible node）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_6-投票节点-voting-node" class="sidebar-link">6. 投票节点（voting node）</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es如何实现高可用" class="sidebar-link">ES如何实现高可用</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es容错机制" class="sidebar-link">ES容错机制</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#如何提高es分布式系统的可用性及性能最大化" class="sidebar-link">如何提高ES分布式系统的可用性及性能最大化</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#master选举流程" class="sidebar-link">Master选举流程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#findmaster" class="sidebar-link">findMaster</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#简单curd" class="sidebar-link">简单CURD</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#创建索引" class="sidebar-link">创建索引</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#查询索引状态" class="sidebar-link">查询索引状态</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#删除索引" class="sidebar-link">删除索引</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#查看索引信息" class="sidebar-link">查看索引信息</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#插入数据" class="sidebar-link">插入数据</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#查询数据" class="sidebar-link">查询数据</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#更新数据" class="sidebar-link">更新数据</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#删除数据" class="sidebar-link">删除数据</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-常用查询" class="sidebar-link">ES 常用查询</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_1-search-timeout" class="sidebar-link">1. search timeout</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_2-query-string" class="sidebar-link">2. query_string</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_3-match-all-匹配所有" class="sidebar-link">3. match_all：匹配所有</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_4-match-name中包含-nfc" class="sidebar-link">4. match：name中包含“nfc”</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_5-sort-按照加个倒序排序" class="sidebar-link">5. sort：按照加个倒序排序</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_6-multi-match-根据多个字段查询一个关键词" class="sidebar-link">6. multi_match：根据多个字段查询一个关键词</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_7-source-元数据-想要查询多个字段" class="sidebar-link">7. _source：元数据，想要查询多个字段</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_8-分页-查询第一页-每页两条数据" class="sidebar-link">8. 分页：查询第一页（每页两条数据）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_9-全文检索-term-不会被分词" class="sidebar-link">9. 全文检索：term：不会被分词</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_10-全文检索-match-会被分词" class="sidebar-link">10. 全文检索：match：会被分词</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_11-短语搜索-match-phrase-和全文检索相反" class="sidebar-link">11. 短语搜索：match_phrase：和全文检索相反</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_12-查询过滤" class="sidebar-link">12. 查询过滤</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_13-compound-queries组合查询" class="sidebar-link">13. Compound queries组合查询</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_14-highlight-search高亮查询" class="sidebar-link">14. Highlight search高亮查询</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_15-deep-paging" class="sidebar-link">15. Deep paging</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_16-scroll-search" class="sidebar-link">16. Scroll search</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_17-filter缓存原理" class="sidebar-link">17. filter缓存原理</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-查询相关" class="sidebar-link">ES 查询相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_1-前缀搜索" class="sidebar-link">1. 前缀搜索</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_2-通配符搜索" class="sidebar-link">2. 通配符搜索</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_3-正则搜索" class="sidebar-link">3. 正则搜索</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_4-模糊搜索-fuzzy" class="sidebar-link">4. 模糊搜索：fuzzy</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_5-match-phrase-prefix讲解" class="sidebar-link">5. matchphraseprefix讲解</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-查询总结" class="sidebar-link">ES 查询总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#match、term、match-phrase、query-string的区别" class="sidebar-link">match、term、matchphrase、querystring的区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#mapping" class="sidebar-link">Mapping</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_1-概念" class="sidebar-link">1. 概念</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_2-查看mapping" class="sidebar-link">2. 查看mapping</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_3-动态mapping" class="sidebar-link">3. 动态mapping</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_4-搜索方式" class="sidebar-link">4. 搜索方式</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_5-es数据类型" class="sidebar-link">5. ES数据类型</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_6-手工创建mapping" class="sidebar-link">6. 手工创建Mapping</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_7-mapping-parameters" class="sidebar-link">7. Mapping parameters</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#聚合查询" class="sidebar-link">聚合查询</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_1-bucket-和-metirc-group-by" class="sidebar-link">1. bucket 和 metirc == group by</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_2-语法" class="sidebar-link">2. 语法</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_3-以tag维度每个产品的数量-即每个标签" class="sidebar-link">3. 以tag维度每个产品的数量，即每个标签</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_4-在-3-的基础上增加-价格大于1999的数据" class="sidebar-link">4. 在 3 的基础上增加：价格大于1999的数据</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_5-价格大于1999的每个tag产品的平均价格" class="sidebar-link">5. 价格大于1999的每个tag产品的平均价格</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_6-自定义聚合" class="sidebar-link">6. 自定义聚合</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_7-mget-批量查询" class="sidebar-link">7. mget：批量查询</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_8-bulk-批量增删改" class="sidebar-link">8. bulk：批量增删改</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_9-es-并发冲突问题" class="sidebar-link">9. ES 并发冲突问题</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es底层原理" class="sidebar-link">ES底层原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#图解正排索引和倒排索引" class="sidebar-link">图解正排索引和倒排索引</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#正排索引doc-values和倒排索引的区别" class="sidebar-link">正排索引doc_values和倒排索引的区别</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#正排索引doc-values和fielddata" class="sidebar-link">正排索引doc_values和fielddata</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-流程核心概念" class="sidebar-link">ES 流程核心概念</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-写流程" class="sidebar-link">ES 写流程</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-scripting" class="sidebar-link">ES Scripting</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_1-使用script执行更新操作" class="sidebar-link">1. 使用script执行更新操作</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_2-使用script执行脚本命令" class="sidebar-link">2. 使用script执行脚本命令</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_3-使用script执行删除操作" class="sidebar-link">3. 使用script执行删除操作</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_4-使用script执行插入更新操作" class="sidebar-link">4. 使用script执行插入更新操作</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_5-使用script执行-bulk-操作" class="sidebar-link">5. 使用script执行 _bulk 操作</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_6-script的其他语言支持" class="sidebar-link">6. script的其他语言支持</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_7-script脚本语言性能比较" class="sidebar-link">7. script脚本语言性能比较</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_8-script多脚本支持" class="sidebar-link">8. script多脚本支持</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_9-stored-scripts-script模板" class="sidebar-link">9. Stored scripts：script模板</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_10-dates-日期的使用" class="sidebar-link">10. Dates：日期的使用</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_11-script正则表达式的支持" class="sidebar-link">11. script正则表达式的支持</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_12-使用script进行聚合查询" class="sidebar-link">12. 使用script进行聚合查询</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#_13-script关于上下文件对象" class="sidebar-link">13. script关于上下文件对象</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#分词器" class="sidebar-link">分词器</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#作用" class="sidebar-link">作用</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#分析器" class="sidebar-link">分析器</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-内置分词器-7-6有15种自带分词器" class="sidebar-link">ES 内置分词器（7.6有15种自带分词器）</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#自定义分析器" class="sidebar-link">自定义分析器</a></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#中文分词器" class="sidebar-link">中文分词器</a></li></ul></li><li class="sidebar-sub-header"><a href="/tiankafei-docs-架构/elasticsearch学习笔记.html#es-java-api" class="sidebar-link">ES Java API</a></li></ul></li><li><a href="/tiankafei-docs-架构/Tomcat源码分析.html" class="sidebar-link">Tomcat源码分析</a></li><li><a href="/tiankafei-docs-架构/Netty源码分析.html" class="sidebar-link">Netty源码分析</a></li><li><a href="/tiankafei-docs-架构/分布式架构.html" class="sidebar-link">分布式架构</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="elasticsearch学习笔记"><a href="#elasticsearch学习笔记" class="header-anchor">#</a> Elasticsearch学习笔记</h1> <h2 id="帮助文档"><a href="#帮助文档" class="header-anchor">#</a> 帮助文档</h2> <h3 id="中文官方文档-较老"><a href="#中文官方文档-较老" class="header-anchor">#</a> 中文官方文档（较老）</h3> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">https</span><span class="token punctuation">:</span><span class="token header-value">//www.elastic.co/guide/cn/elasticsearch/guide/current/getting-started.html#getting-started</span></span>
</code></pre></div><h3 id="英文最新文档-较新"><a href="#英文最新文档-较新" class="header-anchor">#</a> 英文最新文档（较新）</h3> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">https</span><span class="token punctuation">:</span><span class="token header-value">//www.elastic.co/guide/en/elasticsearch/reference/7.10/getting-started.html</span></span>
</code></pre></div><h2 id="es核心概念和原理"><a href="#es核心概念和原理" class="header-anchor">#</a> ES核心概念和原理</h2> <h3 id="什么是搜索"><a href="#什么是搜索" class="header-anchor">#</a> 什么是搜索</h3> <p>百度、垂直搜索（站内搜索）。搜索：通过一个<strong>关键词</strong>或一段描述，得到你想要（相关度高）的结果</p> <h3 id="如何实现搜索功能"><a href="#如何实现搜索功能" class="header-anchor">#</a> 如何实现搜索功能</h3> <p>关系型数据库：性能差、不可靠、结果不准确（相关度低）</p> <h3 id="倒排索引、lucene和全文检索"><a href="#倒排索引、lucene和全文检索" class="header-anchor">#</a> 倒排索引、<code>Lucene</code>和全文检索</h3> <ol><li>倒排索引的数据结构（存储的数据）
<ol><li>包含这个关键词的<code>document list</code></li> <li>关键词在每个doc中出现的次数<code>TF term frequency</code></li> <li>关键词在整个索引中出现的次数<code>IDF inverse doc frequency</code>（值越大，代表相关度越低）</li> <li>关键词在当前<code>doc</code>中出现的次数</li> <li>每个<code>doc</code>的长度，越长相关度越低</li> <li>包含这个关键词的所有<code>doc</code>的平均长度</li></ol></li> <li><code>Lucene</code>：<code>jar</code>包，帮我们创建倒排索引，提供了复杂的<code>API</code></li> <li>如果用<code>Luncene</code>做集群，会有哪些问题
<ul><li>节点一旦宕机，节点数据丢失，后果不堪设想，可用性差</li> <li>自己维护，麻烦（自己创建管理索引），单台节点的承载请求的能里是有限的，需要人工做负载。</li></ul></li></ol> <p><img src="/images/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.png" alt="倒排索引"></p> <h3 id="倒排索引的特点"><a href="#倒排索引的特点" class="header-anchor">#</a> 倒排索引的特点</h3> <ol><li>倒排索引的数据量 &gt; 原始数据量</li> <li>倒排索引做的是完全匹配，不需要全表扫描</li> <li>倒排索引记录着这个词出现在原始数据的那个主键，根据主键去原始数据中查询是很快的</li></ol> <h3 id="elasticsearch"><a href="#elasticsearch" class="header-anchor">#</a> Elasticsearch</h3> <ol><li>特点
<ul><li>分布式</li> <li>高性能</li> <li>高可用</li> <li>可伸缩</li> <li>易维护</li></ul></li> <li>优点
<ul><li>面向开发者友好，屏蔽了Lucene的复杂特性，集群自动发现（cluster discovery）</li> <li>自动维护数据在多个节点上的建立</li> <li>会帮我们做搜索请求的负载均衡</li> <li>自动维护冗余副本，保证了部分节点宕机的情况下仍然不会有任何数据丢失</li> <li><code>ES</code>基于<code>Lucene</code>提供了很多高级功能：复合查询、聚合分析、基于地理位置等</li> <li>对于大公司，可以构建几百台服务器的大型分布式集群，处理PB级别数据；对于小公司，开箱即用，门槛低上手简单</li> <li>相比传统数据库，提供了全文检索，同义词处理（美丽的 cls &gt; 漂亮的 cls），相关度排名。聚合分析以及海量数据的近实时（NTR）处理，这些传统数据库完全做不到</li></ul></li> <li>应用领域
<ul><li>百度（全文检索，高亮、搜索推荐）</li> <li>各大网站的用户行为日志（用户点击、浏览、收藏、评论）</li> <li>BI（business Intelligence商业智能），数据分析，数据挖掘统计</li> <li>Github：代码托管平台，几千亿行代码</li> <li>ELK：Elasticsearch（数据存储）、Logstash（日志采集）、Kibana（可视化）</li></ul></li></ol> <h3 id="es-核心概念"><a href="#es-核心概念" class="header-anchor">#</a> ES 核心概念</h3> <ol><li><code>cluster</code>（集群）：每个集群至少包含两个节点</li> <li><code>node</code>：集群中的每个节点，一个节点不代表一台服务器</li> <li><code>field</code>：一个数据字段，与<code>index</code>和<code>type</code>一起，可以定位一个<code>doc</code></li> <li><code>document</code>：<code>es</code>最小的数据单元，通常是以<code>json</code>的形式存储的</li> <li><code>type</code>：逻辑上的数据分类，<code>es7.x</code>中删除了<code>type</code>的概念</li> <li><code>index</code>：一类相同或者类似的<code>doc</code>，比如一个员工索引，商品索引</li> <li><code>shard</code>分片：P分片，R副本
<ul><li>一个<code>index</code>包含多个<code>shard</code>，默认5个分片，默认每个分片分配一个副本，分片的数量在创建索引的时候设置，如果想修改，需要重建索引</li> <li>每个<code>shard</code>都是一个<code>lucene</code>实例，有完整的创建索引的处理请求能力</li> <li>es会自动在<code>nodes</code>上为我们做<code>shard</code>均衡</li> <li>一个<code>doc</code>是不可能同时存在与多个分片中的，但是可以存在于多个副本中</li> <li>分片和对应的副本不能同时存在于同一个节点，所以最低的可用配置是两个节点，互为主备</li></ul></li></ol> <h2 id="环境安装"><a href="#环境安装" class="header-anchor">#</a> 环境安装</h2> <h3 id="docker-安装配置-es"><a href="#docker-安装配置-es" class="header-anchor">#</a> docker 安装配置 es</h3> <h4 id="拉取镜像"><a href="#拉取镜像" class="header-anchor">#</a> 拉取镜像</h4> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">docker</span> pull elasticsearch:7.6.2
</code></pre></div><h4 id="启动es"><a href="#启动es" class="header-anchor">#</a> 启动es</h4> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">9200</span>:9200 <span class="token parameter variable">-p</span> <span class="token number">9300</span>:9300 <span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token parameter variable">-e</span> <span class="token string">&quot;discovery.type=single-node&quot;</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>elasticsearch elasticsearch:7.6.2
</code></pre></div><h4 id="修改配置"><a href="#修改配置" class="header-anchor">#</a> 修改配置</h4> <ol><li><p>进入容器</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> elasticsearch <span class="token function">bash</span>
</code></pre></div></li> <li><p>vim config/elasticsearch.yml</p> <div class="language-shell extra-class"><pre class="language-shell"><code>cluster.name: <span class="token string">&quot;my-application&quot;</span>
node.name: <span class="token string">&quot;node-1&quot;</span>
network.host: <span class="token number">0.0</span>.0.0
</code></pre></div></li> <li><p>重启容器</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">docker</span> restart elasticsearch
</code></pre></div></li></ol> <h4 id="访问地址"><a href="#访问地址" class="header-anchor">#</a> 访问地址</h4> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">http</span><span class="token punctuation">:</span><span class="token header-value">//&lt;IP&gt;:&lt;PORT&gt;</span></span>
<span class="token header"><span class="token header-name keyword">http</span><span class="token punctuation">:</span><span class="token header-value">//192.168.21.123:9200/</span></span>
</code></pre></div><h3 id="docker-安装配置-kibana"><a href="#docker-安装配置-kibana" class="header-anchor">#</a> docker 安装配置 kibana</h3> <h4 id="拉取镜像-2"><a href="#拉取镜像-2" class="header-anchor">#</a> 拉取镜像</h4> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">docker</span> pull kibana:7.6.2
</code></pre></div><h4 id="启动kibana"><a href="#启动kibana" class="header-anchor">#</a> 启动kibana</h4> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">5601</span>:5601 <span class="token parameter variable">--restart</span><span class="token operator">=</span>always <span class="token parameter variable">--name</span> kibana kibana:7.6.2
</code></pre></div><h4 id="出现的问题修改配置"><a href="#出现的问题修改配置" class="header-anchor">#</a> 出现的问题修改配置</h4> <ol><li><p>如果出现以下页面：Kibana server is not ready yet，说明Kibana没有找到ES节点</p></li> <li><p>进入容器</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> kibana <span class="token function">bash</span>
</code></pre></div></li> <li><p>vim config/kibana.yml</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token comment">#</span>
<span class="token comment"># ** THIS IS AN AUTO-GENERATED FILE **</span>
<span class="token comment">#</span>

<span class="token comment"># Default Kibana configuration for docker target</span>
<span class="token key atrule">server.name</span><span class="token punctuation">:</span> kibana
<span class="token key atrule">server.host</span><span class="token punctuation">:</span> <span class="token string">&quot;0&quot;</span>
<span class="token comment"># 中文配置</span>
<span class="token key atrule">i18n.locale</span><span class="token punctuation">:</span> <span class="token string">&quot;zh-CN&quot;</span>
<span class="token key atrule">elasticsearch.hosts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;http://192.168.21.123:9200&quot;</span> <span class="token punctuation">]</span>
<span class="token key atrule">xpack.monitoring.ui.container.elasticsearch.enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre></div></li> <li><p>重启容器</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">docker</span> restart kibana
</code></pre></div></li></ol> <h4 id="访问地址-2"><a href="#访问地址-2" class="header-anchor">#</a> 访问地址</h4> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">http</span><span class="token punctuation">:</span><span class="token header-value">//&lt;IP&gt;:&lt;PORT&gt;</span></span>
<span class="token header"><span class="token header-name keyword">http</span><span class="token punctuation">:</span><span class="token header-value">//192.168.21.123:5601/</span></span>
</code></pre></div><h3 id="es-健康检查"><a href="#es-健康检查" class="header-anchor">#</a> es 健康检查</h3> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header"><span class="token header-name keyword">http</span><span class="token punctuation">:</span><span class="token header-value">//&lt;IP&gt;:9200/_cluster/health</span></span>
<span class="token header"><span class="token header-name keyword">http</span><span class="token punctuation">:</span><span class="token header-value">//192.168.21.123:9200/_cluster/health</span></span>
</code></pre></div><h4 id="集群状态"><a href="#集群状态" class="header-anchor">#</a> 集群状态</h4> <ol><li><code>cluster_name</code>集群名称</li> <li><code>status</code>集群状态<code>green</code>代表健康；<code>yellow</code>代表分配了所有主分片，但至少缺少一个副本，此时集群数据仍旧完整；<code>red</code>代表部分主分片不可用，可能已经丢失数据。</li> <li><code>number_of_nodes</code>代表在线的节点总数量</li> <li><code>number_of_data_nodes</code>代表在线的数据节点的数量</li> <li><code>active_shards</code>存活的分片数量</li> <li><code>active_primary_shards</code>存活的主分片数量 正常情况下 <code>shards</code>的数量是<code>pri</code>的两倍</li> <li><code>relocating_shards</code>迁移中的分片数量，正常情况为 0</li> <li><code>initializing_shards</code>初始化中的分片数量，正常情况为 0</li> <li><code>unassigned_shards</code>未分配的分片，正常情况为 0</li> <li><code>delayed_unassigned_shards</code></li> <li><code>number_of_pending_tasks</code>，准备中的任务，任务指迁移分片等，正常情况为 0</li> <li><code>number_of_in_flight_fetch</code></li> <li><code>task_max_waiting_in_queue_millis</code>任务最长等待时间</li> <li><code>active_shards_percent_as_number</code>正常分片百分比 正常情况为 100%</li></ol> <h4 id="api"><a href="#api" class="header-anchor">#</a> API</h4> <ol><li><code>/_cat/allocation</code>      	#查看单节点的shard分配整体情况</li> <li><code>/_cat/shards</code>          	#查看各shard的详细情况</li> <li><code>/_cat/shards/{index}</code>  	#查看指定分片的详细情况</li> <li><code>/_cat/master</code>          	#查看master节点信息</li> <li><code>/_cat/nodes</code>           	#查看所有节点信息</li> <li><code>/_cat/indices</code>         	#查看集群中所有index的详细信息</li> <li><code>/_cat/indices/{index}</code> 	#查看集群中指定index的详细信息</li> <li><code>/_cat/segments</code>        	#查看各index的segment详细信息,包括segment名, 所属shard, 内存(磁盘)占用大小, 是否刷盘</li> <li><code>/_cat/segments/{index}</code>	#查看指定index的segment详细信息</li> <li><code>/_cat/count</code>           	#查看当前集群的doc数量</li> <li><code>/_cat/count/{index}</code>   	#查看指定索引的doc数量</li> <li><code>/_cat/recovery</code>        	#查看集群内每个shard的recovery过程.调整replica。</li> <li><code>/_cat/recovery/{index}</code>	#查看指定索引shard的recovery过程</li> <li><code>/_cat/health</code>          	#查看集群当前状态：红、黄、绿</li> <li><code>/_cat/pending_tasks</code>   	#查看当前集群的pending task</li> <li><code>/_cat/aliases</code>         	#查看集群中所有alias信息,路由配置等</li> <li><code>/_cat/aliases/{alias}</code> 	#查看指定索引的alias信息</li> <li><code>/_cat/thread_pool</code>     	#查看集群各节点内部不同类型的threadpool的统计信息,</li> <li><code>/_cat/plugins</code>         	#查看集群各个节点上的plugin信息</li> <li><code>/_cat/fielddata</code>       	#查看当前集群各个节点的fielddata内存使用情况</li> <li><code>/_cat/fielddata/{fields}</code>	#查看指定field的内存使用情况,里面传field属性对应的值</li> <li><code>/_cat/nodeattrs</code>			#查看单节点的自定义属性</li> <li><code>/_cat/repositories</code>		#输出集群中注册快照存储库</li> <li><code>/_cat/templates</code>			#输出当前正在存在的模板信息</li></ol> <h4 id="健康值状态"><a href="#健康值状态" class="header-anchor">#</a> 健康值状态</h4> <ol><li>Green：所有Primary和Replica均为active，集群健康</li> <li>Yellow：至少一个Replica不可用，但是所有Primary均为active，数据仍然是可以保证完整性的</li> <li>Red：至少有一个Primary为不可用状态，数据不完整，集群不可用</li></ol> <h2 id="es节点有哪些类型"><a href="#es节点有哪些类型" class="header-anchor">#</a> ES节点有哪些类型</h2> <h3 id="_1-主节点-master-node"><a href="#_1-主节点-master-node" class="header-anchor">#</a> 1. 主节点（Master node）</h3> <ol><li><p>主节点的主要职责是负责集群层面的相关操作，管理集群变更，如创建或删除索引，跟踪哪些节点是集群的一部分，并决定哪些分片分配给哪些相关的节点</p></li> <li><p>主节点也可以作为数据节点，但稳定的主节点对集群的健康是非常重要的，默认情况下任何一个集群中的节点都有可能被选为主节点，索引数据和搜索查询等操作会占用大量的cpu，内存，io资源，为了确保一个集群的稳定，分离主节点和数据节点是一个比较好的选择</p></li> <li><p>通过配置<code>node.master: true</code>(默认)使节点具有被选举为<code>Master</code>的资格。主节点是全局唯一的，从有资格成为<code>Master</code>的节点中选举</p></li> <li><p>为了防止数据丢失，每个主节点应该知道有资格升为主节点的数量，默认为1，为了避免网络分区出现多主的情况，配置<code>discovery.zen.minimun_master_nodes</code>原则上最小值应该为：<code>(master_eligible_nodes/2)+1</code></p></li> <li><div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
</code></pre></div></li></ol> <h3 id="_2-数据节点-data-node"><a href="#_2-数据节点-data-node" class="header-anchor">#</a> 2. 数据节点（Data node）</h3> <ol><li><p>数据节点主要是存储索引数据的节点，执行数据相关操作：CRUD、搜索，聚合操作等。数据节点对cpu，内存，I/O要求较高， 在优化的时候需要监控数据节点的状态，当资源不够的时候，需要在集群中添加新的节点。</p></li> <li><p>通过配置<code>node.data: true</code>(默认来是一个节点成为数据节点)，也可以通过下面配置创建一个数据节点</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">node.ingest</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
</code></pre></div></li></ol> <h3 id="_3-预处理节点-ingest-node"><a href="#_3-预处理节点-ingest-node" class="header-anchor">#</a> 3. 预处理节点（ingest node）</h3> <ol><li><p>这是从5.0版本开始引入的概念。预处理操作运行在索引文档之前，即写入数据之前，通过事先定义好的一系列<code>processors</code>(处理器)和<code>pipeline</code>（管道），对数据进行某种转换、富化。<code>processors</code>和<code>pipeline</code>拦截<code>bulk</code>和<code>index</code>请求，在应用相关操作后将文档传回给<code>index</code>或<code>bulk API</code></p></li> <li><p>默认情况下，在所有的节点启用<code>ingest</code>。如果想在某个节点上禁用<code>ingest</code>，则可以填写配置<code>node.ingest: false</code>，也可以通过下面的配置创建一个仅用于预处理的节点：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.ingest</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
</code></pre></div></li></ol> <h3 id="_4-协调节点-coordinating-node"><a href="#_4-协调节点-coordinating-node" class="header-anchor">#</a> 4. 协调节点（Coordinating node）</h3> <ol><li><p>客户端请求可以发送到集群的任何节点，每个节点都知道任意文档所处的位置，然后转发这些请求，收集数据并返回给客户端，处理客户端请求的节点称为协调节点。</p></li> <li><p>协调节点将请求转发给保存数据的数据节点。每个数据节点在本地执行请求，并将结果返回给协调节点。协调节点收集完数据后，将每个数据节点的结果合并为单个全局结果。对结果收集和排序的过程可能需要很多CPU和内存资源。</p></li> <li><p>通过下面配置创建一个仅用于协调的节点：</p> <div class="language-yaml extra-class"><pre class="language-yaml"><code><span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.ingest</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
</code></pre></div></li></ol> <h3 id="_5-部落节点-trible-node"><a href="#_5-部落节点-trible-node" class="header-anchor">#</a> 5. 部落节点（Trible node）</h3> <ol><li><code>tribes</code>功能允许部落节点在多个集群之间充当联合客户端</li> <li>部落节点是一个单独的节点，其主要工作是嗅探远程集群的集群状态，并将它们合并在一起。为了做到这一点，它加入了所有的远程集群，使它成为一个非特殊的节点，它不属于自己的集群，而是加入了多个集群。</li> <li>也被称为<code>跨集群搜索</code>的功能，该功能<code>允许用户不仅跨本地索引，而且跨集群撰写搜索</code>。这意味着可以搜索属于其他远程集群的数据。</li></ol> <h3 id="_6-投票节点-voting-node"><a href="#_6-投票节点-voting-node" class="header-anchor">#</a> 6. 投票节点（voting node）</h3> <ol><li><code>node.voting_only: true</code>（仅投票节点，即使配置了<code>data.master: true</code>，也不会参选</li> <li>仍然可以作为数据节点<code>node.data: true</code></li></ol> <h2 id="es如何实现高可用"><a href="#es如何实现高可用" class="header-anchor">#</a> ES如何实现高可用</h2> <ol><li>ES在分配单个索引的分片时会将每个分片尽可能分配到更多的节点上。但是，实际情况取决于集群拥有的分片和索引的数量以及它们的大小，不一定总是能均匀地分布</li> <li>ES不允许Primary和它的Replica放在同一个节点中，并且同一个节点不接受完全相同的两个Replica</li> <li>同一个节点允许多个索引的分片同时存在</li></ol> <h2 id="es容错机制"><a href="#es容错机制" class="header-anchor">#</a> ES容错机制</h2> <ol><li>Master选举（假如宕机节点是Master）
<ul><li>脑裂：可能会产生多个Master节点</li> <li>解决：discovery.zen.minimum_master_nodes=N/2+1</li></ul></li> <li><code>Replica</code>容错，新的（或者原有）Master节点会将丢失的Primary对应的某个副本提升为Primary</li> <li>Master节点会尝试重启故障机</li> <li>数据同步，Master会将宕机期间丢失的数据同步到重启机器对应的分片上去</li></ol> <h2 id="如何提高es分布式系统的可用性及性能最大化"><a href="#如何提高es分布式系统的可用性及性能最大化" class="header-anchor">#</a> 如何提高ES分布式系统的可用性及性能最大化</h2> <ol><li>每台节点的<code>shard</code>数量越少，每个<code>shard</code>分配的CPU、内存和IO资源越多，单个<code>shard</code>的性能越好，当一台机器一个<code>shard</code>时，单个<code>shard</code>性能最好</li> <li>稳定的<code>Master节点</code>对于集群的健康非常重要！理论上讲，应该尽可能的减轻<code>Master节点</code>的压力，分片数量越多，<code>Master节点</code>维护管理<code>shard</code>的任务越重，并且节点可能就要承担更多的数据转发任务，可增加<code>仅协调节点</code>来缓解<code>Master节点</code>和<code>Data节点</code>的压力，但是在集群中添加过多的<code>仅协调节点</code>会增加整个集群的负担，因为选择的主节点必须等待每个节点的集群状态更新确认。</li> <li>反过来说，如果相同资源分配相同的前提下，<code>shard</code>数量越少，单个<code>shard</code>的体积越大，查询性能越低，速度越慢，这个取舍应根据实际集群状况和结合应用场景等因素综合考虑</li> <li><code>data节点</code>和<code>Master节点</code>一定要分开，集群规模越大，这样做的意义也就越大</li> <li><code>data节点</code>处理与数据相关的操作，例如<code>CRUD</code>，搜索和聚合。这些操作是<code>I/O</code>，内存和<code>CPU</code>密集型的，所以他们需要更高配置的服务器以及更高的带宽，并且集群的性能冗余非常重要</li> <li>由于<code>仅投票节</code>不参与<code>Master</code>竞选，所以和真正的<code>Master</code>节点相比，它需要的内存和CPU较少。但是，所有<code>候选节点</code>以及<code>仅投票节点</code>都可能是<code>数据节点</code>，所以他们都需要快速稳定低延迟的网络</li> <li>高可用性（HA）群集至少需要三个主节点，其中<code>至少两个不是仅投票节点</code>。即使其中一个节点发生故障，这样的群集也将能够选举一个主节点。生产环境最好设置3台仅Master候选节点（node.master = true	 node.data = true）</li> <li>为确保集群仍然可用，集群不能同时停止投票配置中的一半或更多节点。只要有一半以上的投票节点可用，集群仍可以正常工作。这意味着，如果存在三个或四个主节点合格的节点，则集群可以容忍其中一个节点不可用。如果有两个或更少的主机资格节点，则它们必须都保持可用</li></ol> <h2 id="master选举流程"><a href="#master选举流程" class="header-anchor">#</a> Master选举流程</h2> <h3 id="findmaster"><a href="#findmaster" class="header-anchor">#</a> findMaster</h3> <h2 id="简单curd"><a href="#简单curd" class="header-anchor">#</a> 简单CURD</h2> <h3 id="创建索引"><a href="#创建索引" class="header-anchor">#</a> 创建索引</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 格式</span>
PUT /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>?pretty
<span class="token comment"># demo</span>
PUT /product?pretty
</code></pre></div><h3 id="查询索引状态"><a href="#查询索引状态" class="header-anchor">#</a> 查询索引状态</h3> <div class="language-shell extra-class"><pre class="language-shell"><code>GET /_cat/indices?v
</code></pre></div><h3 id="删除索引"><a href="#删除索引" class="header-anchor">#</a> 删除索引</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 格式</span>
DELETE /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>?pretty
<span class="token comment"># demo</span>
DELETE /product?pretty
</code></pre></div><h3 id="查看索引信息"><a href="#查看索引信息" class="header-anchor">#</a> 查看索引信息</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 查看索引 map 映射信息</span>
GET /product
<span class="token comment"># 查看索引数据</span>
GET /product/_search
</code></pre></div><h3 id="插入数据"><a href="#插入数据" class="header-anchor">#</a> 插入数据</h3> <div class="language-shell extra-class"><pre class="language-shell"><code>PUT /product/_doc/1
<span class="token punctuation">{</span>
    <span class="token string">&quot;name&quot;</span> <span class="token builtin class-name">:</span> <span class="token string">&quot;xiaomi phone&quot;</span>,
    <span class="token string">&quot;desc&quot;</span> <span class="token builtin class-name">:</span>  <span class="token string">&quot;shouji zhong de zhandouji&quot;</span>,
    <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">3999</span>,
    <span class="token string">&quot;tags&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;xingjiabi&quot;</span>, <span class="token string">&quot;fashao&quot;</span>, <span class="token string">&quot;buka&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
PUT /product/_doc/2
<span class="token punctuation">{</span>
    <span class="token string">&quot;name&quot;</span> <span class="token builtin class-name">:</span> <span class="token string">&quot;xiaomi nfc phone&quot;</span>,
    <span class="token string">&quot;desc&quot;</span> <span class="token builtin class-name">:</span>  <span class="token string">&quot;zhichi quangongneng nfc,shouji zhong de jianjiji&quot;</span>,
    <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">4999</span>,
    <span class="token string">&quot;tags&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;xingjiabi&quot;</span>, <span class="token string">&quot;fashao&quot;</span>, <span class="token string">&quot;gongjiaoka&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
PUT /product/_doc/3
<span class="token punctuation">{</span>
    <span class="token string">&quot;name&quot;</span> <span class="token builtin class-name">:</span> <span class="token string">&quot;nfc phone&quot;</span>,
    <span class="token string">&quot;desc&quot;</span> <span class="token builtin class-name">:</span>  <span class="token string">&quot;shouji zhong de hongzhaji&quot;</span>,
    <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">2999</span>,
    <span class="token string">&quot;tags&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;xingjiabi&quot;</span>, <span class="token string">&quot;fashao&quot;</span>, <span class="token string">&quot;menjinka&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
PUT /product/_doc/4
<span class="token punctuation">{</span>
    <span class="token string">&quot;name&quot;</span> <span class="token builtin class-name">:</span> <span class="token string">&quot;xiaomi erji&quot;</span>,
    <span class="token string">&quot;desc&quot;</span> <span class="token builtin class-name">:</span>  <span class="token string">&quot;erji zhong de huangmenji&quot;</span>,
    <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">999</span>,
    <span class="token string">&quot;tags&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;low&quot;</span>, <span class="token string">&quot;bufangshui&quot;</span>, <span class="token string">&quot;yinzhicha&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
PUT /product/_doc/5
<span class="token punctuation">{</span>
    <span class="token string">&quot;name&quot;</span> <span class="token builtin class-name">:</span> <span class="token string">&quot;hongmi erji&quot;</span>,
    <span class="token string">&quot;desc&quot;</span> <span class="token builtin class-name">:</span>  <span class="token string">&quot;erji zhong de kendeji&quot;</span>,
    <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">399</span>,
    <span class="token string">&quot;tags&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;lowbee&quot;</span>, <span class="token string">&quot;xuhangduan&quot;</span>, <span class="token string">&quot;zhiliangx&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="查询数据"><a href="#查询数据" class="header-anchor">#</a> 查询数据</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 查询单个document</span>
<span class="token comment"># 格式</span>
GET /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>/_doc/<span class="token punctuation">{</span>id<span class="token punctuation">}</span>
<span class="token comment"># demo</span>
GET /product/_doc/1

<span class="token comment"># 查看所有的document</span>
<span class="token comment"># 格式</span>
GET /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>/_search
<span class="token comment"># demo</span>
GET /product/_search

<span class="token comment"># 查询多个结果的排序</span>
<span class="token comment"># 格式</span>
GET /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>/_search?sort<span class="token operator">=</span>排序的字段:<span class="token operator">&lt;</span>asc<span class="token operator">&gt;</span><span class="token operator">&lt;</span>desc<span class="token operator">&gt;</span>
<span class="token comment"># demo</span>
GET /product/_search?sort<span class="token operator">=</span>price
GET /product/_search?sort<span class="token operator">=</span>price:asc
GET /product/_search?sort<span class="token operator">=</span>price:desc
GET /product/_search?q<span class="token operator">=</span>price:2999<span class="token operator">&amp;</span><span class="token assign-left variable">sort</span><span class="token operator">=</span>price:desc
</code></pre></div><h3 id="更新数据"><a href="#更新数据" class="header-anchor">#</a> 更新数据</h3> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 全量更新（完全覆盖）</span>
<span class="token comment"># 格式</span>
PUT /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>/_doc/<span class="token punctuation">{</span>id<span class="token punctuation">}</span>
json格式的数据

<span class="token comment"># demo</span>
PUT /product/_doc/1
<span class="token punctuation">{</span>
    <span class="token string">&quot;name&quot;</span> <span class="token builtin class-name">:</span> <span class="token string">&quot;xiaomi phone&quot;</span>,
    <span class="token string">&quot;desc&quot;</span> <span class="token builtin class-name">:</span>  <span class="token string">&quot;shouji zhong de zhandouji&quot;</span>,
    <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">3999</span>,
    <span class="token string">&quot;tags&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">[</span> <span class="token string">&quot;xingjiabi&quot;</span>, <span class="token string">&quot;fashao&quot;</span>, <span class="token string">&quot;buka&quot;</span> <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 增量更新</span>
<span class="token comment"># 格式</span>
POST /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>/_doc/<span class="token punctuation">{</span>id<span class="token punctuation">}</span>/_update
<span class="token punctuation">{</span>
    <span class="token string">&quot;doc&quot;</span><span class="token builtin class-name">:</span> json格式的数据
<span class="token punctuation">}</span>

<span class="token comment"># demo</span>
POST /product/_doc/1/_update
<span class="token punctuation">{</span>
    <span class="token string">&quot;doc&quot;</span>:<span class="token punctuation">{</span>
        <span class="token string">&quot;price&quot;</span> <span class="token builtin class-name">:</span>  <span class="token number">23999</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="删除数据"><a href="#删除数据" class="header-anchor">#</a> 删除数据</h3> <blockquote><p>先逻辑删除，没有立即删除，后续才会物理删除</p></blockquote> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment"># 格式</span>
DELETE /<span class="token punctuation">{</span>indexName<span class="token punctuation">}</span>/_doc/<span class="token punctuation">{</span>id<span class="token punctuation">}</span>
<span class="token comment"># demo</span>
DELETE /product/_doc/1
</code></pre></div><h2 id="es-常用查询"><a href="#es-常用查询" class="header-anchor">#</a> ES 常用查询</h2> <h3 id="_1-search-timeout"><a href="#_1-search-timeout" class="header-anchor">#</a> 1. search timeout</h3> <ol><li>设置：默认没有<code>timeout</code>，如果设置了<code>timeout</code>，那么会执行<code>timeout</code>机制</li> <li><code>timeout</code>机制：假设用户查询结果有1W条数据，但是需要10s才能查询完毕，但是用户设置了1s的<code>timeout</code>，那么不管当前一共查询到了多少数据，都会在1s后停止查询，并返回当前数据</li> <li>用法：GET /product/_search?timeout=1s/ms/m</li></ol> <h3 id="_2-query-string"><a href="#_2-query-string" class="header-anchor">#</a> 2. query_string</h3> <ol><li>查询所有：GET /product/_search</li> <li>带参数：GET /product/_search?q=name:xiaomi</li> <li>分页+排序：GET /product/_search?from=0&amp;size=2&amp;sort=price:asc</li></ol> <h3 id="_3-match-all-匹配所有"><a href="#_3-match-all-匹配所有" class="header-anchor">#</a> 3. match_all：匹配所有</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  }
}
</code></pre></div><h3 id="_4-match-name中包含-nfc"><a href="#_4-match-name中包含-nfc" class="header-anchor">#</a> 4. match：name中包含“nfc”</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name&quot;: &quot;nfc&quot;
    }
  }
}
</code></pre></div><h3 id="_5-sort-按照加个倒序排序"><a href="#_5-sort-按照加个倒序排序" class="header-anchor">#</a> 5. sort：按照加个倒序排序</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;multi_match&quot;: {
      &quot;query&quot;: &quot;nfc&quot;,
      &quot;fields&quot;: [&quot;name&quot;,&quot;desc&quot;]
    }
  },
  &quot;sort&quot;: [
    {
      &quot;price&quot;: &quot;desc&quot;
    }
  ]
}
</code></pre></div><h3 id="_6-multi-match-根据多个字段查询一个关键词"><a href="#_6-multi-match-根据多个字段查询一个关键词" class="header-anchor">#</a> 6. multi_match：根据多个字段查询一个关键词</h3> <blockquote><p>name和desc中包含“nfc”</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;multi_match&quot;: {
      &quot;query&quot;: &quot;nfc&quot;,
      &quot;fields&quot;: [&quot;name&quot;,&quot;desc&quot;]
    }
  },
  &quot;sort&quot;: [
    {
      &quot;price&quot;: &quot;desc&quot;
    }
  ]
}
</code></pre></div><h3 id="_7-source-元数据-想要查询多个字段"><a href="#_7-source-元数据-想要查询多个字段" class="header-anchor">#</a> 7. _source：元数据，想要查询多个字段</h3> <blockquote><p>① 例子中为只查询“name”和“price”字段。</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;:{
    &quot;match&quot;: {
      &quot;name&quot;: &quot;nfc&quot;
    }
  },
  &quot;_source&quot;: [&quot;name&quot;,&quot;price&quot;]
}
</code></pre></div><h3 id="_8-分页-查询第一页-每页两条数据"><a href="#_8-分页-查询第一页-每页两条数据" class="header-anchor">#</a> 8. 分页：查询第一页（每页两条数据）</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  },
  &quot;sort&quot;: [
    {
      &quot;price&quot;: &quot;asc&quot;
    }
  ], 
  &quot;from&quot;: 0,
  &quot;size&quot;: 2
}
</code></pre></div><h3 id="_9-全文检索-term-不会被分词"><a href="#_9-全文检索-term-不会被分词" class="header-anchor">#</a> 9. 全文检索：term：不会被分词</h3> <blockquote><p>查询不会被分词，eq相等匹配倒排索引；文档内容会被分词，相当于eq的是倒排索引</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;name&quot;: &quot;nfc&quot;
    }
  }
}
GET /product/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;name&quot;: &quot;nfc phone&quot; 这里因为没有分词，所以查询没有结果
    }
  }
}
</code></pre></div><h3 id="_10-全文检索-match-会被分词"><a href="#_10-全文检索-match-会被分词" class="header-anchor">#</a> 10. 全文检索：match：会被分词</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name&quot;: &quot;xiaomi nfc zhineng phone&quot;
    }
  }
}
#验证分词
GET /_analyze 
{
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot;:&quot;xiaomi nfc zhineng phone&quot;
}
</code></pre></div><h3 id="_11-短语搜索-match-phrase-和全文检索相反"><a href="#_11-短语搜索-match-phrase-和全文检索相反" class="header-anchor">#</a> 11. 短语搜索：match_phrase：和全文检索相反</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;match_phrase&quot;: {
      &quot;name&quot;: &quot;nfc phone&quot;
    }
  }
}
</code></pre></div><h3 id="_12-查询过滤"><a href="#_12-查询过滤" class="header-anchor">#</a> 12. 查询过滤</h3> <ol><li><code>bool</code>：可以<code>组合多个查询条件</code>，<code>bool</code>查询也是采用<code>more_matches_is_better</code>的机制，因此满足<code>must</code>和<code>should</code>子句的文档将会合并起来计算分值</li> <li><code>must</code>：<code>必须满足</code>（子查询必须出现在匹配的文档中，并将有助于得分）</li> <li><code>should</code>：<code>可能满足</code> <code>or</code>（子查询可能会出现在匹配的文档中）</li> <li><code>must_not</code>：<code>必须不满足</code> <code>不计算相关度分数</code> <code>not</code>（子查询不得出现在匹配的文档中，子句在过滤器上下文中执行，这意味着计分被忽略，并且子句被视为用于缓存）</li> <li><code>filter</code>：<code>过滤器</code> <code>不计算相关度分数</code>，<code>cache</code>（子查询必须出现在匹配的文档中，但是不像<code>must</code>查询的分数将忽略。<code>filter</code>子句在<code>filter</code>上下文中优先执行，这意味着计分被忽略，并且子句被考虑用于缓存）</li> <li><code>minimum_should_match</code>：参数指定<code>should</code>返回的文档必须匹配的子句的数量或百分比。如果<code>bool</code>查询包含至少一个<code>should</code>子句，而没有<code>must</code>或<code>filter</code>子句，则默认值为1。否则，默认值为0</li></ol> <h4 id="_1-bool单条件查询"><a href="#_1-bool单条件查询" class="header-anchor">#</a> 1. bool单条件查询</h4> <blockquote><p>首先筛选<code>name</code>包含<code>xiaomi phone</code>并且价格大于1999的数据（不排序），然后搜索<code>name</code>包含<code>xiaomi</code>and <code>desc</code> 包含<code>shouji</code></p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;:{
      &quot;must&quot;: [
        {&quot;match&quot;: { &quot;name&quot;: &quot;xiaomi&quot;}},
        {&quot;match&quot;: {&quot;desc&quot;: &quot;shouji&quot;}}
      ],
      &quot;filter&quot;: [
        {&quot;match_phrase&quot;:{&quot;name&quot;:&quot;xiaomi phone&quot;}},
        {&quot;range&quot;: {
          &quot;price&quot;: {
            &quot;gt&quot;: 1999
          }
        }}
      ]
    }
  }
}
</code></pre></div><h4 id="_2-bool多条件"><a href="#_2-bool多条件" class="header-anchor">#</a> 2. bool多条件</h4> <blockquote><p>name包含xiaomi 不包含erji 描述里包不包含nfc都可以，价钱要大于等于4999</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      # name中必须包含&quot;xiaomi&quot;
      &quot;must&quot;: [
        {
          &quot;match&quot;: {&quot;name&quot;: &quot;xiaomi&quot;}
        }
      ],
      # name中必须不能包含&quot;erji&quot;
      &quot;must_not&quot;: [
        {
          &quot;match&quot;: {&quot;name&quot;: &quot;erji&quot;}
        }
      ],
      # should中至少满足0个条件，参见下面的 minimum_should_match 的解释
      &quot;should&quot;: [
        {
          &quot;match&quot;: {&quot;desc&quot;: &quot;nfc&quot;}
        }
      ],
      # 筛选价格大于4999的doc
      &quot;filter&quot;: [
        {
          &quot;range&quot;: {
            &quot;price&quot;: {&quot;gt&quot;: 4999}
          }
        }
      ]
    }
  }
}
</code></pre></div><h4 id="_3-minimum-should-match的嵌套查询"><a href="#_3-minimum-should-match的嵌套查询" class="header-anchor">#</a> 3. minimum_should_match的嵌套查询</h4> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;:{
      &quot;must&quot;: [
        {&quot;match&quot;: { &quot;name&quot;: &quot;nfc&quot;}}
      ],
      &quot;should&quot;: [
        {&quot;range&quot;: {
          &quot;price&quot;: {&quot;gt&quot;:1999}
        }},
         {&quot;range&quot;: {
          &quot;price&quot;: {&quot;gt&quot;:3999}
        }}
      ],
      &quot;minimum_should_match&quot;: 1
    }
  }
}
# demo
GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: {
        &quot;bool&quot;: {
          &quot;should&quot;: [
            { &quot;range&quot;: {&quot;price&quot;: {&quot;gt&quot;: 1999}}},
            { &quot;range&quot;: {&quot;price&quot;: {&quot;gt&quot;: 3999}}}
          ],
          &quot;must&quot;: [
            { &quot;match&quot;: {&quot;name&quot;: &quot;nfc&quot;}}
          ]
        }
      }
    }
  }
}
</code></pre></div><blockquote><ol><li>当<code>bool</code>处在<code>query</code>上下文中时，如果<code>must</code>或者<code>filter</code>匹配了<code>doc</code>，那么<code>should</code>即便一条都不满足也可以召回<code>doc</code></li> <li>当<code>bool</code>处在父<code>bool</code>的<code>filter</code>上下文中时 或者 <code>bool</code>处在<code>query</code>上下文且没有<code>must</code>/<code>filter</code>子句的时候，<code>should</code>至少匹配1个才能召回<code>doc</code></li></ol> <p>如果需要类似这种查询：where name='nfc phone' and (price='2999' or desc='shouji zhong de hongzhaji')，就有2种做法：</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code># 走嵌套bool，让should进入filter上下文：
GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: [
        [
          {&quot;match_phrase&quot;: {&quot;name&quot;: &quot;nfc phone&quot;}},
          {&quot;term&quot;: {&quot;name&quot;: &quot;nfc&quot;}}
        ],
        {
          &quot;bool&quot;: {
            &quot;should&quot;: [
              { &quot;match_phrase&quot;: {&quot;price&quot;: &quot;2999&quot;}},
              { &quot;match_phrase&quot;: {&quot;desc&quot;: &quot;shouji zhong de hongzhaji&quot;}}
            ]
          }
        }
      ]
    }
  }
}
# 走单bool，query上下文，需要显式指定minimum_should_match=1
GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: [
        [
          {&quot;match_phrase&quot;: {&quot;name&quot;: &quot;nfc phone&quot;}},
          {&quot;term&quot;: {&quot;name&quot;: &quot;nfc&quot;}}
        ]
      ],
      &quot;should&quot;: [
        { &quot;match_phrase&quot;: {&quot;price&quot;: &quot;2999&quot;}},
        { &quot;match_phrase&quot;: {&quot;desc&quot;: &quot;shouji zhong de hongzhaji&quot;}}
      ],
      &quot;minimum_should_match&quot;: 1
    }
  }
}
# 其实作为一个可扩展的查询接口，一般来说嵌套bool表达力更丰富，扩展性更好，所以不建议用第二种方式开发业务
</code></pre></div><h4 id="_4-constant-score-不计算得分"><a href="#_4-constant-score-不计算得分" class="header-anchor">#</a> 4. constant_score：不计算得分</h4> <blockquote><p>当我们不关心检索词频率<code>TF</code>（<code>Term Frequency</code>）对搜索结果排序的影响时，可以使用<code>constant_score</code>将查询语句<code>query</code>或者过滤语句<code>filter</code>包装起来</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;:{
      &quot;filter&quot;: {
        &quot;bool&quot;: {
          &quot;should&quot;:[
            {&quot;term&quot;:{&quot;name&quot;:&quot;xiaomi&quot;}},
            {&quot;term&quot;:{&quot;name&quot;:&quot;nfc&quot;}}
            ],
          &quot;must_not&quot;:[
            {&quot;term&quot;:{&quot;name&quot;:&quot;erji&quot;}}
            ]
        }
      },
      &quot;boost&quot;: 1.2
    }
  }
}
</code></pre></div><h3 id="_13-compound-queries组合查询"><a href="#_13-compound-queries组合查询" class="header-anchor">#</a> 13. Compound queries组合查询</h3> <blockquote><p>想要一台带<code>NFC</code>功能的 或者 小米的手机 但是不要耳机</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> product <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token operator">like</span> <span class="token string">&quot;%xiaomi%&quot;</span> <span class="token operator">or</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token operator">like</span> <span class="token string">'%nfc%'</span><span class="token punctuation">)</span> <span class="token operator">AND</span> <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token operator">not</span> <span class="token operator">LIKE</span> <span class="token string">'%erji%'</span>
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;:{
      &quot;filter&quot;: {
        &quot;bool&quot;: {
          &quot;should&quot;:[
            {&quot;term&quot;:{&quot;name&quot;:&quot;xiaomi&quot;}},
            {&quot;term&quot;:{&quot;name&quot;:&quot;nfc&quot;}}
            ],
          &quot;must_not&quot;:[
            {&quot;term&quot;:{&quot;name&quot;:&quot;erji&quot;}}
            ]
        }
      },
      &quot;boost&quot;: 1.2
    }
  }
}
</code></pre></div><blockquote><p>搜索一台xiaomi nfc phone或者一台满足 是一台手机 并且 价格小于等于2999</p></blockquote> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> product <span class="token keyword">WHERE</span> NAME <span class="token operator">LIKE</span> <span class="token string">'%xiaomi nfc phone%'</span> <span class="token operator">OR</span> <span class="token punctuation">(</span>NAME <span class="token operator">LIKE</span> <span class="token string">'%phone%'</span> <span class="token operator">AND</span> price <span class="token operator">&gt;</span> <span class="token number">399</span> <span class="token operator">AND</span> price <span class="token operator">&lt;=</span><span class="token number">999</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;constant_score&quot;: {
      &quot;filter&quot;: { 
        &quot;bool&quot;:{
          &quot;should&quot;:[
            {
              &quot;match_phrase&quot;: {
                &quot;name&quot;:&quot;xiaomi nfc phone&quot;
              }
            },
            {
              &quot;bool&quot;:{
                &quot;must&quot;:[
                  {&quot;term&quot;:{&quot;name&quot;:&quot;phone&quot;}},
                  {&quot;range&quot;:{&quot;price&quot;:{&quot;lte&quot;:&quot;2999&quot;}}}
                  ]
              }
            }
          ]
        }
      }
    }
  }
}
</code></pre></div><h3 id="_14-highlight-search高亮查询"><a href="#_14-highlight-search高亮查询" class="header-anchor">#</a> 14. Highlight search高亮查询</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
    &quot;query&quot; : {
        &quot;match_phrase&quot; : {
            &quot;name&quot; : &quot;nfc phone&quot;
        }
    },
    &quot;highlight&quot;:{
      &quot;fields&quot;:{
         &quot;name&quot;:{}
      }
    }
}
</code></pre></div><h3 id="_15-deep-paging"><a href="#_15-deep-paging" class="header-anchor">#</a> 15. Deep paging</h3> <h4 id="_1-deep-paging概念"><a href="#_1-deep-paging概念" class="header-anchor">#</a> 1. deep paging概念</h4> <p><strong>查询的很深，比如一个索引有三个 <code>primary shard</code>，分别存储了<code>6000</code>条数据，我们要得到第<code>100</code>页的数据（每页<code>10</code>条），类似这种情况就叫<code>deep paging</code></strong></p> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  },
  &quot;sort&quot;: [
    {
      &quot;price&quot;: &quot;asc&quot;
    }
  ], 
  &quot;from&quot;: 0,
  &quot;size&quot;: 2
}
</code></pre></div><h4 id="_2-查询原理-如何得到第100页的10条数据"><a href="#_2-查询原理-如何得到第100页的10条数据" class="header-anchor">#</a> 2. 查询原理：如何得到第100页的10条数据？</h4> <h5 id="错误的做法"><a href="#错误的做法" class="header-anchor">#</a> 错误的做法</h5> <p>在每个 <code>shard</code> 中搜索<code>990</code>到<code>999</code>这<code>10</code>条数据，然后用这<code>30</code>条数据排序，排序之后取<code>10</code>条数据就是要搜索的数据，这种做法是错的；因为3个 <code>shard</code> 中的数据的 <code>_score</code> 分数不一样，可能这某一个 <code>shard</code> 中第一条数据的 <code>_score</code> 分数比另一个 <code>shard</code> 中第<code>1000</code>条都高，所以在每个 <code>shard</code> 中搜索<code>990</code>到<code>999</code>这<code>10</code>条数据然后排序的做法是不正确的。</p> <h5 id="正确的做法"><a href="#正确的做法" class="header-anchor">#</a> 正确的做法</h5> <p>正确的做法是每个 <code>shard</code> 把<code>0</code>到<code>999</code>条数据全部搜索出来（按排序顺序），然后全部返回给 <code>coordinate node</code>，由 <code>coordinate node</code> 按 <code>_score</code> 分数排序后，取出第<code>100</code>页的<code>10</code>条数据，然后返回给客户端</p> <p><img src="/images/elasticsearch-deep-paging.png" alt="elasticsearch-deep-paging"></p> <h4 id="_3-性能问题"><a href="#_3-性能问题" class="header-anchor">#</a> 3. 性能问题</h4> <ol><li>消耗网络带宽，因为所搜过深的话，各 <code>shard</code> 要把数据传递给 <code>coordinate node</code>，这个过程是有大量数据传递的，消耗网络</li> <li>消耗内存，各 <code>shard</code> 要把数据传送给 <code>coordinate node</code>，这个传递回来的数据，是被 <code>coordinate node</code> 保存在内存中的，这样会大量消耗内存</li> <li>消耗<code>cup</code>，<code>coordinate node</code> 要把传回来的数据进行排序，这个排序过程很消耗<code>cpu</code></li></ol> <h4 id="_4-结论"><a href="#_4-结论" class="header-anchor">#</a> 4. 结论</h4> <p><font color="red"><strong>鉴于deep paging的性能问题，所有应尽量减少使用</strong></font></p> <h3 id="_16-scroll-search"><a href="#_16-scroll-search" class="header-anchor">#</a> 16. Scroll search</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search?scroll=1m
{
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  },
  &quot;sort&quot;: [
    {
      &quot;price&quot;: &quot;desc&quot;
    }
  ],
  &quot;size&quot;: 2
}
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code>GET /_search/scroll
{
  # 每次查询更新scroll的时间，相当于延期
  &quot;scroll&quot;:&quot;1m&quot;
  &quot;scroll_id&quot;: &quot;&quot;
}
</code></pre></div><h4 id="_1-基于scroll滚动技术实现大数据量搜索"><a href="#_1-基于scroll滚动技术实现大数据量搜索" class="header-anchor">#</a> 1. 基于scroll滚动技术实现大数据量搜索</h4> <p><strong>如果一次性要查出来比如10万条数据，那么性能会很差，此时一般会采取用scroll滚动查询，一批一批的查，直到所有数据都查询完为止。</strong></p> <ol><li><p><code>scroll</code>搜索会在第一次搜索的时候，保存一个当时的视图快照，之后只会基于该旧的视图快照提供数据搜索，如果这个期间数据变更，是不会让用户看到的</p></li> <li><p>采用基于<code>_doc</code>（不使用<code>_score</code>）进行排序的方式，性能较高</p></li> <li><p>每次发送<code>scroll</code>请求，我们还需要指定一个<code>scroll</code>参数，指定一个<code>时间窗口</code>，每次搜索请求只要在这个事件窗口内能完成就可以了</p> <div class="language-http extra-class"><pre class="language-http"><code># sort默认是相关度排序（&quot;sort&quot;:[{&quot;FIELD&quot;:{&quot;order&quot;:&quot;desc&quot;}}]）,不按_score排序，按_doc排序
# size设置的是每页显示的记录数
# 第一次查询会生成快照
GET /lib3/user/_search?scroll=1m #这一批查询在一分钟内完成
{
	&quot;query&quot;:{
		&quot;match&quot;:{}
	},
	&quot;sort&quot;:[  
		&quot;_doc&quot;
	],
	&quot;size&quot;:3 
}
# 第二次查询通过第一次的快照ID来查询，后面以此类推
GET /_search/scroll
{
  &quot;scroll&quot;:&quot;1m&quot;, 
  &quot;scroll_id&quot;:&quot;&quot;
}
</code></pre></div></li></ol> <h4 id="_2-基于-scroll-解决深度分页问题"><a href="#_2-基于-scroll-解决深度分页问题" class="header-anchor">#</a> 2. 基于 scroll 解决深度分页问题</h4> <p><strong>原理上是对某次查询生成一个游标 <code>scroll_id</code> ， 后续的查询只需要根据这个游标去取数据，直到结果集中返回的 <code>hits</code> 字段为空，就表示遍历结束。</strong></p> <p><font color="red"><strong>注意</strong>：<code>scroll_id</code> 的生成可以理解为建立了一个临时的<code>历史快照</code>，在此之后的增删改查等操作不会影响到这个快照的结果。</font></p> <p>使用 curl 进行分页读取过程如下：</p> <ol><li>先获取第一个 scroll_id，url 参数包括 /index/_type/ 和 scroll，scroll 字段指定了scroll_id 的<strong>有效生存期，以分钟为单位，过期之后会被es 自动清理</strong>。如果文档不需要特定排序，可以指定按照文档创建的时间返回会使迭代更高效</li> <li>后续的文档读取上一次查询返回的<code>scroll_id</code> 来不断的取下一页，如果<code>srcoll_id</code> 的生存期很长，那么每次返回的 <code>scroll_id</code> 都是一样的，直到该 <code>scroll_id</code> 过期，才会返回一个新的 <code>scroll_id</code>。请求指定的 <code>scroll_id</code> 时就不需要 /index/_type 等信息了。每读取一页都会重新设置 <code>scroll_id</code> 的生存时间，所以这个时间只需要满足读取当前页就可以，不需要满足读取所有的数据的时间，1 分钟足以。</li> <li>所有文档获取完毕之后，需要手动清理掉 <code>scroll_id</code> 。虽然<code>es</code>会有自动清理机制，但是 <code>srcoll_id</code> 的存在会耗费大量的资源来保存一份当前查询结果集映像，并且会占用文件描述符。所以用完之后要及时清理。使用 <code>es</code> 提供的 <code>CLEAR_API</code> 来删除指定的 <code>scroll_id</code></li></ol> <h4 id="_3-基于-search-after-实现深度分页"><a href="#_3-基于-search-after-实现深度分页" class="header-anchor">#</a> 3. 基于 search_after 实现深度分页</h4> <p><code>search_after</code> 是 <code>ES5.0</code> 及之后版本提供的新特性，<code>search_after</code> 有点类似 <code>scroll</code>，但是和 <code>scroll</code> 又不一样，它提供一个活动的游标，通过上一次查询最后一条数据来进行下一次查询。<code>search_after</code> 分页的方式和 <code>scroll</code> 有一些显著的区别：首先它是<strong>根据上一页的最后一条数据来确定下一页的位置</strong>，同时在分页请求的过程中，如果有索引数据的增删改查，这些变更也会实时的反映到游标上。</p> <ol><li><p>第一页的请求和正常的请求一样</p> <div class="language-http extra-class"><pre class="language-http"><code>GET /order/info/_search
{
    &quot;size&quot;: 10,
    &quot;query&quot;: {
        &quot;match_all&quot; : {
        }
    },
    &quot;sort&quot;: [
        {&quot;date&quot;: &quot;asc&quot;}
    ]
}
# 返回结果
{
    &quot;_index&quot;: &quot;zmrecall&quot;,
    &quot;_type&quot;: &quot;recall&quot;,
    &quot;_id&quot;: &quot;60310505115909&quot;,
    &quot;_score&quot;: null,
    &quot;_source&quot;: {
      ...
      &quot;date&quot;: 1545037514
    },
    &quot;sort&quot;: [
    	1545037514
    ]
  }
</code></pre></div></li> <li><p>第二页的请求，使用第一页返回结果的最后一个数据的值，加上 <code>search_after</code> 字段来取下一页。<strong>注意</strong>：使用 <code>search_after</code> 的时候要将 <code>from</code> 置为 0 或 -1。</p> <div class="language-http extra-class"><pre class="language-http"><code>curl -XGET 127.0.0.1:9200/order/info/_search
{
    &quot;size&quot;: 10,
    &quot;query&quot;: {
        &quot;match_all&quot; : {
        }
    },
    &quot;search_after&quot;: [1545037514], # 这个值与上次查询最后一条数据的sort值一致，支持多个
    &quot;sort&quot;: [
        {&quot;date&quot;: &quot;asc&quot;}
    ]
}
</code></pre></div></li></ol> <h4 id="_4-需要注意的点"><a href="#_4-需要注意的点" class="header-anchor">#</a> 4. 需要注意的点</h4> <ol><li>如果 <code>search_after</code> 中的关键字为654，那么654323的文档也会被搜索到，所以在选择 <code>search_after</code> 的排序字段时需要谨慎，可以使用比如<code>文档的id</code>或者<code>时间戳</code>等</li> <li><code>search_after</code> <strong>适用于深度分页+ 排序</strong>，因为每一页的数据依赖于上一页最后一条数据，所以<strong>无法跳页请求</strong>。</li> <li>返回的始终是<strong>最新的数据</strong>，在分页过程中数据的位置可能会有变更。这种分页方式更加符合 <code>moa</code> 的业务场景</li></ol> <h4 id="_5-番外篇-moa业务场景"><a href="#_5-番外篇-moa业务场景" class="header-anchor">#</a> 5. 番外篇：MOA业务场景</h4> <ol><li>医疗大数据 看病更便捷</li> <li>金融大数据 赚钱更给力</li> <li>交通大数据 出行更方便</li> <li>环保大数据 治污更给力</li> <li>舆情大数据 网络管理利器</li></ol> <h3 id="_17-filter缓存原理"><a href="#_17-filter缓存原理" class="header-anchor">#</a> 17. filter缓存原理</h3> <h2 id="es-查询相关"><a href="#es-查询相关" class="header-anchor">#</a> ES 查询相关</h2> <h3 id="_1-前缀搜索"><a href="#_1-前缀搜索" class="header-anchor">#</a> 1. 前缀搜索</h3> <blockquote><p>以<code>xx</code>开头的搜索，不计算相关度评分，和<code>filter</code>比，没有<code>bitcache</code>(<code>filter</code>的缓存，为了增加性能)。前缀搜索，尽量把前缀长度设置的更长，性能差。<strong>搜索原理：搜索的是倒排索引；搜索的关键字需要进行分词，分词后的每一个词都要进行全表扫描倒排索引进行匹配，引性能特别慢</strong>。<code>index_prefixes</code>: 默认<code>min_chars</code>：2,  <code>max_chars</code>：5</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code># 前缀搜索
POST /my_index/_bulk
{ &quot;index&quot;: { &quot;_id&quot;: &quot;1&quot;} }
{ &quot;text&quot;: &quot;城管打电话喊商贩去摆摊摊&quot; }
{ &quot;index&quot;: { &quot;_id&quot;: &quot;2&quot;} }
{ &quot;text&quot;: &quot;笑果文化回应商贩老农去摆摊&quot; }
{ &quot;index&quot;: { &quot;_id&quot;: &quot;3&quot;} }
{ &quot;text&quot;: &quot;老农耗时17年种出椅子树&quot; }
{ &quot;index&quot;: { &quot;_id&quot;: &quot;4&quot;} }
{ &quot;text&quot;: &quot;夫妻结婚30多年AA制,被城管抓&quot; }
{ &quot;index&quot;: { &quot;_id&quot;: &quot;5&quot;} }
{ &quot;text&quot;: &quot;黑人见义勇为阻止抢劫反被铐住&quot; }
# 查不出结果的原因是：使用了es的默认分词器，对中文支持的不太友好，这个分词器会把中文一个字一个字的拆开
GET my_index/_search
{
  &quot;query&quot;: {
    &quot;prefix&quot;: {
      &quot;text&quot;: {
        &quot;value&quot;: &quot;城管&quot;
      }
    }
  }
}
# 测试默认中文分词器
GET /_analyze
{
  &quot;text&quot;: &quot;城管打电话喊商贩去摆摊摊&quot;,
  &quot;analyzer&quot;: &quot;standard&quot;
}
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code># 前缀搜索
POST /my_index/_bulk
{ &quot;index&quot;: { &quot;_id&quot;: &quot;1&quot;} }
{ &quot;text&quot;: &quot;my english&quot; }
{ &quot;index&quot;: { &quot;_id&quot;: &quot;2&quot;} }
{ &quot;text&quot;: &quot;my english is good&quot; }
{ &quot;index&quot;: { &quot;_id&quot;: &quot;3&quot;} }
{ &quot;text&quot;: &quot;my chinese is good&quot; }
{ &quot;index&quot;: { &quot;_id&quot;: &quot;4&quot;} }
{ &quot;text&quot;: &quot;my japanese is nice&quot; }
{ &quot;index&quot;: { &quot;_id&quot;: &quot;5&quot;} }
{ &quot;text&quot;: &quot;my disk is full&quot; }
# 英文默认分词器是好用的
GET /_analyze
{
  &quot;text&quot;: &quot;my chinese is good&quot;,
  &quot;analyzer&quot;: &quot;standard&quot;
}
# 英文的前缀搜索是好用的
GET my_index/_search
{
  &quot;query&quot;: {
    &quot;prefix&quot;: {
      &quot;text&quot;: &quot;ch&quot;
    }
  }
}
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code># 设置默认的 启动索引 加快前缀搜索速度 index_prefixes: 默认min_chars:2, max_chars:5；es 会根据设置的参数建立倒排索引 
PUT my_index
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;text&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;index_prefixes&quot;: {
          &quot;min_chars&quot;:2,
          &quot;max_chars&quot;:4
        }    
      }
    }
  }
}
</code></pre></div><h3 id="_2-通配符搜索"><a href="#_2-通配符搜索" class="header-anchor">#</a> 2. 通配符搜索</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET my_index/_search
{
  &quot;query&quot;: {
    &quot;wildcard&quot;: {
      &quot;text&quot;: {
        &quot;value&quot;: &quot;eng?ish&quot;
      }
    }
  }
}
# 数据还是用的之前的 product 索引的数据
# 匹配的是倒排索引
GET product/_search
{
  &quot;query&quot;: {
    &quot;wildcard&quot;: {
      &quot;name&quot;: {
        &quot;value&quot;: &quot;xia?mi&quot;
      }
    }
  }
}
# 数据还是用的之前的 product 索引的数据
# 匹配的是文档数据
GET product/_search
{
  &quot;query&quot;: {
    &quot;wildcard&quot;: {
      &quot;name.keyword&quot;: {
        &quot;value&quot;: &quot;xiaomi*nfc*&quot;,
        &quot;boost&quot;: 1.0
      }
    }
  }
}
</code></pre></div><h3 id="_3-正则搜索"><a href="#_3-正则搜索" class="header-anchor">#</a> 3. 正则搜索</h3> <p><code>regexp</code>查询的性能可以根据提供的正则表达式而有所不同。为了提高性能，应避免使用通配符模式，如<code>.*</code>或 <code>.*?+</code>未经前缀或后缀。flags参数值：</p> <ol><li><p><code>ALL</code>(<code>Default</code>)：启用所有可选操作符。</p></li> <li><p><code>COMPLEMENT</code>：启用~操作符。可以使用<code>~</code>对下面最短的模式进行否定。例如：</p> <ul><li>a~bc  # matches 'adc' and 'aec' but not 'abc'</li></ul></li> <li><p><code>INTERVAL</code>：启用<code>&lt;&gt;</code>操作符。可以使用<code>&lt;&gt;</code>匹配数值范围。例如：</p> <ul><li><p>foo&lt;1-100&gt;    # matches 'foo1', 'foo2' ... 'foo99', 'foo100'</p></li> <li><p>foo&lt;01-100&gt;   # matches 'foo01', 'foo02' ... 'foo99', 'foo100'</p></li></ul></li> <li><p><code>INTERSECTION</code>：启用&amp;操作符，它充当AND操作符。如果左边和右边的模式都匹配，则匹配成功。例如：</p> <ul><li>aaa.+&amp;.+bbb  # matches 'aaabbb'</li></ul></li> <li><p><code>ANYSTRING</code>：启用@操作符。您可以使用@来匹配任何整个字符串。您可以将@操作符与&amp;和~操作符组合起来，创建一个“everything except”逻辑。例如：</p> <ul><li>@&amp;~(abc.+)  # matches everything except terms beginning with 'abc'</li></ul></li></ol> <div class="language-http extra-class"><pre class="language-http"><code># 正则搜索
GET product/_search
{
  &quot;query&quot;: {
    &quot;regexp&quot;: {
      &quot;name&quot;: {
        &quot;value&quot;: &quot;[\\s\\S]*nfc[\\s\\S]*&quot;,
        &quot;flags&quot;: &quot;ALL&quot;,
        &quot;max_determinized_states&quot;: 10000,
        &quot;rewrite&quot;: &quot;constant_score&quot;
      }
    }
  }
}
# 更新数据
PUT /product/_doc/1
{
  &quot;testid&quot;:&quot;123456&quot;,
  &quot;text&quot;:&quot;shouji zhong 2020-05-20 de zhandouji&quot;
}
GET /_analyze
{
  &quot;text&quot;: &quot;shouji zhong 2020-05-20 de zhandouji&quot;,
  &quot;analyzer&quot;: &quot;ik_max_word&quot;
}
# 为什么没有结果，因为默认的标准分词器会把2020-05-20分成3个词，倒排索引中没有2020-05-20
GET product/_search
{
  &quot;query&quot;: {
    &quot;regexp&quot;: {
      &quot;text&quot;: {
        &quot;value&quot;: &quot;.*2020-05-20.*&quot;,
        &quot;flags&quot;: &quot;ALL&quot;
      }
    }
  }
}
# 这样就可以查出来结果，但是不建议使用这种方式，性能特别慢
GET product/_search
{
  &quot;query&quot;: {
    &quot;regexp&quot;: {
      &quot;text.keyword&quot;: {
        &quot;value&quot;: &quot;.*2020-05-20.*&quot;,
        &quot;flags&quot;: &quot;ALL&quot;
      }
    }
  }
}
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code># 创建索引时设置分词器
PUT my_index
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;text&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;ik_max_word&quot;,
        &quot;search_analyzer&quot;: &quot;ik_max_word&quot;
      }
    }
  }
}
# 插入数据
PUT /my_index/_doc/1
{
  &quot;testid&quot;:&quot;123456&quot;,
  &quot;text&quot;:&quot;shouji zhong 2020-05-20 de zhandouji&quot;
}
# 使用ik分词器进行查询方式二
GET /my_index/_search
{
  &quot;query&quot;: {
    &quot;regexp&quot;: {
      &quot;text&quot;: {
        &quot;value&quot;: &quot;.*2020-05-20.*&quot;,
        &quot;flags&quot;: &quot;ALL&quot;
      }
    }
  }
}
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code># flags：INTERVAL方式查询
GET my_index/_search
{
  &quot;query&quot;: {
    &quot;regexp&quot;: {
      &quot;text&quot;: {
        &quot;value&quot;: &quot;.*&lt;1-4&gt;.*&quot;,
        &quot;flags&quot;: &quot;INTERVAL&quot;
      }
    }
  }
}
GET product/_search
{
  &quot;query&quot;: {
    &quot;regexp&quot;: {
      &quot;desc&quot;: {
        &quot;value&quot;: &quot;.*zh~eng.*&quot;,
        &quot;flags&quot;: &quot;INTERVAL&quot;
      }
    }
  }
}
</code></pre></div><h3 id="_4-模糊搜索-fuzzy"><a href="#_4-模糊搜索-fuzzy" class="header-anchor">#</a> 4. 模糊搜索：fuzzy</h3> <h4 id="模糊的几种情况"><a href="#模糊的几种情况" class="header-anchor">#</a> 模糊的几种情况</h4> <ol><li>混淆字符 (box → fox)</li> <li>缺少字符 (black → lack)</li> <li>多出字符 (sic → sick)</li> <li>颠倒次序 (act → cat)</li></ol> <h4 id="fuzzy的参数"><a href="#fuzzy的参数" class="header-anchor">#</a> fuzzy的参数</h4> <ol><li><p><code>value</code>：要搜索的关键字</p></li> <li><p><code>fuzziness</code>：（可选，字符串）最大误差  并非越大越好，召回率高 但是结果不准确</p> <ul><li><p>两段文本之间的<code>Damerau-Levenshtein</code>距离是使一个字符串与另一个字符串匹配所需的插入、删除、替换和调换的数量</p></li> <li><ol><li>距离公式：<code>Levenshtein</code>是<code>lucene</code>的，es改进版：<code>Damerau-Levenshtein</code>，</li></ol> <p><code>axe</code>=&gt;<code>aex</code> <code>Levenshtein</code>=2  <code>Damerau-Levenshtein</code>=1</p></li></ul></li> <li><p><code>max_expansions</code>：（可选，整数）匹配的最大词项数量。默认为50</p></li> <li><p><code>prefix_length</code>：创建扩展时保留不变的开始字符数。默认为0</p> <p>避免在<code>max_expansions</code>参数中使用较高的值，尤其是当<code>prefix_length</code>参数值为时0。<code>max_expansions</code>由于检查的变量数量过多，参数中的高值 可能导致性能不佳</p></li> <li><p><code>transpositions</code>：（可选，布尔值）指示编辑是否包括两个相邻字符的变位（ab→ba）。默认为<code>true</code></p></li> <li><p><code>rewrite</code>：（可选，字符串）用于重写查询的方法：<a href="#performance-considerations">https://www.elastic.co/cn/blog/found-fuzzy-search#performance-considerations</a></p></li></ol> <div class="language-http extra-class"><pre class="language-http"><code># 查询语句
GET /my_index/_search 
{
  &quot;query&quot;: {
    &quot;fuzzy&quot;: {
      &quot;text&quot;: {
        &quot;value&quot;: &quot;shouai&quot;,
        &quot;fuzziness&quot;: 2
      }
    }
  }
}
# shouai容错的搜索结果
{
	&quot;_source&quot; : {
          &quot;testid&quot; : &quot;123456&quot;,
          &quot;text&quot; : &quot;shouji zhong 2020-05-20 de zhandouji&quot;
        }
}
GET /my_index/_search 
{
  &quot;query&quot;: {
    &quot;fuzzy&quot;: {
      &quot;text&quot;: {
        &quot;value&quot;: &quot;shouai&quot;,
        &quot;fuzziness&quot;: &quot;AUTO&quot;
      }
    }
  }
}
</code></pre></div><h3 id="_5-match-phrase-prefix讲解"><a href="#_5-match-phrase-prefix讲解" class="header-anchor">#</a> 5. match_phrase_prefix讲解</h3> <p><code>match_phrase_prefix</code>与<code>match_phrase</code>相同，但是它多了一个特性，就是它允许在文本的最后一个词项<code>(term)</code>上的前缀匹配；如果 是一个单词，比如<code>a</code>，它会匹配文档字段所有以<code>a</code>开头的文档，如果是一个短语，比如 <code>this is ma</code>，他会先在倒排索引中做以<code>ma</code>做前缀搜索，然后在匹配到的<code>doc</code>中做<code>match_phrase</code>查询，(网上有的说是先<code>match_phrase</code>，然后再进行前缀搜索, 是不对的)</p> <h4 id="参数"><a href="#参数" class="header-anchor">#</a> 参数</h4> <ol><li><code>analyzer</code>指定何种分析器来对该短语进行分词处理</li> <li><code>max_expansions</code>限制匹配的最大词项</li> <li><code>boost</code>用于设置该查询的权重</li> <li><code>slop</code>允许短语间的词项<code>(term)</code>间隔</li></ol> <blockquote><p><code>slop</code>参数告诉<code>match_phrase</code>查询词条相隔多远时仍然能将文档视为匹配 什么是相隔多远？ 意思是说为了让查询和文档匹配你需要移动词条多少次？</p></blockquote> <h2 id="es-查询总结"><a href="#es-查询总结" class="header-anchor">#</a> ES 查询总结</h2> <h3 id="match、term、match-phrase、query-string的区别"><a href="#match、term、match-phrase、query-string的区别" class="header-anchor">#</a> <a href="https://www.cnblogs.com/chenmz1995/p/10199147.html" target="_blank" rel="noopener noreferrer">match、term、match_phrase、query_string的区别<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <h4 id="准备数据"><a href="#准备数据" class="header-anchor">#</a> 准备数据</h4> <div class="language-http extra-class"><pre class="language-http"><code># 插入数据
PUT /product/_doc/1
{
    &quot;name&quot; : &quot;xiaomi phone&quot;,
    &quot;desc&quot; :  &quot;shouji zhong de zhandouji&quot;,
    &quot;price&quot; :  3999,
    &quot;tags&quot;: [ &quot;xingjiabi&quot;, &quot;fashao&quot;, &quot;buka&quot; ]
}
PUT /product/_doc/2
{
    &quot;name&quot; : &quot;xiaomi nfc phone&quot;,
    &quot;desc&quot; :  &quot;zhichi quangongneng nfc,shouji zhong de jianjiji&quot;,
    &quot;price&quot; :  4999,
    &quot;tags&quot;: [ &quot;xingjiabi&quot;, &quot;fashao&quot;, &quot;gongjiaoka&quot; ]
}
PUT /product/_doc/3
{
    &quot;name&quot; : &quot;nfc phone&quot;,
    &quot;desc&quot; :  &quot;shouji zhong de hongzhaji&quot;,
    &quot;price&quot; :  2999,
    &quot;tags&quot;: [ &quot;xingjiabi&quot;, &quot;fashao&quot;, &quot;menjinka&quot; ]
}
PUT /product/_doc/4
{
    &quot;name&quot; : &quot;xiaomi erji&quot;,
    &quot;desc&quot; :  &quot;erji zhong de huangmenji&quot;,
    &quot;price&quot; :  999,
    &quot;tags&quot;: [ &quot;low&quot;, &quot;bufangshui&quot;, &quot;yinzhicha&quot; ]
}
PUT /product/_doc/5
{
    &quot;name&quot; : &quot;hongmi erji&quot;,
    &quot;desc&quot; :  &quot;erji zhong de kendeji&quot;,
    &quot;price&quot; :  399,
    &quot;tags&quot;: [ &quot;lowbee&quot;, &quot;xuhangduan&quot;, &quot;zhiliangx&quot; ]
}
</code></pre></div><h4 id="match"><a href="#match" class="header-anchor">#</a> match</h4> <div class="language-http extra-class"><pre class="language-http"><code># 查询所有
GET /product/_search
{
  &quot;query&quot;:{
    &quot;match_all&quot;: {}
  }
}
# match分词，text也分词，只要match的分词结果和text的分词结果有相同的就匹配
# nfc phone会被分成两个词，分别匹配倒排索引
GET /product/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name&quot;: &quot;nfc phone&quot;
    }
  }
}
# match会被分词，而keyword不会被分词，match的需要跟keyword的完全匹配可以
GET /product/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name.keyword&quot;: &quot;xiaomi nfc phone&quot;
    }
  }
}
</code></pre></div><h4 id="term"><a href="#term" class="header-anchor">#</a> term</h4> <div class="language-http extra-class"><pre class="language-http"><code># term 查询关键字不会被分词，倒排所用中没有'nfc phone'这个词，所以查询不到结果
GET /product/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;name&quot;: &quot;nfc phone&quot;
    }
  }
}
# text字段会分词，而term 查询关键字不会被分词，所以term查询的条件必须是text字段分词后的某一个才可以
GET /product/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;name&quot;: &quot;nfc&quot;
    }
  }
}
# term 查询关键字不会被分词，而keyword字段也不分词。需要完全匹配才可
GET /product/_search
{
  &quot;query&quot;: {
    &quot;term&quot;: {
      &quot;name.keyword&quot;: &quot;nfc phone&quot;
    }
  }
}
</code></pre></div><h4 id="match-phrase"><a href="#match-phrase" class="header-anchor">#</a> match_phrase</h4> <div class="language-http extra-class"><pre class="language-http"><code># match_phrase是分词的，text也是分词的。match_phrase的分词结果必须在text字段分词中都包含（且不支持前缀搜索），而且顺序必须相同，而且必须都是连续的
GET /product/_search
{
  &quot;query&quot;: {
    &quot;match_phrase&quot;: {
      &quot;desc&quot;: &quot;shouji zhong&quot;
    }
  }
}
# match_phrase是分词的，而keyword字段不分词。需要完全匹配才可
GET /product/_search
{
  &quot;query&quot;: {
    &quot;match_phrase&quot;: {
      &quot;desc.keyword&quot;: &quot;shouji zhong&quot;
    }
  }
}
</code></pre></div><h4 id="query-string"><a href="#query-string" class="header-anchor">#</a> query_string</h4> <div class="language-http extra-class"><pre class="language-http"><code># query_string是分词的，text也是分词的。分词之后，每一个词可支持前缀搜索，故不要求顺序
GET /product/_search
{
  &quot;query&quot;: {
    &quot;query_string&quot;: {
      &quot;query&quot;: &quot;zhong shouji&quot;,
      &quot;fields&quot;: [&quot;desc&quot;]
    }
  }
}
# query_string是分词的，而keyword字段不分词。需要完全匹配才可
GET /product/_search
{
  &quot;query&quot;: {
    &quot;query_string&quot;: {
      &quot;query&quot;: &quot;shouji zhong de zhandouji&quot;,
      &quot;fields&quot;: [&quot;desc.keyword&quot;]
    }
  }
}
</code></pre></div><h2 id="mapping"><a href="#mapping" class="header-anchor">#</a> Mapping</h2> <h3 id="_1-概念"><a href="#_1-概念" class="header-anchor">#</a> 1. 概念</h3> <p><code>mapping</code>就是<code>ES</code>数据字段<code>field</code>的<code>type</code>元数据，<code>ES</code>在创建索引的时候，<code>dynamic mapping</code>会自动为不同的数据指定相应<code>mapping</code>，<code>mapping</code>中包含了字段的类型、搜索方式（<code>exact value</code>或者<code>full text</code>）、分词器等。</p> <h3 id="_2-查看mapping"><a href="#_2-查看mapping" class="header-anchor">#</a> 2. 查看mapping</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_mappings
</code></pre></div><h3 id="_3-动态mapping"><a href="#_3-动态mapping" class="header-anchor">#</a> 3. 动态mapping</h3> <ol><li>Elasticsearch：text / keyword</li> <li>123456             =&gt;	long			？为什么不是<code>integer</code></li> <li>123.123            =&gt;	double        实际是<code>float</code>类型</li> <li>true false          =&gt;	boolean</li> <li>2020-05-20       =&gt;	date</li></ol> <blockquote><p><font color="red">为啥<code>123456</code>是<code>long</code>类型而不是<code>integer</code>？因为<code>es</code>的<code>mapping_type</code>是由<code>JSON</code>分析器检测数据类型，而<code>Json</code>没有隐式类型转换（<code>integer</code>=&gt;<code>long</code> or <code>float</code>=&gt; <code>double</code>），所以<code>dynamic mapping</code>会选择一个比较宽的数据类型。</font></p></blockquote> <h3 id="_4-搜索方式"><a href="#_4-搜索方式" class="header-anchor">#</a> 4. 搜索方式</h3> <ol><li>exact value 精确匹配：在倒排索引过程中，分词器会将<code>field</code>作为一个整体创建到索引中</li> <li>full text全文检索： 分词、近义词同义词、混淆词、大小写、词性、过滤、时态转换等</li></ol> <div class="language-http extra-class"><pre class="language-http"><code># 搜索所有字段包含de的doc
GET /product/_search?q=de
# 搜索name字段包含de的doc
GET /product/_search?q=name:de
# name.keyword 不会被分词，有点儿类似 match_phrase 短语搜索，eq文档doc的属性
GET /product/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name.keyword&quot;: &quot;xiaomi phone&quot;
    }
  }
}
GET /product/_search
{
  &quot;query&quot;: {
    &quot;match_phrase&quot;: {
      &quot;name&quot;: &quot;xiaomi phone&quot;
    }
  }
}
# 全文检索可能会搜索出多条结果 eq倒排索引
GET /product/_search
{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;name&quot;: &quot;xiaomi phone&quot;
    }
  }
}
</code></pre></div><h3 id="_5-es数据类型"><a href="#_5-es数据类型" class="header-anchor">#</a> 5. ES数据类型</h3> <h4 id="_1-核心类型"><a href="#_1-核心类型" class="header-anchor">#</a> 1. 核心类型</h4> <ol><li><p>数字类型</p> <ul><li>long</li> <li>integer</li> <li>short</li> <li>byte</li> <li>double</li> <li>float</li> <li>half_float</li> <li>scaled_float</li> <li>在满足需求的情况下，尽可能选择范围小的数据类型</li></ul></li> <li><p>字符串</p> <ul><li><p>keyword：适用于索引结构化的字段，可以用于过滤、排序、聚合。<code>keyword</code>类型的字段只能通过精确值搜索列。ID应该用<code>keyword</code></p></li> <li><p>text：当一个字段是要被全文搜索的，比如<code>Email</code>内容、产品描述，这些字段应该使用<code>text</code>类型。设置<code>text</code>类型以后，字段内容会被分析，在生成倒排索引之前，字符串会被分析器分成一个一个词项。<code>text</code>类型的字段不用于排序，很少用于聚合。</p> <blockquote><p>解释一下为啥不会为<code>text</code>创建索引：字段数据会占用大量堆空间，尤其是在加载高基数<code>text</code>字段时。字段数据一旦加载到堆中，就在该段的生命周期内保持在那里。同样，加载字段数据是一个昂贵的过程，可能导致用户遇到延迟问题。这就是默认情况下禁用字段数据的原因。</p> <p>有时，在同一字段中同时具有全文本<code>text</code>和关键字<code>keyword</code>版本会很有用：一个用于全文本搜索，另一个用于聚合和排序</p></blockquote></li> <li><p>date（时间类型）：exact value</p></li> <li><p>boolean（布尔类型）</p></li> <li><p>binary（二进制）：binary</p></li> <li><p>range（区间类型）：integer_range、float_range、long_range、double_range、date_range</p></li></ul></li></ol> <h4 id="_2-复杂类型"><a href="#_2-复杂类型" class="header-anchor">#</a> 2. 复杂类型</h4> <ol><li>Object：用于单个JSON对象</li> <li>Nested：用于JSON对象数组</li></ol> <h4 id="_3-地理位置"><a href="#_3-地理位置" class="header-anchor">#</a> 3. 地理位置</h4> <ol><li>Geo-point：纬度 / 经度积分</li> <li>Geo-shape：用于多边形等复杂形状</li></ol> <h4 id="_4-特有类型"><a href="#_4-特有类型" class="header-anchor">#</a> 4. 特有类型</h4> <ol><li>IP地址：ip 用于IPv4和IPv6地址</li> <li>Completion：提供自动完成建议</li> <li>Tocken_count：计算字符串中令牌的数量</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/7.7/mapper-murmur3.html" target="_blank" rel="noopener noreferrer">Murmur3<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：在索引时计算值的哈希并将其存储在索引中</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/plugins/7.7/mapper-annotated-text.html" target="_blank" rel="noopener noreferrer">Annotated-text<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：索引包含特殊标记的文本（通常用于标识命名实体）</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/percolator.html" target="_blank" rel="noopener noreferrer">Percolator<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：接受来自query-dsl的查询</li> <li>Join：为同一索引内的文档定义父/子关系</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rank-features.html" target="_blank" rel="noopener noreferrer">Rank features<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：记录数字功能以提高查询时的点击率。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/dense-vector.html" target="_blank" rel="noopener noreferrer">Dense vector<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：记录浮点值的密集向量。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sparse-vector.html" target="_blank" rel="noopener noreferrer">Sparse vector<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：记录浮点值的稀疏向量。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-as-you-type.html" target="_blank" rel="noopener noreferrer">Search-as-you-type<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：针对查询优化的文本字段，以实现按需输入的完成</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/alias.html" target="_blank" rel="noopener noreferrer">Alias<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：为现有字段定义别名。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/flattened.html" target="_blank" rel="noopener noreferrer">Flattened<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：允许将整个JSON对象索引为单个字段。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/shape.html" target="_blank" rel="noopener noreferrer">Shape<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：shape 对于任意笛卡尔几何。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/histogram.html" target="_blank" rel="noopener noreferrer">Histogram<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：histogram 用于百分位数聚合的预聚合数值。</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/constant-keyword.html" target="_blank" rel="noopener noreferrer">Constant keyword<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：keyword当所有文档都具有相同值时的情况的 专业化。</li></ol> <h4 id="_5-array-数组"><a href="#_5-array-数组" class="header-anchor">#</a> 5. Array（数组）</h4> <p>在Elasticsearch中，数组不需要专用的字段数据类型。默认情况下，任何字段都可以包含零个或多个值，但是，数组中的所有值都必须具有相同的数据类型。</p> <h4 id="_6-es7新增"><a href="#_6-es7新增" class="header-anchor">#</a> 6. ES7新增</h4> <ol><li>Date_nanos：date plus 纳秒</li> <li>Features：</li> <li>Vector：as</li></ol> <h3 id="_6-手工创建mapping"><a href="#_6-手工创建mapping" class="header-anchor">#</a> 6. 手工创建Mapping</h3> <div class="language-http extra-class"><pre class="language-http"><code># 格式
PUT /{indexName}
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
        &quot;field&quot;: {
          &quot;mapping_parameter&quot;: &quot;parameter_value&quot;
        }
      }
  }
}
# 手工创建 mappings
PUT /product3
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;date&quot;: {
        &quot;type&quot;: &quot;text&quot;
      },
      &quot;desc&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;english&quot;
      },
      &quot;name&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;index&quot;: &quot;false&quot;
      },
      &quot;price&quot;: {
        &quot;type&quot;: &quot;long&quot;
      },
      &quot;tags&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;index&quot;: &quot;true&quot;
      },
      &quot;parts&quot;: {
        &quot;type&quot;: &quot;object&quot;
      },
      &quot;partlist&quot;: {
        &quot;type&quot;: &quot;nested&quot;
      }
    }
  }
}
# 查看 mapping
GET /product3/_mapping
# 插入数据
PUT /product3/_doc/1
{
  &quot;name&quot;: &quot;xiaomi phone&quot;,
  &quot;desc&quot;: &quot;shouji zhong de zhandouji&quot;,
  &quot;count&quot;: 123456,
  &quot;price&quot;: 3999,
  &quot;date&quot;: &quot;2020-05-20&quot;,
  &quot;isdel&quot;: false,
  &quot;tags&quot;: [
    &quot;xingjiabi&quot;,
    &quot;fashao&quot;,
    &quot;buka&quot;
  ],
  &quot;parts&quot;: {
    &quot;name&quot;: &quot;adapter&quot;,
    &quot;desc&quot;: &quot;5V 2A&quot;
  },
  &quot;partlist&quot;: [
    {
      &quot;name&quot;: &quot;adapter&quot;,
      &quot;desc&quot;: &quot;5V 2A&quot;
    },
    {
      &quot;name&quot;: &quot;USB-C&quot;,
      &quot;desc&quot;: &quot;5V 2A 1.5m&quot;
    },
    {
      &quot;name&quot;: &quot;erji&quot;,
      &quot;desc&quot;: &quot;boom&quot;
    }
  ]
}
# 查看数据
GET /product3/_search
{
  &quot;query&quot;: {
    &quot;match_all&quot;: {}
  }
}
</code></pre></div><h3 id="_7-mapping-parameters"><a href="#_7-mapping-parameters" class="header-anchor">#</a> 7. Mapping parameters</h3> <ol><li><p><code>index</code>：是否对创建对当前字段创建索引，默认true，如果不创建索引，该字段不会通过索引被搜索到，但是仍然会在<code>source</code>元数据中展示</p></li> <li><p><code>analyzer</code>：指定分析器（character filter、tokenizer、Token filters）。</p></li> <li><p><code>boost</code>：对当前字段相关度的评分权重，默认1</p></li> <li><p><code>coerce</code>：是否允许强制类型转换  true “1”=&gt; 1  false “1”=&lt; 1</p></li> <li><p><code>copy_to</code>：</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;field&quot;: {
   &quot;type&quot;: &quot;text&quot;,
   &quot;copy_to&quot;: &quot;other_field_name&quot; 
}
</code></pre></div></li> <li><p><code>doc_values</code>：为了提升排序和聚合效率，默认true，如果确定不需要对字段进行排序或聚合，也不需要通过脚本访问字段值，则可以禁用<code>doc</code>值以节省磁盘空间（不支持<code>text</code>和<code>annotated_text</code>）</p></li> <li><p><code>dynamic</code>：控制是否可以动态添加新字段</p> <ul><li>true 新检测到的字段将添加到映射中。（默认）</li> <li>false 新检测到的字段将被忽略。这些字段将不会被索引，因此将无法搜索，但仍会出现在_source返回的匹配项中。这些字段不会添加到映射中，必须显式添加新字段。</li> <li>strict 如果检测到新字段，则会引发异常并拒绝文档。必须将新字段显式添加到映射中</li></ul></li> <li><p><code>eager_global_ordinals</code>：用于聚合的字段上，优化聚合性能。</p> <ul><li><code>Frozen indices</code>（冻结索引）：有些索引使用率很高，会被保存在内存中，有些使用率特别低，宁愿在使用的时候重新创建，在使用完毕后丢弃数据，<code>Frozen indices</code>的数据命中频率小，不适用于高搜索负载，数据不会被保存在内存中，堆空间占用比普通索引少得多，<code>Frozen indices</code>是只读的，请求可能是秒级或者分钟级。<code>eager_global_ordinals</code>不适用于<code>Frozen indices</code></li></ul></li> <li><p><code>enable</code>：是否创建倒排索引，可以对字段操作，也可以对索引操作，如果不创建索引，仍然可以检索并在<code>_source</code>元数据中展示，谨慎使用，该状态无法修改。</p> <div class="language-http extra-class"><pre class="language-http"><code>PUT my_index 
{
  &quot;mappings&quot;: {
    &quot;enabled&quot;: false 
  }
}
PUT my_index
{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;session_data&quot;: {
        &quot;type&quot;: &quot;object&quot;,
        &quot;enabled&quot;: false
      }
    }
  }
}
</code></pre></div><blockquote><p><font color="red"><strong>注意：enable只能在最顶层，并且type为object的时候设置才生效。</strong></font></p></blockquote></li> <li><p><code>fielddata</code>：查询时<code>内存</code>数据结构，在首次用当前字段聚合、排序或者在脚本中使用时，需要字段为<code>fielddata</code>数据结构，并且创建正排索引<code>doc_values</code>并保存到<code>JVM</code>的堆中，一定要慎用。</p></li> <li><p><code>fields</code>：给<code>field</code>创建多字段，用于不同目的（全文检索或者聚合分析排序）</p></li> <li><p><code>format</code>：格式化</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;date&quot;: {
      &quot;type&quot;:   &quot;date&quot;,
      &quot;format&quot;: &quot;yyyy-MM-dd&quot;
 }
</code></pre></div></li> <li><p><code>ignore_above</code>：超过长度将被忽略</p></li> <li><p><code>ignore_malformed</code>：忽略类型错误</p> <div class="language-http extra-class"><pre class="language-http"><code>PUT my_index{
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;number_one&quot;: {
        &quot;type&quot;: &quot;integer&quot;,
        &quot;ignore_malformed&quot;: true
      },
      &quot;number_two&quot;: {
        &quot;type&quot;: &quot;integer&quot;
      }
    }
  }
}
PUT my_index/_doc/1{
  &quot;text&quot;:       &quot;Some text value&quot;,
  &quot;number_one&quot;: &quot;foo&quot;    //虽然有异常 但是不抛出
}
PUT my_index/_doc/2{
  &quot;text&quot;:       &quot;Some text value&quot;,
  &quot;number_two&quot;: &quot;foo&quot;   //数据格式不对	
}
</code></pre></div></li> <li><p><code>index_options</code>：控制将哪些信息添加到反向索引中以进行搜索和突出显示。仅用于<code>text</code>字段</p></li> <li><p><code>Index_phrases</code>：提升<code>exact_value</code>查询速度，但是要消耗更多磁盘空间</p></li> <li><p><code>Index_prefixes</code>：前缀搜索</p> <ol><li><p><code>min_chars</code>：前缀最小长度，&gt;0，默认2（包含）</p></li> <li><p><code>max_chars</code>：前缀最大长度，&lt;20，默认5（包含）</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;index_prefixes&quot;: {
	&quot;min_chars&quot; : 1,
	&quot;max_chars&quot; : 10
}	
</code></pre></div></li></ol></li> <li><p><code>meta</code>：附加元数据</p></li> <li><p><code>normalizer</code>：</p></li> <li><p><code>norms</code>：是否禁用评分（在<code>filter</code>和<code>聚合字段</code>上应该禁用）</p></li> <li><p><code>null_value</code>：为null值设置默认值（&quot;null_value&quot;: &quot;NULL&quot;）</p></li> <li><p><code>position_increment_gap</code>：</p></li> <li><p><code>proterties</code>：除了<code>mapping</code>还可用于<code>object</code>的属性设置</p></li> <li><p><code>search_analyzer</code>：设置单独的查询时分析器</p> <div class="language-http extra-class"><pre class="language-http"><code>PUT my_index{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;filter&quot;: {
        &quot;autocomplete_filter&quot;: {
          &quot;type&quot;: &quot;edge_ngram&quot;,
          &quot;min_gram&quot;: 1,
          &quot;max_gram&quot;: 20
        }
      },
      &quot;analyzer&quot;: {
        &quot;autocomplete&quot;: { 
          &quot;type&quot;: &quot;custom&quot;,
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [
            &quot;lowercase&quot;,
            &quot;autocomplete_filter&quot;
          ]
        }
      }
    }
  },
  &quot;mappings&quot;: {
    &quot;properties&quot;: {
      &quot;text&quot;: {
        &quot;type&quot;: &quot;text&quot;,
        &quot;analyzer&quot;: &quot;autocomplete&quot;, 
        &quot;search_analyzer&quot;: &quot;standard&quot; 
      }
    }
  }
}
PUT my_index/_doc/1{
  &quot;text&quot;: &quot;Quick Brown Fox&quot; 
}
GET my_index/_search{
  &quot;query&quot;: {
    &quot;match&quot;: {
      &quot;text&quot;: {
        &quot;query&quot;: &quot;Quick Br&quot;, 
        &quot;operator&quot;: &quot;and&quot;
      }
    }
  }
}
</code></pre></div></li> <li><p><code>similarity</code>：为字段设置相关度算法，支持<code>BM25</code>、<code>claassic（TF-IDF）</code>、<code>boolean</code></p></li> <li><p><code>store</code>：设置字段是否仅查询</p></li> <li><p><code>term_vector</code>：</p></li></ol> <h2 id="聚合查询"><a href="#聚合查询" class="header-anchor">#</a> 聚合查询</h2> <h3 id="_1-bucket-和-metirc-group-by"><a href="#_1-bucket-和-metirc-group-by" class="header-anchor">#</a> 1. bucket 和 metirc == group by</h3> <table><thead><tr><th>bucket（item）</th> <th>metirc（count）</th></tr></thead> <tbody><tr><td>北京</td> <td>100</td></tr> <tr><td>天津</td> <td>99</td></tr> <tr><td>河北</td> <td>98</td></tr></tbody></table> <h3 id="_2-语法"><a href="#_2-语法" class="header-anchor">#</a> 2. 语法</h3> <div class="language- extra-class"><pre class="language-text"><code>&quot;aggs&quot;: {
	code...
}
</code></pre></div><h3 id="_3-以tag维度每个产品的数量-即每个标签"><a href="#_3-以tag维度每个产品的数量-即每个标签" class="header-anchor">#</a> 3. 以<code>tag</code>维度每个产品的数量，即每个标签</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;aggs&quot;: {
    &quot;tag_agg_group&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;tags.keyword&quot;
      }
    }
  },
  # 不加这个会把原始的doc也查出来
  &quot;size&quot;: 0
}
</code></pre></div><h3 id="_4-在-3-的基础上增加-价格大于1999的数据"><a href="#_4-在-3-的基础上增加-价格大于1999的数据" class="header-anchor">#</a> 4. 在 3 的基础上增加：价格大于1999的数据</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: [
        {
          &quot;range&quot;: {&quot;price&quot;: {&quot;gt&quot;: 1999}}
        }
      ]
    }
  },
  &quot;aggs&quot;: {
    &quot;tag_agg_group&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;tags.keyword&quot;
      }
    }
  },
  # 不加这个会把原始的doc也查出来
  &quot;size&quot;: 0
}
</code></pre></div><h3 id="_5-价格大于1999的每个tag产品的平均价格"><a href="#_5-价格大于1999的每个tag产品的平均价格" class="header-anchor">#</a> 5. 价格大于1999的每个tag产品的平均价格</h3> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;aggs&quot;: {
    &quot;tag_agg_avg&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;tags.keyword&quot;,
        &quot;order&quot;: {
          &quot;avg_price&quot;: &quot;desc&quot;
        }
      },
      &quot;aggs&quot;: {
        &quot;avg_price&quot;: {
          &quot;avg&quot;: {
            &quot;field&quot;: &quot;price&quot;
          }
        }
      }
    }
  },
  # 不加这个会把原始的doc也查出来
  &quot;size&quot;:0
}
</code></pre></div><h3 id="_6-自定义聚合"><a href="#_6-自定义聚合" class="header-anchor">#</a> 6. 自定义聚合</h3> <p><strong>按照千元机：1000以下  中端机：2000-3000 高端机：3000以上分组聚合，分别计算数量</strong></p> <div class="language-http extra-class"><pre class="language-http"><code>GET /product/_search
{
  &quot;aggs&quot;: {
    &quot;tag_agg_group&quot;: {
      &quot;range&quot;: {
        &quot;field&quot;: &quot;price&quot;,
        &quot;ranges&quot;: [
          {
            &quot;from&quot;: 100,
            &quot;to&quot;: 1000
          },
          {
            &quot;from&quot;: 1000,
            &quot;to&quot;: 3000
          },
          {
            &quot;from&quot;: 3000
          }
        ]
      },
      &quot;aggs&quot;: {
        &quot;price_agg&quot;: {
          &quot;avg&quot;: {
            &quot;field&quot;: &quot;price&quot;
          }
        }
      }
    }
  },
  # 不加这个会把原始的doc也查出来
  &quot;size&quot;: 0
}
</code></pre></div><h3 id="_7-mget-批量查询"><a href="#_7-mget-批量查询" class="header-anchor">#</a> 7. mget：批量查询</h3> <div class="language-http extra-class"><pre class="language-http"><code># 语法
GET /_mget
GET /&lt;index&gt;/_mget
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code># demo
# 批量查询不同索引的结果
GET /_mget
{
  &quot;docs&quot;: [
    {
      &quot;_index&quot;: &quot;product&quot;,
      &quot;_id&quot;: 2
    },
    {
      &quot;_index&quot;: &quot;product&quot;,
      &quot;_id&quot;: 3
    }
  ]
}
# 批量查询同一个索引的不同ID
#封装,把索引名(product提取出来)
GET /product/_mget
{
  &quot;docs&quot;: [
    {
      &quot;_id&quot;: 2
    },
    {
      &quot;_id&quot;: 3
    }
  ]
}
GET /product/_mget
{
  &quot;ids&quot;:[2,3]
}
#include包含哪些字段  exclude排除哪些字段
GET /product/_mget
{
  &quot;docs&quot;: [
    {
      &quot;_id&quot;: 2,
      &quot;_source&quot;: false
    },
    {
      &quot;_id&quot;: 3,
      &quot;_source&quot;: [
        &quot;name&quot;,
        &quot;price&quot;
      ]
    },
    {
      &quot;_id&quot;: 4,
      &quot;_source&quot;: {
        &quot;include&quot;: [
          &quot;name&quot;
        ],
        &quot;exclude&quot;:[
          &quot;price&quot;
          ]
      }
    }
  ]
}
</code></pre></div><h3 id="_8-bulk-批量增删改"><a href="#_8-bulk-批量增删改" class="header-anchor">#</a> 8. bulk：批量增删改</h3> <div class="language-http extra-class"><pre class="language-http"><code># 语法格式
POST /_bulk
POST /&lt;index&gt;/_bulk
{&quot;action&quot;: {&quot;metadata&quot;}}
{&quot;data&quot;}
</code></pre></div><ol><li><strong>Operate：</strong></li> <li><code>create</code>：如果<code>id</code>已经存在，则报错；不存在，则插入</li> <li><code>delete</code>：删除（lazy delete原理）</li> <li><code>index</code>：可以是创建，也可以是全量替换</li> <li><code>update</code>：执行<code>partial update</code>（全量替换，部分替换）</li> <li>这么做的好处是为了节省内存，普通的插入方式会在<code>es</code>内部序列化反序列化成一个个对象，采用<code>bulk</code>方式不需要序列化反序列化对象，从而节省了内存的开销</li></ol> <div class="language-http extra-class"><pre class="language-http"><code>#手动指定id和自动生成（正常方式）
PUT /test_index/_doc/1/
{
  &quot;field&quot;:&quot;test&quot;
}
PUT /test_index/_doc/1/_create
{
  &quot;field&quot;:&quot;test&quot;
}
PUT /test_index/_create/1/
{
  &quot;field&quot;:&quot;test&quot;
}
#自动生产id(guid)
POST /test_index/_doc
{
  &quot;field&quot;:&quot;test&quot;
}
# bulk方式操作数据
POST /_bulk
{&quot;create&quot;:{&quot;_index&quot;:&quot;product2&quot;, &quot;_id&quot;:&quot;1&quot;, &quot;retry_on_conflict&quot;:&quot;3&quot;}}
{&quot;name&quot;:&quot;_buld create1&quot;}
{&quot;create&quot;:{&quot;_index&quot;:&quot;product2&quot;, &quot;_id&quot;:&quot;12&quot;}}
{&quot;name&quot;:&quot;_buld create12&quot;}
{&quot;delete&quot;:{&quot;_index&quot;:&quot;product2&quot;, &quot;_id&quot;:&quot;11&quot;}}
{&quot;update&quot;:{&quot;_index&quot;:&quot;product2&quot;, &quot;_id&quot;:&quot;12&quot;}}
{&quot;doc&quot;:{&quot;name&quot;:&quot;_buld create22&quot;}}
{&quot;index&quot;:{&quot;_index&quot;:&quot;product2&quot;, &quot;_id&quot;:&quot;12&quot;}}
{&quot;doc&quot;:{&quot;name&quot;:&quot;_buld create2222222&quot;}}
{&quot;index&quot;:{&quot;_index&quot;:&quot;product2&quot;, &quot;_id&quot;:&quot;11&quot;}}
{&quot;doc&quot;:{&quot;name&quot;:&quot;_buld create111&quot;}}
# retry_on_conflict：冲突重试 
# index 存在则全量替换，不存在则创建
# POST /_bulk?filter_path=items.*.error  只显示失败的结果
</code></pre></div><h3 id="_9-es-并发冲突问题"><a href="#_9-es-并发冲突问题" class="header-anchor">#</a> 9. ES 并发冲突问题</h3> <ol><li><p>悲观锁：各种情况，都加锁，读写锁、行级锁、表级锁。使用简单，但是并发能力很低</p></li> <li><p>乐观锁：并发能力高，操作麻烦，每次<code>no-query</code>操作都需要比对<code>version</code></p> <div class="language- extra-class"><pre class="language-text"><code>?version=2&amp;&amp;version_type=external
# `if_seq_no` and `if_primary_term`
</code></pre></div></li></ol> <h2 id="es底层原理"><a href="#es底层原理" class="header-anchor">#</a> ES底层原理</h2> <h3 id="图解正排索引和倒排索引"><a href="#图解正排索引和倒排索引" class="header-anchor">#</a> 图解正排索引和倒排索引</h3> <p><img src="/images/%E5%9B%BE%E8%A7%A3-%E6%AD%A3%E6%8E%92%E7%B4%A2%E5%BC%95VS%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95.jpg" alt="图解-正排索引VS倒排索引"></p> <blockquote><p>如果使用倒排索引做聚合操作，会对倒排索引进行多次全表扫描，从而降低了查询效率</p></blockquote> <h3 id="正排索引doc-values和倒排索引的区别"><a href="#正排索引doc-values和倒排索引的区别" class="header-anchor">#</a> 正排索引<code>doc_values</code>和倒排索引的区别</h3> <ol><li>倒排索引的优势在于查找包含某个项的文档，即用于搜索查询；相反正排索引的优势是确定哪些项是否存在单个文档里</li> <li>倒排索引和正排索引均是在<code>index-time</code>时创建，保存再Lucene文件中（序列化到磁盘）</li> <li><code>doc_values</code>使用非<code>JVM</code>内存，gc友好</li> <li>不分词的<code>field</code>会在<code>index-time</code>时生成正排索引，聚合时直接使用正排索引，而分词的<code>field</code>在创建索引时是没有正排索引的，如果没有创建<code>doc_values</code>的字段需要做聚合查询时，<code>name</code>需要将<code>fielddata</code>打开，设置为true。此时会在执行查询的时候，动态在<code>JVM</code>的堆内存空间创建正排索引。</li></ol> <h3 id="正排索引doc-values和fielddata"><a href="#正排索引doc-values和fielddata" class="header-anchor">#</a> 正排索引<code>doc_values</code>和<code>fielddata</code></h3> <ol><li>与<code>doc_value</code>不同，当没有<code>doc_value</code>的字段需要聚合时，需要打开<code>fielddata</code>，然后临时在内存中建立正排索引，<code>fielddata</code>的构建和管理发生在<code>JVM Heap</code>中</li> <li><code>fielddata</code>默认是不器用的，因为<code>text</code>的字段比较长，一般只做关键字分词和搜索，很少拿他来进行全文匹配、聚合、排序等操作</li> <li><code>ES</code>采用了<code>circuit breaker</code>熔断机制避免<code>fielddata</code>一次性超过物理内存大小而导致内存溢出，如果触发熔断，查询会被终止并返回异常</li> <li><code>fielddata</code>使用的是<code>JVM</code>内存，<code>doc_value</code>在内存不足时会静静的待在磁盘中，而当内存充足时，会缓存到内存里以提升性能</li></ol> <h3 id="es-流程核心概念"><a href="#es-流程核心概念" class="header-anchor">#</a> ES 流程核心概念</h3> <ol><li><code>index buffer</code>：内存缓冲区；一个<code>node</code>只有一块<code>index buffer</code>，所有<code>shard</code>共用。数据会在<code>index buffer</code>中排序、压缩</li> <li><code>index segment file</code>：存储倒排索引的文件，每个<code>segment</code>本质上就是一个倒排索引，每秒都会生成一个<code>segment</code>文件，当文件过多时<code>es</code>会自动进行<code>segment merge</code>（合并文件），合并时会同时将已经标注删除的文档物理删除</li> <li><code>commit point</code>：记录当前所有可用的<code>segment</code>（已经被<code>fsync</code>以后的数据，不包括在<code>page cache</code>的部分），每个<code>commit point</code>都会维护一个<code>.del</code>文件（<code>es</code>删除数据本质是不属于物理删除），当<code>es</code>做<strong>删改</strong>操作时首先会在<code>.del</code>文件中声明某个<code>document</code>已经被删除，文件内记录了在某个<code>segment</code>内某个文档已经被删除，当查询请求过来时在<code>segment</code>中被删除的文件是能够查出来的，但是当返回结果时会根据<code>commit point</code>维护的那个<code>.del</code>文件把已经删除的文档过滤掉（真正落磁盘的可能有多份数据，这个记录那个被删掉了）</li> <li><code>translog</code>：为了防止<code>elasticsearch</code>宕机造成数据丢失保证可靠存储，<code>es</code>会在每次写入数据的同时写到<code>translog</code>日志中(图中会有详解)。<code>shard</code>级别，一个<code>translog</code>对应一个<code>shard</code></li> <li><code>fsync</code>：<code>translog</code>会每隔<code>5s</code>或者在一个变更请求完成之后执行一次<code>fsync</code>操作，将<code>translog</code>从缓存刷入磁盘，这个操作比较耗时，如果对数据一致性要求不是很高时建议将索引改为异步，如果节点宕机时会有<code>5s</code>的数据丢失</li> <li><code>refresh</code>：<code>es</code>接收数据请求时先存入内存中，默认每隔一秒会从内存<code>buffer</code>中将数据写入<code>page cache</code>，这个过程叫做<code>refresh</code></li> <li><code>flush</code>：<code>es</code>默认每隔30分钟会将<code>page cache</code>中的数据刷入磁盘同时清空<code>translog</code>日志文件，这个过程叫做<code>flush</code></li></ol> <h3 id="es-写流程"><a href="#es-写流程" class="header-anchor">#</a> ES 写流程</h3> <p><img src="/images/es%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B.png" alt="ES写入原理"></p> <h2 id="es-scripting"><a href="#es-scripting" class="header-anchor">#</a> ES Scripting</h2> <h3 id="_1-使用script执行更新操作"><a href="#_1-使用script执行更新操作" class="header-anchor">#</a> 1. 使用<code>script</code>执行更新操作</h3> <div class="language-http extra-class"><pre class="language-http"><code>POST product2/_update/4
{
  &quot;script&quot;: {
    &quot;source&quot;: &quot;ctx._source.price-=1&quot;
  }
}
#可以简写
POST product2/_update/4
{
  &quot;script&quot;: &quot;ctx._source.price-=1&quot;
}
</code></pre></div><h3 id="_2-使用script执行脚本命令"><a href="#_2-使用script执行脚本命令" class="header-anchor">#</a> 2. 使用<code>script</code>执行脚本命令</h3> <div class="language-http extra-class"><pre class="language-http"><code>POST product2/_update/3
{
  &quot;script&quot;: {
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;source&quot;: &quot;ctx._source.tags.add('无线充电')&quot;
  }
}
#传参
POST product2/_update/3
{
  &quot;script&quot;: {
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;source&quot;: &quot;ctx._source.tags.add(params.tag_name)&quot;,
    &quot;params&quot;: {
      &quot;tag_name&quot;: &quot;无线充电&quot;
    }
  }
}
</code></pre></div><h3 id="_3-使用script执行删除操作"><a href="#_3-使用script执行删除操作" class="header-anchor">#</a> 3. 使用<code>script</code>执行删除操作</h3> <div class="language-http extra-class"><pre class="language-http"><code># delete
POST product2/_update/15
{
  &quot;script&quot;: {
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;source&quot;: &quot;ctx.op='delete'&quot;
  }
}
</code></pre></div><h3 id="_4-使用script执行插入更新操作"><a href="#_4-使用script执行插入更新操作" class="header-anchor">#</a> 4. 使用<code>script</code>执行插入更新操作</h3> <div class="language-http extra-class"><pre class="language-http"><code># upsert   smartison  update insert
#如果数据存在,执行partial update操作,如果数据不存在,那么执行create操作
GET /product2/_doc/15
POST product2/_update/15
{
  &quot;script&quot;: {
    &quot;source&quot;: &quot;ctx._source.price += params.param1&quot;,
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;params&quot;: {
      &quot;param1&quot;: 100
    }
  },
  &quot;upsert&quot;: {
    &quot;name&quot;: &quot;小米10&quot;,
    &quot;price&quot;: 1999
  }
}
</code></pre></div><h3 id="_5-使用script执行-bulk-操作"><a href="#_5-使用script执行-bulk-操作" class="header-anchor">#</a> 5. 使用<code>script</code>执行 _bulk 操作</h3> <div class="language-http extra-class"><pre class="language-http"><code># 错误的实例，需要改写成下面的语句
POST _bulk
{
  &quot;update&quot;:{
    &quot;_index&quot;:&quot;product2&quot;,
    &quot;_id&quot;:&quot;15&quot;,
    &quot;retry_on_conflict&quot;:3
  }
}
{
  &quot;script&quot;: {
    &quot;source&quot;: &quot;ctx._source.price += params.param1&quot;,
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;params&quot;: {
      &quot;param1&quot;: 100
    }
  },
  &quot;upsert&quot;: {
    &quot;name&quot;: &quot;小米10&quot;,
    &quot;price&quot;: 1999
  }
}
#改成_bulk批量操作呢
POST _bulk
{ &quot;update&quot; : { &quot;_id&quot; : &quot;0&quot;, &quot;_index&quot; : &quot;product2&quot;, &quot;retry_on_conflict&quot; : 3} }
{ &quot;script&quot; : { &quot;source&quot;: &quot;ctx._source.price += params.param1&quot;, &quot;lang&quot; : &quot;painless&quot;, &quot;params&quot; : {&quot;param1&quot; : 100}}, &quot;upsert&quot; : {&quot;price&quot; : 1999}}

</code></pre></div><h3 id="_6-script的其他语言支持"><a href="#_6-script的其他语言支持" class="header-anchor">#</a> 6. <code>script</code>的其他语言支持</h3> <ol><li>GET查询 除了<code>painless</code>(默认) ES还支持：</li> <li><ul><li><code>Groovy</code>：<code>ES1.4.X</code>——<code>ES5.0</code></li> <li><code>expression</code>：每个文档的开销较低：表达式的作用更多，可以非常快速地执行，甚至比编写native脚本还要快，支持javascript语法的子集：单个表达式。缺点：只能访问数字，布尔值，日期和geo_point字段，存储的字段不可用</li> <li><code>mustache</code>：提供模板参数化查询</li> <li><code>java</code></li> <li><code>Painless</code>：<code>Painless</code>是一种专门用于<code>Elasticsearch</code>的简单，用于内联和存储脚本，类似于Java，也有注释、关键字、类型、变量、函数等，安全的脚本语言。它是<code>Elasticsearch</code>的默认脚本语言，可以安全地用于内联和存储脚本</li></ul></li></ol> <div class="language-http extra-class"><pre class="language-http"><code>#这些语言应用场景更窄,但是可能性能更好
GET product2/_search
{
  &quot;script_fields&quot;: {
    &quot;test_field&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;:   &quot;expression&quot;,
        &quot;source&quot;: &quot;doc['price']&quot;
      }
    }
  }
}
GET product2/_search
{
  &quot;script_fields&quot;: {
    &quot;test_field&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;:   &quot;painless&quot;,
        &quot;source&quot;: &quot;doc['price'].value&quot;
      }
    }
  }
}
</code></pre></div><h3 id="_7-script脚本语言性能比较"><a href="#_7-script脚本语言性能比较" class="header-anchor">#</a> 7. <code>script</code>脚本语言性能比较</h3> <ol><li>Elasticsearch首次执行脚本时，将对其进行编译并将编译后的版本存储在缓存中。编译过程比较消耗性能。</li> <li>如果需要将变量传递到脚本中，则应以命名形式传递变量，<code>params</code>而不是将值硬编码到脚本本身中。例如，如果您希望能够将字段值乘以不同的乘数，请不要将乘数硬编码到脚本中</li></ol> <div class="language-http extra-class"><pre class="language-http"><code>#看took消耗
GET product2/_search
{
  &quot;script_fields&quot;: {
    &quot;test_field&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;:   &quot;expression&quot;,
        &quot;source&quot;: &quot;doc['price'] * 9&quot;
      }
    }
  }
}
GET product2/_search
{
  &quot;script_fields&quot;: {
    &quot;test_field&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;:   &quot;painless&quot;,
        &quot;source&quot;: &quot;doc['price'].value * 9&quot;
      }
    }
  }
}
#更换num的值 对比took消耗   
GET product2/_search
{
  &quot;script_fields&quot;: {
    &quot;test_field&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;:   &quot;expression&quot;,
        &quot;source&quot;: &quot;doc['price'] * num&quot;,
        &quot;params&quot;: {
          &quot;num&quot;: 6
        }
      }
    }
  }
}
#doc['price'] * num只编译一次而doc['price'] * 9 会随着数字改变而一直编译,ES默认每分钟支持15次编译
</code></pre></div><h3 id="_8-script多脚本支持"><a href="#_8-script多脚本支持" class="header-anchor">#</a> 8. <code>script</code>多脚本支持</h3> <div class="language-http extra-class"><pre class="language-http"><code>#例如 打8折价格
GET product2/_search
{
  &quot;script_fields&quot;: {
    &quot;discount_price&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;: &quot;painless&quot;,
        &quot;source&quot;: &quot;doc['price'].value * params.discount&quot;,
        &quot;params&quot;: {
          &quot;discount&quot;: 0.8
        }
      }
    }
  }
}
# 原始价格 和 多个打折价格
GET product2/_search
{
  &quot;script_fields&quot;: {
    &quot;price&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;: &quot;painless&quot;,
        &quot;source&quot;: &quot;doc['price'].value&quot;
      }
    },
    &quot;discount_price&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;: &quot;painless&quot;,
        &quot;source&quot;: &quot;[doc['price'].value * params.discount_8,doc['price'].value * params.discount_7,doc['price'].value * params.discount_6,doc['price'].value * params.discount_5]&quot;,
        &quot;params&quot;: {
          &quot;discount_8&quot;: 0.8,
          &quot;discount_7&quot;: 0.7,
          &quot;discount_6&quot;: 0.6,
          &quot;discount_5&quot;: 0.5
        }
      }
    }
  }
}
GET product2/_search
{
  &quot;script_fields&quot;: {
    &quot;discount_price&quot;: {
      &quot;script&quot;: {
        &quot;lang&quot;: &quot;painless&quot;,
        &quot;source&quot;: &quot;doc.price.value * params.discount&quot;,
        &quot;params&quot;: {
          &quot;discount&quot;: 0.8
        }
      }
    }
  }
}
# 那么遇到复杂脚本，写很多行怎么办呢
POST product2/_update/1
{
  &quot;script&quot;: {
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;source&quot;: &quot;&quot;&quot;
      ctx._source.name += params.name;
      ctx._source.price -= 1
    &quot;&quot;&quot;,
    &quot;params&quot;: {
      &quot;name&quot;: &quot;无线充电&quot;,
      &quot;price&quot;: &quot;1&quot;
    }
  }
}
</code></pre></div><h3 id="_9-stored-scripts-script模板"><a href="#_9-stored-scripts-script模板" class="header-anchor">#</a> 9. <code>Stored scripts</code>：<code>script</code>模板</h3> <ol><li>可以理解为<code>script</code>模板，缓存在集群的<code>cache</code>中，作用域为整个集群</li> <li>默认缓存大小是<code>100MB</code>，可以通过<code>script.cache.max_size</code>设置缓存大小</li> <li>没有过期时间，可以通过<code>script.cache.expire</code>设置过期时间</li> <li>脚本最大<code>64MB</code>，可以通过<code>script.max_size_in_bytes</code>设置脚本大小；有发生变更时会重新编译</li></ol> <p><font color="red"><strong>这里的<code>post</code>需要使用<code>doc</code>获取属性，因为这个最值是给<code>get</code>方法使用的</strong></font></p> <div class="language-http extra-class"><pre class="language-http"><code># 格式
# /_scripts/{id}  类似存储过程  计算折扣 作用域为整个集群
# 增加 script 模板
POST _scripts/calculate-discount
{
  &quot;script&quot;: {
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;source&quot;: &quot;doc['price'].value * params.discount&quot;
  }
}
# 查看 script 模板
GET _scripts/calculate-discount
# 删除 script 模板
DELETE _scripts/calculate-discount
# 使用 script 模板
GET product2/_search
{
  &quot;script_fields&quot;: {
    &quot;discount_price&quot;: {
      &quot;script&quot;: {
        &quot;id&quot;:&quot;calculate-discount&quot;,
        &quot;params&quot;: {
          &quot;discount&quot;: 0.8
        }
      }
    }
  }
}
</code></pre></div><h3 id="_10-dates-日期的使用"><a href="#_10-dates-日期的使用" class="header-anchor">#</a> 10. <code>Dates</code>：日期的使用</h3> <blockquote><p><code>ZonedDateTime</code>类型，因此它们支持诸如之类的方法<code>getYear</code>，<code>getDayOfWeek</code>或例如从<code>1970年</code>开始到该时间的毫秒数<code>getMillis</code>。要在脚本中使用它们，请省略<code>get</code>前缀并首字母小写的驼峰标识。</p> <ol><li>getMonth()</li> <li>getDayOfMonth()</li> <li>getDayOfWeek()</li> <li>getDayOfYear()</li> <li>getHour()</li> <li>getMinute()</li> <li>getSecond()</li> <li>getNano()</li></ol></blockquote> <div class="language-http extra-class"><pre class="language-http"><code># 时间类型的使用
GET product2/_search/1
{
  &quot;script_fields&quot;: {
    &quot;test_year&quot;: {
      &quot;script&quot;: {
        &quot;source&quot;: &quot;doc.createtime.value.year&quot;
      }
    }
  }
}
</code></pre></div><h3 id="_11-script正则表达式的支持"><a href="#_11-script正则表达式的支持" class="header-anchor">#</a> 11. <code>script</code>正则表达式的支持</h3> <blockquote><p>需要先启用配置：`script.painless.regex.enabled: true；会影响查询性能</p></blockquote> <div class="language-http extra-class"><pre class="language-http"><code>POST product2/_update/1
{
  &quot;script&quot;: {
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;source&quot;: &quot;&quot;&quot;
      if (ctx._source.name =~ /[\s\S]*phone[\s\S]*/) {
        ctx._source.name += &quot;***|&quot;;
      } else {
        ctx.op = &quot;noop&quot;;
      }
    &quot;&quot;&quot;
  }
}
#[0-9]{4}-[0-9]{2}-[0-9]{2}匹配出来的不一定是日期 比如  9999-99-99  但是日期一定能匹配上
POST product2/_update/1
{
  &quot;script&quot;: {
    &quot;lang&quot;: &quot;painless&quot;,
    &quot;source&quot;: &quot;&quot;&quot;
      if (ctx._source.createtime ==~ /[0-9]{4}-[0-9]{2}-[0-9]{2}/) {
        ctx._source.name += &quot;|***&quot;;
      } else {
        ctx.op = &quot;noop&quot;;
      }
    &quot;&quot;&quot;
  }
}
</code></pre></div><h3 id="_12-使用script进行聚合查询"><a href="#_12-使用script进行聚合查询" class="header-anchor">#</a> 12. 使用<code>script</code>进行聚合查询</h3> <div class="language-http extra-class"><pre class="language-http"><code>#统计所有小于1000商品tag的 数量 不考虑去重
GET /product/_search
GET /product/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: [
        {
          &quot;range&quot;: {
            &quot;price&quot;: {
              &quot;lt&quot;: 1000
            }
          }
        }
      ]
    }
  },
  &quot;aggs&quot;: {
    &quot;tag_agg_group&quot;: {
      &quot;sum&quot;: {
        &quot;script&quot;: {
          &quot;lang&quot;: &quot;painless&quot;,
          &quot;source&quot;: &quot;&quot;&quot;
            int total = 0;
            for (int i = 0; i &lt; doc['tags.keyword'].length; i++) {
               total++;
            }
            return total;
          &quot;&quot;&quot;
        }
      }
    }
  },
  &quot;size&quot;: 0
}
</code></pre></div><h3 id="_13-script关于上下文件对象"><a href="#_13-script关于上下文件对象" class="header-anchor">#</a> 13. <code>script</code>关于上下文件对象</h3> <blockquote><p><code>doc['field'].value</code>和<code>params['_source']['field']</code>：理解之间的区别是很重要的，<code>doc['field'].value</code>和<code>params['_source']['field']</code>。首先，使用<code>doc</code>关键字，将导致该字段的条件被加载到内存（缓存），这将导致更快的执行，但更多的内存消耗。此外，<code>doc[...]</code>符号只允许简单类型（不能返回一个复杂类型(<code>JSON</code>对象或者<code>nested</code>类型)），只有在非分析或单个词条的基础上有意义。但是，<code>doc</code>如果可能，使用仍然是从文档访问值的推荐方式，因为<code>_source</code>每次使用时都必须加载并解析。使用<code>_source</code>非常缓慢</p></blockquote> <ol><li><p>在 post 的请求当中, 使用<code>ctx._source.&lt;field-name&gt;</code>获取属性的值</p></li> <li><p>在 get 的请求当中，使用<code>doc['&lt;field-name&gt;']</code>获取属性的值</p></li> <li><p>在 expression 语言中使用<code>doc['&lt;field-name&gt;']</code>获取属性的值</p></li> <li><p>在 painless 语言中使用<code>doc['&lt;field-name&gt;'].value</code>获取属性的值</p></li> <li><p>在 painless 语言中，当数组中有对象时，使用<code>params['_source']['field-name']</code> 获取属性的值</p> <div class="language- extra-class"><pre class="language-text"><code>doc['field-name'].value =&gt; params['_source']['field-name']
</code></pre></div></li></ol> <h2 id="分词器"><a href="#分词器" class="header-anchor">#</a> 分词器</h2> <h3 id="作用"><a href="#作用" class="header-anchor">#</a> 作用</h3> <ol><li>分词</li> <li><code>normalization</code>（提升<code>recall</code>召回率：能搜索到的结果比率）</li></ol> <h3 id="分析器"><a href="#分析器" class="header-anchor">#</a> 分析器</h3> <h4 id="_1-character-filter-mapping"><a href="#_1-character-filter-mapping" class="header-anchor">#</a> 1. character filter（mapping）</h4> <p><strong>分词之前预处理</strong>：过滤无用字符、标签等，转换一些&amp;=&gt;and，《Elasticsearch》=&gt; Elasticsearch</p> <ol><li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-htmlstrip-charfilter.html" target="_blank" rel="noopener noreferrer">HTML Strip Character Filter<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：<code>html_strip</code>；</p> <ul><li>参数：<code>escaped_tags</code>需要保留的<code>html</code>标签</li></ul> <div class="language-http extra-class"><pre class="language-http"><code># character filter
# HTML Strip Character Filter
PUT my_index
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;char_filter&quot;: {
        &quot;my_char_filter&quot;: {
          &quot;type&quot;: &quot;html_strip&quot;,
          &quot;escaped_tags&quot;: [&quot;a&quot;]
        }
      },
      &quot;analyzer&quot;: {
        &quot;my_analyzer&quot;: {
          &quot;tokenizer&quot;: &quot;keyword&quot;,
          &quot;char_filter&quot;: [&quot;my_char_filter&quot;]
        }
      }
    }
  }
}
POST my_index/_analyze
{
  &quot;analyzer&quot;: &quot;my_analyzer&quot;,
  &quot;text&quot;: &quot;&lt;p&gt;I&amp;apos;m so &lt;a&gt;happy&lt;/a&gt;!&lt;/p&gt;&quot;
}
</code></pre></div></li> <li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-mapping-charfilter.html" target="_blank" rel="noopener noreferrer">Mapping Character Filter<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：type mapping</p> <div class="language-http extra-class"><pre class="language-http"><code># Mapping Character Filter
PUT my_index2
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;char_filter&quot;: {
        &quot;my_char_filter&quot;: {
          &quot;type&quot;: &quot;mapping&quot;,
          &quot;mappings&quot;: [
            &quot;٠ =&gt; 0&quot;,
            &quot;١ =&gt; 1&quot;,
            &quot;٢ =&gt; 2&quot;,
            &quot;٣ =&gt; 3&quot;,
            &quot;٤ =&gt; 4&quot;,
            &quot;٥ =&gt; 5&quot;,
            &quot;٦ =&gt; 6&quot;,
            &quot;٧ =&gt; 7&quot;,
            &quot;٨ =&gt; 8&quot;,
            &quot;٩ =&gt; 9&quot;
          ]
        }
      },
      &quot;analyzer&quot;: {
        &quot;my_analyzer&quot;: {
          &quot;tokenizer&quot;: &quot;keyword&quot;,
          &quot;char_filter&quot;: [
            &quot;my_char_filter&quot;
          ]
        }
      }
    }
  }
}
POST my_index2/_analyze
{
  &quot;analyzer&quot;: &quot;my_analyzer&quot;,
  &quot;text&quot;: &quot;My license plate is ٢٥٠١٥&quot;
}
</code></pre></div></li> <li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-replace-charfilter.html" target="_blank" rel="noopener noreferrer">Pattern Replace Character Filter<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：type pattern_replace</p> <div class="language-http extra-class"><pre class="language-http"><code># Pattern Replace Character Filter
PUT my_index3
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;char_filter&quot;: {
        &quot;my_char_filter&quot;: {
          &quot;type&quot;: &quot;pattern_replace&quot;,
          &quot;pattern&quot;: &quot;(\\d+)-(?=\\d)&quot;,
          &quot;replacement&quot;: &quot;$1_&quot;
        }
      },
      &quot;analyzer&quot;: {
        &quot;my_analyzer&quot;: {
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;char_filter&quot;: [&quot;my_char_filter&quot;]
        }
      }
    }
  }
}
POST my_index3/_analyze
{
  &quot;analyzer&quot;: &quot;my_analyzer&quot;,
  &quot;text&quot;: &quot;123-456-789&quot;
}
</code></pre></div></li></ol> <h4 id="_2-tokenizer-分词器"><a href="#_2-tokenizer-分词器" class="header-anchor">#</a> 2. tokenizer（分词器）</h4> <div class="language-http extra-class"><pre class="language-http"><code>GET _analyze
{
  &quot;tokenizer&quot; : &quot;standard&quot;,
  &quot;filter&quot; : [&quot;lowercase&quot;],
  &quot;text&quot; : &quot;THE Quick FoX JUMPs&quot;
}
</code></pre></div><div class="language-http extra-class"><pre class="language-http"><code>GET /_analyze
{
  &quot;tokenizer&quot;: &quot;standard&quot;,
  &quot;filter&quot;: [
    {
      &quot;type&quot;: &quot;condition&quot;,
      &quot;filter&quot;: [ &quot;lowercase&quot; ],
      &quot;script&quot;: {
        &quot;source&quot;: &quot;token.getTerm().length() &lt; 5&quot;
      }
    }
  ],
  &quot;text&quot;: &quot;THE QUICK BROWN FOX&quot;
}
</code></pre></div><h4 id="_3-token-filter"><a href="#_3-token-filter" class="header-anchor">#</a> 3. token filter</h4> <p>停用词、时态转换、大小写转换、同义词转换、语气词处理等。比如：has =&gt; have  him =&gt; he  apples =&gt; apple  the / oh / a=&gt;干掉</p> <div class="language-http extra-class"><pre class="language-http"><code>PUT /my_index4
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;analyzer&quot;: {
        &quot;my_analyzer&quot;:{
          &quot;type&quot;:&quot;standard&quot;,
          &quot;stopwords&quot;:&quot;_english_&quot;
        }
      }
    }
  }
}
# 使用自定义analysis
GET my_index4/_analyze
{
  &quot;analyzer&quot;: &quot;my_analyzer&quot;,
  &quot;text&quot;: &quot;Teacher Ma is in the restroom&quot;
}
# 使用系统自带analysis
GET my_index4/_analyze
{
  &quot;tokenizer&quot;: &quot;standard&quot;,
  &quot;filter&quot;:[&quot;lowercase&quot;],
  &quot;text&quot;: &quot;Teacher Ma is in the restroom&quot;
}
</code></pre></div><h3 id="es-内置分词器-7-6有15种自带分词器"><a href="#es-内置分词器-7-6有15种自带分词器" class="header-anchor">#</a> ES 内置分词器（7.6有15种自带分词器）</h3> <ol><li><code>standard analyzer</code>：默认分词器，中文支持的不理想，会逐字拆分
<ul><li><code>max_token_length</code>：最大令牌长度。如果看到令牌超过此长度，则将其<code>max_token_length</code>间隔分割。默认为255</li></ul></li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html" target="_blank" rel="noopener noreferrer">Pattern Tokenizer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：以正则匹配分隔符，把文本拆分成若干词项</li> <li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-simplepattern-tokenizer.html" target="_blank" rel="noopener noreferrer">Simple Pattern Tokenizer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：以正则匹配词项，速度比<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-tokenizer.html" target="_blank" rel="noopener noreferrer">Pattern Tokenizer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>快</li> <li><code>whitespace analyzer</code>：以空白符分隔<code>Tim_cookie</code></li></ol> <h3 id="自定义分析器"><a href="#自定义分析器" class="header-anchor">#</a> 自定义分析器</h3> <ol><li><code>tokenizer</code>：内置或自定义分词器。（需要）</li> <li><code>char_filter</code>：内置或自定义<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-charfilters.html" target="_blank" rel="noopener noreferrer">字符过滤器<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><code>filter</code>：内置或自定义<code>token filter</code></li> <li><code>position_increment_gap</code>：在为文本值数组建立索引时，<code>Elasticsearch</code>在一个值的最后一项和下一个值的第一项之间插入一个假的“空白”，以确保词组查询与来自不同数组元素的两项不匹配。默认为100。查看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/position-increment-gap.html" target="_blank" rel="noopener noreferrer">position_increment_gap<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>更多。</li></ol> <div class="language-http extra-class"><pre class="language-http"><code># 自定义 analysis
# 设置type为custom告诉Elasticsearch我们正在定义一个定制分析器。将此与配置内置分析器的方式进行比较： type将设置为内置分析器的名称，如 standard或simple
PUT /test_analysis
{
  &quot;settings&quot;: {
    &quot;analysis&quot;: {
      &quot;char_filter&quot;: {
        &quot;test_char_filter&quot;: {
          &quot;type&quot;: &quot;mapping&quot;,
          &quot;mappings&quot;: [
            &quot;&amp; =&gt; and&quot;,
            &quot;| =&gt; or&quot;
          ]
        }
      },
      &quot;filter&quot;: {
        &quot;test_stopwords&quot;: {
          &quot;type&quot;: &quot;stop&quot;,
          &quot;stopwords&quot;: [&quot;is&quot;,&quot;in&quot;,&quot;at&quot;,&quot;the&quot;,&quot;a&quot;,&quot;for&quot;]
        }
      },
      &quot;tokenizer&quot;: {
        &quot;punctuation&quot;: { 
          &quot;type&quot;: &quot;pattern&quot;,
          &quot;pattern&quot;: &quot;[ .,!?]&quot;
        }
      },
      &quot;analyzer&quot;: {
        &quot;my_analyzer&quot;: {
          &quot;type&quot;: &quot;custom&quot;,
          &quot;char_filter&quot;: [
            &quot;html_strip&quot;,
            &quot;test_char_filter&quot;
          ],
          &quot;tokenizer&quot;: &quot;standard&quot;,
          &quot;filter&quot;: [&quot;lowercase&quot;,&quot;test_stopwords&quot;]
        }
      }
    }
  }
}
GET /test_analysis/_analyze
{
  &quot;text&quot;: &quot;Teacher ma &amp; zhang also thinks [mother's friends] is good | nice!!!&quot;,
  &quot;analyzer&quot;: &quot;my_analyzer&quot;
}
</code></pre></div><h3 id="中文分词器"><a href="#中文分词器" class="header-anchor">#</a> 中文分词器</h3> <ol><li><p><code>IK</code>分词：<code>ES</code>的安装目录  不要有中文和空格</p> <ol><li>下载：https://github.com/medcl/elasticsearch-analysis-ik</li> <li>创建插件文件夹 <code>cd your-es-root/plugins/ &amp;&amp; mkdir ik</code></li> <li>将插件解压缩到文件夹<code>your-es-root/plugins/ik</code></li> <li>重新启动<code>es</code></li></ol></li> <li><p>两种<code>analyzer</code></p> <ol><li><code>ik_max_word</code>：细粒度</li> <li><code>ik_smart</code>：粗粒度</li></ol> <div class="language-http extra-class"><pre class="language-http"><code>GET _analyze
{
  &quot;analyzer&quot;: &quot;ik_smart&quot;,
  &quot;text&quot; : &quot;我爱中华人民共和国&quot;
}
GET _analyze
{
  &quot;analyzer&quot;: &quot;ik_max_word&quot;,
  &quot;text&quot; : &quot;我爱中华人民共和国&quot;
}
GET _analyze
{
  &quot;analyzer&quot;: &quot;standard&quot;,
  &quot;text&quot; : &quot;我爱中华人民共和国&quot;
}
</code></pre></div></li> <li><p><code>IK</code>文件描述</p> <ol><li><code>IKAnalyzer.cfg.xml</code>：IK分词配置文件</li> <li>主词库：<code>main.dic</code></li> <li>英文停用词：<code>stopword.dic</code>，不会建立在倒排索引中</li> <li>特殊词库：
<ul><li><code>quantifier.dic</code>：特殊词库：计量单位等</li> <li><code>suffix.dic</code>：特殊词库：后缀名</li> <li><code>surname.dic</code>：特殊词库：百家姓</li> <li><code>preposition</code>：特殊词库：语气词</li></ul></li> <li>自定义词库：比如当下流行词：857、emmm...、渣女、舔屏、996</li> <li>热更新</li> <li>修改<code>ik</code>分词器源码（<strong>最好是通过扩展的方式，不要硬改源码</strong>）</li> <li>基于<code>ik</code>分词器原生支持的热更新方案，部署一个<code>web</code>服务器，提供一个<code>http</code>接口，通过<code>modified</code>和<code>tag</code>两个<code>http</code>响应头，来提供词语的热更新</li></ol></li></ol> <h2 id="es-java-api"><a href="#es-java-api" class="header-anchor">#</a> ES Java API</h2></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">11/25/2022, 3:23:17 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/tiankafei-docs-架构/zookeeper学习笔记.html" class="prev">
        zookeeper学习笔记
      </a></span> <span class="next"><a href="/tiankafei-docs-架构/Tomcat源码分析.html">
        Tomcat源码分析
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a9dae821.js" defer></script><script src="/assets/js/2.63c13255.js" defer></script><script src="/assets/js/108.b9cdff35.js" defer></script>
  </body>
</html>
